# Sammeln von Benutzereingaben mit Formularen {#forms}

In diesem Kapitel werden Sie mit der Verwendung von Webformularen zum Sammeln von eingegeben 
Daten von Website-Nutzernvertraut gemacht. In Zend Framework 3 ist die Funktionalität
zum Arbeiten mit Formularen hauptsächlich auf vier Komponenten verteilt: die Komponente @`Zend\Form`,
mit dem Sie Formulare erstellen können und die View-Helper zum Rendern von Formularelementen enthält;
die Komponenten @`Zend\Filter`, @`Zend\Validator` und @`Zend\InputFilter`, mit denen Sie Benutzereingaben filtern
und validieren können.

|-----------------------|-----------------------------------------------------------|
| *Komponente* 			| *Beschreibung* 											|
|-----------------------|-----------------------------------------------------------|
| @`Zend\Form` 			| Enthält Basismodellklassen. 								|
|-----------------------|-----------------------------------------------------------|
| @`Zend\Filter` 		| Enthält verschiedene Filterklassen. 						|
|-----------------------|-----------------------------------------------------------|
| @`Zend\Validator` 	| Implementiert verschiedene Validator-Klassen. 			|
|-----------------------|-----------------------------------------------------------|
| @`Zend\InputFilter` 	| Implementiert einen Container für Filter und Validatoren.	|
|-----------------------|-----------------------------------------------------------|
| @`Zend\Mail` 			| Enthält die Funktionalität zum Senden von E-Mails. 		|
|-----------------------|-----------------------------------------------------------|

## Holen Sie sich das Form-Demo-Beispiel von GitHub

Wir demonstrieren die Verwendung von Formularen in der Beispiel-Webanwendung *Form Demo*, welches
mit dem Buch gebündelt ist. Dieses Beispiel ist eine vollständige Website, die Sie installieren können
und sehen Sie Formulare in Aktion.

Um die Anwendung *Form Demo* herunterzuladen, besuchen Sie
[diese Seite](https://github.com/olegkrivtsov/using-zf3-book-samples)
und klicken Sie auf die Schaltfläche *Klonen oder Herunterladen*, um den Code als ZIP-Archiv herunterzuladen.
Wenn der Download abgeschlossen ist, entpacken Sie das Archiv in ein Verzeichnis Ihrer Wahl.

Navigieren Sie dann zum Verzeichnis `formdemo`, dass den kompletten
Quellcode der Webanwendung *Form Demo* enthält:

{line-numbers=off,lang=text}
~~~
/using-zf3-book-samples
  /formdemo
  ...
~~~

T> Um das Beispiel zu installieren, können Sie entweder Ihre standardmäßige virtuelle Host-Datei bearbeiten
T> oder Sie eine Neue erstellen. Starten Sie nach dem Bearbeiten der Datei den Apache HTTP Server neu
T> und öffnen Sie die Website in Ihrem Webbrowser. Für weitere Informationen zu
T> Virtuelle Apache-Hosts finden Sie im [Anhang A. Web-Entwicklungsumgebung konfigurieren](#devenv).

## Über HTML-Formulare

Die von Zend Framework 3 bereitgestellte Formularfunktion verwendet intern HTML-Formulare.
Deshalb beginnen wir mit einer kurzen Einführung in das Thema HTML-Formulare.

In HTML sind Formulare in die Tags `<form>` und `</form>` eingeschlossen. Ein Formular besteht in der Regel
aus Elementen: Texteingabefelder, Checkboxen, Radio-Buttons, Sende-Buttons,
versteckte Textelementen usw. HTML bietet mehrere Tags zum Definieren von Formularelementen:

* `<input>` - gibt ein Eingabefeld an, in das der Benutzer einige Daten kann
   (Aussehen und Verhalten des Feldes hängen vom Feldtyp ab);
* `<textarea>` - mehrzeiliger Textbereich, der eine
   unbegrenzte Anzahl von Zeichen enthalten kann;
* `<button>` - eine anklickbare Schaltfläche[^button];
* `<select>` - eine Dropdown-Liste;
* `<option>` - wird innerhalb des Elements `<select>` zum Definieren der
   verfügbare Optionen in einer Dropdown-Liste verwendet.

[^button]: Das Feld `<button>` ist analog zu `<input type ="button">`. Jedoch
           bietet es zusätzliche Funktionen, z.B. wie das Angeben eines grafischen Symbols auf der Schaltfläche.

In Tabelle 7.1 finden Sie Beispiele für HTML-Formularfelddefinitionen. Abbildung 7.1 enthält
entsprechende Feldvisualisierungen (mit Ausnahme des Feldtyps "hidden", der keine visuelle Darstellung hat).

![Abbildung 7.1. Standard-HTML-Formularfelder](images/forms/standard_form_fields.png)

{title="Tabelle 7.1. Standard-HTML-Formularfelder"}
|---------------------------------------|-------------------------------------------------------------------|
| *Feld* 								| *Definition* 														|
|---------------------------------------|-------------------------------------------------------------------|
| Texteingabefeld 						| `<input type="text">` 											|
|---------------------------------------|-------------------------------------------------------------------|
| Textbereich 							| `<textarea rows=4></textarea>` 									|
|---------------------------------------|-------------------------------------------------------------------|
| Passwort 								| `<input type="password">` 										|
|---------------------------------------|-------------------------------------------------------------------|
| Button 								| `<input type="button" value="Anwenden">` oder 					|
| 										| `<button type="button">Anwenden</button>`  						|
|---------------------------------------|-------------------------------------------------------------------|
| Schaltfläche "Senden" 				| `<input type="submit" value="Senden">`  							|
|---------------------------------------|-------------------------------------------------------------------|
| Bild (grafische Übergabeschaltfläche)	| `<input type="image" src="button.jpg">` 							|
|---------------------------------------|-------------------------------------------------------------------|
| Reset-Button 							| `<input type="reset" value="Zurücksetzen">`  						|
|---------------------------------------|-------------------------------------------------------------------|
| Checkbox 								| `<input type="checkbox">Erinnere mich</input>` 					|
|---------------------------------------|-------------------------------------------------------------------|
| Radio 								| `<input type="radio" value="Radio">Erlaubt</input>` 				|
|---------------------------------------|-------------------------------------------------------------------|
| Select 								| `<select><option>Aktiv</option><option>Inaktiv</option></select>`	|
|---------------------------------------|-------------------------------------------------------------------|
| Datei 								| `<input type="file">`  											|
|---------------------------------------|-------------------------------------------------------------------|
| Verstecktes-Feld 						| `<input type="hidden">` 											|
|---------------------------------------|-------------------------------------------------------------------|

HTML5 führte mehrere neue Formularfelder ein (aufgelistet in Tabelle 7.2); Abbildung 7.2 enthält entsprechende
Feldvisualisierungen.

HTML5-Felder bieten bequemere Möglichkeiten zur Eingabe der am häufigsten verwendeten Datentypen:
Zahlen, Daten, E-Mails, URLs, etc. Zusätzlich kann der Webbrowser prüfen, ob die eingegebenen Daten des Benutzers
in einem korrekten Format vorliegen. Sind die Daten beim Daten beim Absenden des Formulars ungültig, wird der Browser
Formularübertragung verhindern und den Benutzer bitten, den Eingabefehler zu korrigieren.

{title="Tabelle 7.2. HTML5 Formularfelder"}
|-------------------------------|-----------------------------------------------|
| *Feld* 						| *Definition* 									|
|-------------------------------|-----------------------------------------------|
| Farbwähler 					| `<input type="color">` 						|
|-------------------------------|-----------------------------------------------|
| Datum 						| `<input type="date">` 						|
|-------------------------------|-----------------------------------------------|
| Datum-Uhrzeit (mit Zeitzone)	| `<input type="datetime">` 					|
|-------------------------------|-----------------------------------------------|
| Datum-Uhrzeit (ohne Zeitzone) | `<input type ="datetime-local">` 				|
|-------------------------------|-----------------------------------------------|
| E-Mail-Adresse 				| `<input type="email">` 						|
|-------------------------------|-----------------------------------------------|
| Nummer 						| `<input type="number">` 						|
|-------------------------------|-----------------------------------------------|
| Zeit 							| `<input type="time">` 						|
|-------------------------------|-----------------------------------------------|
| Monat 						| `<input type="month">` 						|
|-------------------------------|-----------------------------------------------|
| Woche 						| `<input type="week">` 						|
|-------------------------------|-----------------------------------------------|
| URL 							| `<input type="url">` 							|
|-------------------------------|-----------------------------------------------|
| Bereich (Schieberegler) 		| `<input type="range">` 						|
|-------------------------------|-----------------------------------------------|
| Suchfeld 						| `<input type="search" name="googlesearch">`	|
|-------------------------------|-----------------------------------------------|
| Telefonnummer					| `<input type="tel">` 							|
|-------------------------------|-----------------------------------------------|

![Abbildung 7.2. HTML5-Formularfelder](images/forms/html5_form_fields.png)

### Fieldsets

Sie können verwandte Formularfelder mit Hilfe des Tags `<fieldset>` zusammenfassen, wie in dem
Beispiel unten. Mit dem optionalen Tag `<legend>` können Sie die Beschriftung für die Gruppe definieren.

{line-numbers=off, lang=html}
~~~
<fieldset>
  <legend>Choose a payment method:</legend>
  <input type="radio" name="payment" value="paypal">PayPal</input>
  <input type="radio" name="payment" value="card">Credit Card</input>
</fieldset>
~~~

Das oben dargestellte HTML-Markup erzeugt die Gruppe wie in Abbildung 7.3:

![Abbildung 7.3. Fieldset](images/forms/fieldset.png)

### Beispiel: "Kontakt-Formular"

Ein Beispiel für ein typisches HTML-Formular ist unten dargestellt:

{line-numbers=on, lang=html}
~~~
<form name="contact-form" action="/contactus" method="post"> 
  <label for="email">E-mail</label>
  <input name="email" type="text">                              
  <br>        
  <label for="subject">Subject</label>            
  <input name="subject" type="text">                              
  <br>                
  <label for="body">Message</label>            
  <textarea name="body" class="form-control" rows="6"></textarea>
  <br>              
  <input name="submit" type="submit" value="Submit">       
</form>
~~~

Im obigen Beispiel haben wir das Kontakt-Formular, in dem der
Benutzer seine E-Mail-Adresse, einen Betreff und einen Text eingeben kann und diese dann an den Server zu senden.
Die Formulardefinition beginnt mit dem Tag `<form>` (Zeile 1).

Der  Tag`<form>` enthält mehrere wichtige Attribute:

* Das Attribut `name` gibt den Namen des Formulars ("contact-form") an.
* Das Attribut `action` definiert die URL des serverseitigen Skripts, welches
  verantwortlich für die Bearbeitung des eingereichten Formulars ("/contactus") ist.
* Das Attribut `method` definiert die Methode (entweder GET oder POST), die für die Übertragung der Formularaten
  an den Server verwendet werden soll. In diesem Beispiel verwenden wir die POST-Methode (empfohlen).

In Zeile 3 definieren wir ein Texteingabefeld mit Hilfe des Elements `<input>`. Das Attribut `name`
gibt den Namen des Feldes ("email") an. Das Attribut `type` definiert den Zweck des Elementes
(der Typ "text" bedeutet, dass das Eingabefeld für eine Texteingabe gedacht ist).

In Zeile 2 haben wir das Element `<label>`, dass die Bezeichnung für die E-Mail-Texteingabefeld 
darstellt (der Name des entsprechenden Eingabefeldes wird durch das Attribut `for` im Element
`<label>` bestimmt).

In den Zeilen 5-6 haben wir analog das Eingabefeld "Subject" und sein Label.

In Zeile 9 haben wir das Textfeld, das sich gut für die Eingabe mehrzeiliger Textes eignet.
Die Höhe des Textbereichs (6 Zeilen) wird durch die Zeilen Attribut `rows` definiert.

In Zeile 11 haben wir den Submit-Button (Eingabeelement mit Typ "submit").
Mit dem Attribut `value` können Sie den Text auf dem Button festlegen ("Submit").
Wenn Sie auf diesen Button klicken, sendet der Benutzer die Formulardaten an den Server.

Elemente für Zeilenumbruch `<br>` werden in den Zeilen 4, 7 und 10 zur Positionierung verwendet.
(sonst wären sie in der gleichen Zeile).

Um zu sehen, wie dieses Formular aussieht, können Sie den HTML-Markup-Code in eine `.html`-Datei einfügen
und diese in Ihrem Browser öffnen. Sie werden das fertige Formular, wie in Abbildung 7.4., sehen.


![Abbildung 7.4. Visualisierung des Kontakt-Formular](images/forms/typical_form.png)

Wenn Sie einige Daten in das Kontakt-Formular eingeben und auf den Button *Submit* klicken, wird der Webbrowser
einen HTTP-Request an die URL, die Sie im Attribut `action` des Formulars angegeben haben, senden.
Der HTTP-Request enthält die von Ihnen eingegebenen Daten.

### Methoden GET und POST

HTML-Formulare unterstützen die Methoden GET und POST, um die Daten an den Server zu übermitteln. Diese
Methoden haben wichtige technische Unterschiede.

Bei Verwendung der Methode POST zum Senden des Formulars, sind die Daten
im HTTP-Request-Body enthalten. Zum Beispiel, wenn Sie den Button *Submit* klicken,
wird ein HTTP-Request unseres Kontakt-Formular, wie im folgenden Beispiel generiert:
  
{line-numbers=on, lang=text}
~~~
POST http://localhost/contactus HTTP/1.1
Host: localhost
Connection: keep-alive
Content-Length: 76
Accept: text/html,application/xhtml+xml,application/xml
Origin: null
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Content-Type: application/x-www-form-urlencoded

email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit
~~~

Oben können Sie sehen, dass die Formulardaten im Request-Body übertragen werden (Zeile 10). Formularfelder
werden in einer einzigen Zeichenfolge verkettet und dann URL-codiert, um unsichere Zeichen durch erlaubte
Zeichen aus der ASCII-Tabelle zu ersetzen.

Wenn Sie im Gegensatz dazu die Methode GET für das Formular festlegen, wird ein HTTP-Request angezeigt
wie folgendener HTTP-Request generiert:

{line-numbers=on, lang=text}
~~~
GET http://localhost/contactus?email=name%40example.com&subject=Example+Subject&body=Hello%21&submit=Submit HTTP/1.1
Host: localhost
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Accept-Encoding: gzip,deflate,sdch

~~~

Wie Sie im obigen Beispiel sehen können, sind die Formulardaten verkettet, URL-codiert und werden
als Teil der URL des HTTP-Requests gesendet (Zeile 1), wodurch die URL lang und schwerer zu lesen ist.
Da die Formulardaten innerhalb der URL gesendet werden, ist dies für Website-Besucher leicht sichtbar.
 
In den meisten Fällen verwenden Sie die POST-Methode, um Formulardaten im HTTP-Request-Body zu übertragen,
weil der Benutzer die Daten in der Navigationsleiste im Browser nicht sehen muss
(insbesondere bei der Übermittlung von Passwörtern oder anderen sensiblen Daten).

W> Bitte beachten Sie, dass das Senden von Formulardaten mit der POST-Methode Ihre Daten
W> sensible Daten nicht vor dem Diebstahl schützt (wie Passwörter, Kreditkartennummern usw.). Um
W> solche Daten zu schützen, müssen Sie Ihren HTTP-Datenverkehr über eine [SSL](https://de.wikipedia.org/wiki/Transport_Layer_Security) Verbindung leiten
W> (SSL steht für Secure Sockets Layer). Geschützte SSL-Verbindungen unterscheiden sich durch die
W> Verwendung des Schemas *https://* in Webseiten-URLs. Um SSL in Ihrem Apache HTTP Server zu aktivieren,
W> müssen Sie ein SSL-Zertifikat von einem vertrauenswürdigen Anbieter erhalten
W> (wie [VeriSign](http://www.verisign.com/)) und es auf Ihrem Server installieren.

## HTML Formulare mit Twitter Bootstrap formatieren

In ZF3-basierten Websites verwenden wir das Twitter-Bootstrap-CSS-Framework, das den Standard bereitstellt
CSS-Regeln zum Formatieren von Formularen und Formularfeldern. Sie wenden die CSS-Regeln auf ein Formularfeld
(wie `<input>`, `<textarea>`, usw.) an, wenn Sie ihm die CSS-Klasse `.form-control` zuweisen. Zusätzlich,
wenn Sie Labels zusammen mit Eingabefeldern verwenden, legen Sie die Label-Eingabe-Paare innerhalb des Elementes `<div>` ab.
Weisem Sie dem DIV-Element dann die CSS-Klasse `.form-group` zu. Für Submit-Buttons können Sie die CSS-Klasse `.btn` und ein Theme,
wie zum Beispiel die CSS-Klasse `.btn-default`,` .btn-primary` usw. verwenden.

Im Folgenden siehen Sie das angepasste Beispiel des Kontakt-Formulars mit
Twitter Bootstrap:

{line-numbers=off, lang=html}
~~~
<h1>Contact Us</h1>

<p>
    Please fill out the following form to contact us. 
    We appreciate your feedback. 
</p>

<form name="contact-form" action="/contactus" method="post">        

  <div class="form-group">
    <label for="email">Your E-mail</label>
    <input name="email" type="text" class="form-control" 
           placeholder="name@example.com">
  </div>
        
  <div class="form-group">
    <label for="subject">Subject</label>            
    <input name="subject" type="text" class="form-control" 
           placeholder="Type subject here">                              
  </div>
        
  <div class="form-group">
    <label for="body">Message Body</label>            
    <textarea name="body" class="form-control" rows="6" 
              placeholder="Type message text here"></textarea>
  </div>
        
  <input name="submit" type="submit"
         class="btn btn-primary" value="Submit">
</form>
~~~

Die Visualisierung des Formulars ist in Abbildung 7.5 dargestellt.

![Abbildung 7.5. Gestyltes Kontakt-Formular](images/forms/styled_contact_form.png)

Weil Twitter Bootstrap entwickelt wurde, um Mobiltelefone, Tablets und
Desktops zu unterstützen, passt die Formularfelder der Größe des Bildschirms an. Das macht vielleicht
Ihr Formular zu breit oder schwer zu verstehen. Um die Formularbreite zu begrenzen,
können Sie das von Bootstrap bereitgestellte Grid-System verwenden, wie im folgenden Beispiel gezeigt:

{line-numbers=off, lang=html}
~~~
<div class="row">
  <div class="col-md-6">
    <form>
      ...		
    </form>
  </div>    
</div>
~~~

Im obigen HTML-Markup fügen wir ein Formular in die Gitterzelle mit 6 Spalten ein.
Das Formular nimmt jetzt die halbe Breite des Bildschirms ein.

## Installation von ZF3-Formularkomponenten

Um Formulare in einer MVC-Webanwendung zu verwenden, müssen Sie mindestens das Paket
`zendframework/zend-mvc-form` mit Composer installieren:

~~~
php composer.phar require zendframework/zend-mvc-form
~~~

Wenn Sie dieses Paket installieren, wird alles abhänigen Komponente installiert,
welche die Formulare in ZF3 implementieren: @`Zend\Form`, @`Zend\InputFilter`, @`Zend\Filter`, @`Zend\Validator`,
und noch manch andere.

## Abrufen von Formulardaten in einer Controller-Aktion

Der Website-Benutzer arbeitet normalerweise mit dem Formular in der folgenden Reihenfolge:

* Zunächst wird die Aktion eines Controllers ausgeführt, die die Webseite mit enthaltenen 
  Formular rendert, welches den Benutzer der Seite zur Eingabe auffordert.
  Sobald der Benutzer die Formularfelder gefüllt hat, klickt er auf den Button *Submit*.
  Durch diesen wird ein HTTP-Request erzeugt und die Daten werden an den Server gesendet.
* Zweitens, können Sie in der Aktionsmethode Ihres Controllers auf
  die übergebenen Daten aus den Variablen POST (und / oder GET) zugreifen
  und eine Seite mit den Ergebnissen der Formularverarbeitung anzeigen.
  
In der Regel werden diese beiden Webseiten von *der gleichen* Controller-Aktion bearbeitet.
 
Im folgenden Beispiel zeigen wir, wie Sie eine Controller-Aktion zum Anzeigen des Kontakt-Formulars 
und zum Abrufen der vom Benutzer übermittelten Daten erstellen können.
Erstellen Sie zunächst das View-Template *contact-us.phtml* im Verzeichnis *application/index/* unterhalb
des Verzeichnisses *view/* Ihres Moduls (siehe Abbildung 7.6).

![Abbildung 7.6. Erstellen der Datei contact-us.phtml](images/forms/contactus_file.png)

Fügen Sie den HTML-Markup-Code des Kontakt-Formulars aus dem vorherigen Abschnitt
in das View-Template ein.

Dann fügen Sie der Klasse `IndexController` die Aktionsmethode `contactUsAction()` hinzu. In der Aktionmethode
werden wir die Rohdaten aus dem Kontakt-Formular des Seite-Benutzers extrahieren:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Controller;

// ...

class IndexController extends AbstractActionController 
{
  // This action displays the feedback form
  public function contactUsAction() 
  {
    // Check if user has submitted the form
    if($this->getRequest()->isPost()) {
      
	  // Retrieve form data from POST variables
	  $data = $this->params()->fromPost();     
	  
	  // ... Do something with the data ...
	  var_dump($data);	  
    } 
        
    // Pass form variable to view
    return new ViewModel([
          'form' => $form
       ]);
  }
}
~~~

Im obigen Code definieren wir die Aktionsmethode `contactUsAction()` in der
Klasse `IndexController` (Zeile 9).

In Zeile 12 prüfen wir dann, ob es sich bei der Anfrage um einen POST-Request handelt (Prüfung
die Startzeile des HTTP-Request). In der Regel verwendet das Formular die POST-Methode
um die Daten zu übermitteln. Aus diesem Grund können wir feststellen, ob das Formular übermittelt wurde oder nicht.
indem Sie die Startzeile des HTTP-Request prüfen.

In Zeile 15 rufen wir die Rohdaten ab, die vom Benutzer gesendet wurden. Wir extrahieren alle POST-Variablen
mit Hilfe des Controller Plugins @`Params`. Die Daten werden in Form eines Arrays zurückgegeben und
in der Variable `$data` gespeichert.

Schließlich müssen wir eine literale Route hinzufügen, um eine kurze und einprägsame URL
für die Seite *Kontakt* erstellen. Fügen Sie der Routing-Konfiguration in der Datei *module.config.php*
den Schlüssel `contactus` hinzu:

{line-numbers=off, lang=php}
~~~
<?php
return [
  // ...
  'router' => [
    'routes' => [
      // Add the following routing rule for the "Contact Us" page 
      'contactus' => [
        'type' => Literal::class,
          'options' => [
             'route'    => '/contactus',
             'defaults' => [
               'controller' => Controller\IndexController::class,
               'action'     => 'contactUs',
             ],
           ],
         ],
       ],		 
    ],
  ],  
  // ...
];

~~~

Wenn Sie jetzt die URL "http://localhost/contactus" in die Navigationsleiste Ihres Webbrowsers eingeben,
sollten Sie die Seite wie in Abbildung 7.7 sehen.

![Abbildung 7.7. Kontakt-Formular](images/forms/feedback_form.png)

Geben Sie eine E-Mail, einen Betreff und Nachrichtentext ein. Klicken Sie abschließend im Formular auf 
den Button *Submit*. Die Daten werden an den Server gesendet und schließlich werden Sie
in der Methode `IndexController::contactUsAction()` extrahiert.

Unten ein Beispiel für das Array `$data` (erzeugt mit derPHP-Funktion `var_dump()`). 
Wie Sie sehen können, enthält das Array einen Schlüssel für jedes Formularfeld und
einschließlich des Feldes "Submit".

{line-numbers=off, lang=php}
~~~
array (size=4)
    'email' => string 'name@example.com' (length=16)
    'subject' => string 'Happy New Year!' (length=15)
    'body' => string 'Dear Support, I'd like to thank you for the 
              excellent quality of your support service and wish you 
              a Happy New Year!' (length=118)
    'submit' => string 'Submit' (length=6)
~~~

## Formulare und der Model-View-Controller

Im vorherigen Abschnitt haben wir einen sehr einfache Nutzung von Formularen betrachtet: Wir haben das
View-Template mit HTML-Markup für ein Formular und einer Controller Aktion, die unser Formular anzeigt
und rohen Benutzereingaben auf dem Bildschirm ausgibt. Allerdings hat das Verwenden von rohen Benutzereingaben im realen
Anwendungen ein Nachteil, denn übermittelte Daten von Benutzern können fehlrhaft sein oder bösartigen Code enthalten.
Hier werden wir besprechen, wie man eine solche Daten prüft (validiert).

Auf einer ZF3-basierten Website, die das Model-View-Controller-Pattern verwendet, ist in der Regel 
die Formularfunktionalität in *FormModels* enthalten, die für die Felddefinition, Filterung und
Validierung zuständif ist; sowie für die *Formulardarstellung* (View), die typischerweise mit der Hilfe 
von speziellen View-Helpern implementiert wird.

Die Funktionalität ermöglicht das Erstellen von Formularmodellen sowie das Hinzufügen von Filter-und Validierungsregeln und
das verwenden von View-Helper. Das ist schematisch in Abbildung 7.8 dargestellt. Wie Sie der Abbildung entnehmen können, wird die
Funktionalität der Standard-HTML-Formulare als Grundlage verwendet.

![Abbildung 7.8. Formularfunktionen in ZF3](images/forms/html_zf2_forms.png)

Der MVC-Ansatz zum Arbeiten mit Formularen bietet folgende Vorteile:

* Sie können Ihr Formularmodell in verschiedenen Aktionen des Controllers wiederverwenden.
* Mit den View-Helpern können Sie die langweilige Vorbereitung des HTML-Markups (teilweise)
  zum Rendern des Formulars vermeiden und seiner möglichen Validierungsfehler.
* Sie können eine oder mehrere visuelle Darstellungen für dasselbe Formularmodell erstellen.
* Indem Sie die Formularvalidierungslogik in einer einzigen Formularmodellklasse kapseln,
  haben Sie weniger Stellen in Ihrem Code, wo Sie die Benutzereingaben überprüfen müssen, also Sie
  verbessern die Sicherheit Ihrer Website.
  
### Eine typische Formularverarbeitung

Im Allgemeinen instanziieren Sie ein Formularmodell in der Aktion-Methode des Controllers.
Dann rufen Sie die vom Benutzer gesendeten Daten aus den PHP-Variablen ab
und übergeben Sie diese zur Validierung an das Formularmodell.
Formular-View-Helper werden im View-Template zum Generieren des HTML-Markup des Formulars 
verwendet. Dieser typische Vorgang ist in Abbildung 7.9 dargestellt.

![Abbildung 7.9. Verarbeitung eines Formular in einer MVC-Anwendung](images/forms/forms_and_mvc.png)

Die Pfeile in Abbildung 7.9 zeigen die Richtung der Aktionen an:

1. Zuerst rufen Sie innerhalb der Aktionsmethode des Controllers die
   Daten vom Seite-Benutzer aus den Variablen GET, POST (und möglicherweise anderen), die von PHP übermittelt werden,
   ab. Dann erstellen Sie eine Instanz des Formularmodells und übergeben die vom Benutzer
   angegebenen Daten. Die Arbeit des Formularmodells besteht darin, die Formulardaten auf Richtigkeit 
   zu überprüfen (zu validieren) und wenn etwas nicht stimmt, Fehlermeldung(en)
   für jedes ungültige Formularfeld zu generieren.
   
2. Zweitens übergeben Sie das Formularmodell an das View-Template `.phtml` zum
   Rendern (mit Hilfe des Variablencontainers @`ViewModel`[Zend\View\Model\ViewModel]). Das
   View-Template kann dann auf das Formularmodell zugreifen und die nötigen
   Methoden aufrufen.
   
3. Und schließlich verwendet das View-Template das Formularmodell und die View-Helper, die
   von Zend Framework 3 bereitgestellt werden, um die Formularfelder zu rendern (und mögliche
   Validierungsfehlernachrichten, die in der Validierungsphase erzeugt wurden, anzuzeigen).
   Als Ergebnis wird das HTML-Markup des Formulars erzeugt.

In den folgenden Abschnitten werden wir diese ausführlicher behandeln.

## Ein Formularmodell

Ein Formularmodell ist normalerweise eine PHP-Klasse, die eine Anzahl von *Feldern* erzeugt.
Die Basisklasse für alle Formularmodelle ist die Klasse @`Form`[Zend\Form\Form], die in der Komponenten 
@`Zend\Form` definiert ist.

Felder in einem Formularmodell können optional mit *fieldsets* gruppiert werden. Außerdem das Formularmodell
selbst kann als ein Fieldset betrachtet werden. Diese Tatsache spiegelt sich in der Vererbung der Klasse `Form` wider
(Abbildung 7.10).

![Abbildung 7.10. Vererbung der Klasse Form](images/forms/form_inheritance.png)

Wie Sie der Abbildung entnehmen können, erweitert die Klasse @`Form`[Zend\Form\Form] die Klasse @`Fieldset`.
Die Klasse @`Fieldset` wird wiederum von der Klasse @`Element` abgeleitet, die eine einzelne Klasse für
Formularfelder und seine Attribute darstellt.

T> Diese Klassenvererbung mag auf den ersten Blick seltsam aussehen, aber alles ist logisch,
T> wenn Sie sich erinnern, dass die Klasse @`Form`[Zend\Form\Form] Methoden zum Hinzufügen von Formularfeldern von 
T> der Klasse @`Fieldset` erbt. Damit erbt sie die Methoden zum Setzen von Formularattributen aus der Klasse @`Element`.

Im Folgenden stellen wir einen Auschnitt einer Modellklasse für das Kontakt-Formular aus unserem vorherigen Beispielen bereit:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;

// A feedback form model
class ContactForm extends Form
{
  // Constructor.   
  public function __construct()
  {
    // Define form name
    parent::__construct('contact-form');

    // Set POST method for this form
    $this->setAttribute('method', 'post');
  
    // (Optionally) set action for this form
    $this->setAttribute('action', '/contactus');
  
    // Create the form fields here ...	
  }
}
~~~

Wie Sie sehen können, gehören die Formularmodelle des Moduls `Application` unserer Website
zum Namensraum `Application\Form` (Zeile 2).

In Zeile 7 definieren wir die Modellklasse `ContactForm`, die die Basisklasse @`Form`[Zend\Form\Form] erweitert.

In Zeile 10 definieren wir die Konstruktormethode für die Klasse. Weil wir unser Formularmodell
von der Basisklasse @`Form`[Zend\Form\Form] ableiten, müssen wir den Konstruktor der Elternklasse zur Initialisierung aufrufen
(Zeile 13). Der Konstruktor der Elternklasse akzeptiert ein optionales Argument, mit dem der Name des Formulars festgelegt werden kann
('contact-form').

Wir legen die Übermittlungsmethode (POST) für das Formular auch festlegen, indem Sie die Methode `setAttribute()` 
verwenden, die von der Basisklasse bereitgestellt wird (Zeile 16). Die Methode `setAttribute()` benötigt zwei Parameter:
Der erste ist der Name des festzulegenden Attributs und der zweite der Wert des
Attribut.

Sie können auch das Attribut "action" des Formulars (Zeile 19) mit der Methode `setAttribute()` setzen,
wie wir es mit dem Attribut "method" gemacht haben. Wie Sie später sehen werden, ist das Festlegen des Attributs "action" des Formulars optional.

I> Das Attribut "action" für das Formular ist optional, denn wenn es leer ist,
I> ist der Browser gezwungen, die Formulardaten an die URL der aktuellen Seite 
I> übermitteln. Dies ist in den meisten Szenarien ausreichend, weil Sie normalerweise
I> in einer Controller-Action  das Formular anzuzeigen
I> und seine Daten verarbeiten.

Formularfelder werden normalerweise innerhalb des Konstruktors des Formularmodells erstellt
(siehe Zeile 21). Im nächsten Abschnitt werden wir lernen, welche Formularfelder
verfügbar sind und wie Sie sie zum Formularmodell hinzufügen können.

## Formularelemente

In einem Formularmodell wird ein Eingabefeld typischerweise mit der Textbezeichnung (Tags `<label>` und `<input>`)
zusammen benutzt. Ein solches Paar wird auch als *Element* im Formularmodell bezeichnet.

Analog zu einem HTML-Formularfeld kann das Element eines Formularmodells den Namen und andere (optional)
Attribute (z.B. "id", "class", etc.) enthalten. Zusätzlich können Sie *options* auf ein Element setzen;
Mit den Optionen können Sie meist den Text und die Attribute für die Beschriftung des Elements festlegen.

Alle Elemente des Formularmodells werden von der Basisklasse @`Element` übernommen, die ebenfalls eine Klasse
der Komponote @`Zend\Form` ist. Die Basisklasse `Element` implementiert die Schnittstelle @`ElementInterface`.
Das Klassenvererbungsdiagramm ist in Abbildung 7.11 dargestellt.

![Abbildung 7.11. Vererbung der Form-Element-Klasse](images/forms/form_element_inheritance.png)

Konkrete Form-Element-Klassen erweitern die Basisklasse @`Element`. Sie sind in den Tabellen 7.3 - 7.7 aufgeführt.
Diese Klassen befinden sich im Namesraum @`Zend\Form\Element`[Zend\Form].

{title="Tabelle 7.3. Formularelemente, die mit HTML 4 kompatibel sind"}
|-------------------------------------------|-------------------------------|
| *Klassenname* 							| *Beschreibung* 				|
|-------------------------------------------|-------------------------------|
| @`Button` 								| Button-Element. 				|
|-------------------------------------------|-------------------------------|
| @`Checkbox`[Zend\Form\Element\Checkbox]	| Checkbox-Element 				|
|-------------------------------------------|-------------------------------|
| @`File`[Zend\Form\Element\File] 			| Datei-Element 				|
|-------------------------------------------|-------------------------------|
| @`Hidden` 								| Verstecktes Textfeld. 		|
|-------------------------------------------|-------------------------------|
| @`Image`[Zend\Form\Element\Image] 			| Bildfeld. 					|
|-------------------------------------------|-------------------------------|
| @`Password`[Zend\Form\Element\Password] 	| Passwortfeld 					|
|-------------------------------------------|-------------------------------|
| @`Radio` 									| Radio-Element. 				|
|-------------------------------------------|-------------------------------|
| @`Select`[Zend\Form\Element\Select] 		| Auswahlmenü. 					|
|-------------------------------------------|-------------------------------|
| @`Submit` 								| Button "Senden" 				|
|-------------------------------------------|-------------------------------|
| @`Text`[Zend\Form\Element\Text]  			| Allgemeines Texteingabefeld	|
|-------------------------------------------|-------------------------------|
| @`Textarea` 								| Mehrzeiliger Textbereich 		|
|-------------------------------------------|-------------------------------|

{title="Tabelle 7.4. Formularelemente, die mit HTML 5 kompatibel sind"}
|-------------------------------------------|---------------------------------------------------|
| *Klassenname* 							| *Beschreibung* 									|
|-------------------------------------------|---------------------------------------------------|
| @`Color` 									| Farbwähler. 										|
|-------------------------------------------|---------------------------------------------------|
| @`Date`[Zend\Form\Element\Date] 			| Datumsauswahl. 									|
|-------------------------------------------|---------------------------------------------------|
| @`DateTime`[Zend\Form\Element\DateTime]	| Datum und Uhrzeit (mit Zeitzone) 					|
|-------------------------------------------|---------------------------------------------------|
| @`DateTimeLocal` 							| Datum und Uhrzeit (ohne Zeitzone) 				|
|-------------------------------------------|---------------------------------------------------|
| @`Email` 									| E-Mail Eingabefeld 								|
|-------------------------------------------|---------------------------------------------------|
| @`Month` 									| Monat Eingabefeld 								|
|-------------------------------------------|---------------------------------------------------|
| @`Number`[Zend\Form\Element\Number] 		| Ein Texteingabefeld, das nur Zahlen akzeptiert.	|
|-------------------------------------------|---------------------------------------------------|
| @`Time`[Zend\Form\Element\Time] 			| Texteingabefeld zur Eingabe der Uhrzeit dient 	|
|-------------------------------------------|---------------------------------------------------|
| @`Url`[Zend\Form\Element\Url] 				| Texteingabefeld zur Eingabe einer URL. 			|
|-------------------------------------------|---------------------------------------------------|
| @`Week` 									| Texteingabefeld zur Eingabe von Wochentagen. 		|
|-------------------------------------------|---------------------------------------------------|
| @`Range`[Zend\Form\Element\Range] 			| Bereichsfeld (Schieberegler). 					|
|-------------------------------------------|---------------------------------------------------|

{title="Tabelle 7.5. Zusammengesetzte Elemente"}
|-------------------------------------------------------|-----------------------------------------------|
| *Klassenname* 										| *Beschreibung* 								|
|-------------------------------------------------------|-----------------------------------------------|
| @`MultiCheckbox` 										| Eine Gruppe von verwandten Kontrollkästchen.	|
|-------------------------------------------------------|-----------------------------------------------|
| @`DateTimeSelect`[Zend\Form\Element\DateTimeSelect]	| Datum und Zeit auswählen. 					|
|-------------------------------------------------------|-----------------------------------------------|
| @`DateSelect`[Zend\Form\Element\DateSelect] 			| Datum auswählen 								|
|-------------------------------------------------------|-----------------------------------------------|
| @`MonthSelect`[Zend\Form\Element\MonthSelect] 			| Monat auswählen 								|
|-------------------------------------------------------|-----------------------------------------------|

{title="Tabelle 7.6. Sicherheitsformularelemente"}
|-------------------------------------------------------|-----------------------------------------------|
| *Klassenname* 					| *Beschreibung* 													|
|-------------------------------------------------------|-----------------------------------------------|
| @`Captcha` 						| Element mit einem [Prüftbild für Menschen.](https://de.wikipedia.org/wiki/Captcha) |
|-------------------------------------------------------|-----------------------------------------------|
| @`Csrf`[Zend\Form\Element\Csrf] 	| Schutzelement vor Cross-Site-Request-Forgery[^csrf]. 				|
|-------------------------------------------------------|-----------------------------------------------|

{title="Tabelle 7.7. Weitere Formularelemente"}
|-----------------------------------------------|---------------------------|
| *Klassenname* 								| *Beschreibung* 			|
|-----------------------------------------------|---------------------------|
| @`Collection`[Zend\Form\Element\Collection] 	| Sammlung von Elementen. 	|
|-----------------------------------------------|---------------------------|

In den obigen Tabellen sehen Sie, dass die von ZF3 bereitgestellten Formularelemente direkt auf HTML4 abgebildet werden
und HTML5 Eingabefelder (am Anfang dieses Kapitels besprochen).

Für Ihre Bequemlichkeit bietet ZF3 auch mehrere "zusammengesetzte" Felder. Das
@`MultiCheckbox` ist ein Feld, das sich aus einer Gruppe von typischen Checkboxen zusammensetzt. 
Die Elemente @`DateTimeSelect`[Zend\Form\Element\DateTimeSelect], @`DateSelect`[Zend\Form\Element\DateSelect] und @`MonthSelect`[Zend\Form\Element\MonthSelect] sind analog zu den entsprechenden
HTML5-Elemente, aber werden mit den üblichen Auswahlfeldern kombiniert. Diese Eingabefelder haben den Vorteil, dass sie,
im Gegensatz zu den entsprechenden HTML5-Feldern, von allen Webbrowsern unterstützt werden. Die visuelle Darstellung von
diesen Elemente ist in Abbildung 7.12 zu sehen.

![Abbildung 7.12. Zusammengesetzte Formularfelder](images/forms/compound_form_fields.png)

Zusätzlich bietet ZF3 "Sicherheits" -Formularfelder @`Captcha`[Zend\Form\Element\Captcha] und @`Csrf`[Zend\Form\Element\Csrf].
Diese können zur Verbesserung der Sicherheit für ein Formular verwendet werden. Das @`Captcha-Element`[Zend\Form\Element\Captcha] ist ein grafisches Element (Bild),
welches in einem Formular platziert, um zu überprüfen, ob der Benutzer der Seite ein Mensch ist oder ein Roboter. Das Element @`Csrf`[Zend\Form\Element\Csrf] hat
keine visuelle Darstellung und wird verwendet, um
Hackerangriffen im Zusammenhang mit Cross-Site-Request-Forgery[^csrf] zu verhindern.

[^csrf]: Cross-Site Request Forgery (CSRF) ist eine Art böswilliger Exploit von
         einer Website, auf der nicht autorisierte Befehle von einem Benutzer übertragen werden können.
         Das macht eine Webseite verwundbar.

Es gibt ein weiteres spezielles Formularelement namens @`Collection`. Dieses Element ist analog zu Fieldset,
weil es Ihnen ermöglicht, verwandte Formularelemente zu gruppieren. Es ist jedoch zum dynamischen Hinzufügen von Formularelementen vorgesehen.
Die Elemente werdem als Objekte in ein Array an das Formular gebunden.

### Hinzufügen von Elementen zu einem Formularmodell

Die von der Basisklasse @`Form`[Zend\Form\Form] von der Klasse @`Fieldset` geerbten Methoden werden verwendet,
damit Sie dem Formularmodell Elemente (und Feldgruppen) hinzu können. Diese Methoden sind in der Tabelle 7.8 zusammengefasst.

{title="Tabelle 7.8. Von der Fieldset-Klasse bereitgestellte Methoden"}
|-----------------------------------|-------------------------------------------------------------------|
| *Methodenname* 					| *Beschreibung* 													|
|-----------------------------------|-------------------------------------------------------------------|
| `add($elementOrFieldset, $flags)`	| Fügt ein Element (oder ein Feldset) hinzu. 						|
|-----------------------------------|-------------------------------------------------------------------|
| `has($elementOrFieldset)` 		| Überprüft, ob ein bestimmtes Element angehängt ist. 				|
|-----------------------------------|-------------------------------------------------------------------|
| `get($elementOrFieldset)` 		| Gibt das angegebene Element (oder Feldset) nach den Name zurück. 	|
|-----------------------------------|-------------------------------------------------------------------|
| `getElements()` 					| Gibt alle angefügten Elemente zurück. 							|
|-----------------------------------|-------------------------------------------------------------------|
| `getFieldsets()` 					| Gibt alle angefügten Feldgruppen zurück. 							|
|-----------------------------------|-------------------------------------------------------------------|
| `count()` 						| Gibt die Anzahl der angehängten Elemente oder Feldgruppen zurück.	|
|-----------------------------------|-------------------------------------------------------------------|
| `remove($elementOrFieldset)` 		| Entfernt das Element (oder das Feldset). 							|
|-----------------------------------|-------------------------------------------------------------------|

Besonders interessiert uns die Methode `add()`, die zum Anhängen eines Elementes zu einem Formaular 
verwendet wird. Die Methode `add()` benötigt zwei Argumente: das erste (namens `$elementOrFieldset`)
ist ein einzufügendes Element und das zweite (namens `$flags`) ist das optionale Flag.

Der Parameter `$elementOrFieldset` ist entweder eine Instanz von einer abgeleiteten Klasse von
@`Element` (oder von der Klasse @`Fieldset`) oder ein Array, das das Element beschreibt
was erstellt werden soll.

Das optionale Argument `$flags` ist ein Array, das eine Kombination der folgenden Schlüssel enthalten kann: `name`
(erlaubt Ihnen, den Namen des Elements zu setzen) und `priority` (ermöglicht die Angabe eines Null-basierten
Index in der Liste der Elemente, in die das Element eingefügt werden soll). Wenn das Prioritätsflag nicht
angegeben ist, wird das Element am Ende der Liste der Elemente des Formularmodells eingefügt.

Im Folgenden stellen wir zwei Codebeispiele vor, die beide möglichen Arten des Hinzufügens von
Elemente zu einem Formular veranschaulichen.

### Methode 1: Übergeben einer Instanz eines Elements

Das folgende Codefragment erstellt eine Instanz der Klasse @`Zend\Form\Element\Text`
und fügt das Element dem Formularmodell hinzu:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

// Define an alias for the class name
use Zend\Form\Form;
use Zend\Form\Element\Text;

// A feedback form model
class ContactForm extends Form
{
  // Constructor.   
  public function __construct()
  {
    // Create the form fields here ...	
    $element = new Text(
                'subject',            // Name of the element
                [                     // Array of options
                 'label'=> 'Subject'  // Text label
                ]);
    $element->setAttribute('id', 'subject');

    // Add the "subject" field to the form
    $this->add($element);
  }
}
~~~

Im obigen Code haben wir eine Instanz der Klasse @`Zend\Form\Element\Text` erstellt (Zeile 15). Der
Klassenkonstruktor nimmt zwei Parameter entgegen: den Namen des Elements ("Subject") und ein Array von Optionen
(Hier geben wir die Textbezeichnung "subject" an).

Darüber hinaus können Sie das Element mithilfe der Methoden konfigurieren, die von der Basisklasse @`Element` bereitgestellt werden.
Zum Beispiel setzen wir in Zeile 20 das Attribut "id" mit der Methode `setAttribute()`. Für Ihre Referenz
die (wichtigsten) Methoden der Basisklasse @`Element`, welche verwendet werden können, um
Formularelements zu konfigurieren, finden Sie in Tabelle 7.9.

{title="Tabelle 7.9. Von der Element-Klasse bereitgestellte Methoden"}
|---------------------------------------|---------------------------------------------------------------|
| *Methodenname* 						| *Beschreibung* 												|
|---------------------------------------|---------------------------------------------------------------|
| `setName($name)` 						| Legt den Namen des Elements fest. 							|
|---------------------------------------|---------------------------------------------------------------|
| `getName()` 							| Gibt den Namen des Elements zurück. 							|
|---------------------------------------|---------------------------------------------------------------|
| `setOptions($options)` 				| Legt Optionen fest. 											|
|---------------------------------------|---------------------------------------------------------------|
| `getOptions $options)` 				| Gibt Optionen zurück. 										|
|---------------------------------------|---------------------------------------------------------------|
| `getOption($option)` 					| Gibt die angegebene Option zurück. 							|
|---------------------------------------|---------------------------------------------------------------|
| `setAttribute($key, $value)` 			| Legt ein einzelnes Elementattribut fest. 						|
|---------------------------------------|---------------------------------------------------------------|
| `getAttribute($key)` 					| Gibt ein einzelnes Elementattribut zurück. 					|
|---------------------------------------|---------------------------------------------------------------|
| `removeAttribute($key)` 				| Entfernt ein Attribut. 										|
|---------------------------------------|---------------------------------------------------------------|
| `hasAttribute($key)` 					| Prüft, ob ein solches Attribut vorhanden ist. 				|
|---------------------------------------|---------------------------------------------------------------|
| `setAttributes($arrayOrTraversable)`	| Setzt eine Gruppe von Attributen. 							|
|---------------------------------------|---------------------------------------------------------------|
| `getAttributes()` 					| Gibt alle Attribute auf einmal zurück. 						|
|---------------------------------------|---------------------------------------------------------------|
| `clearAttributes()` 					| Entfernt alle Attribute auf einmal. 							|
|---------------------------------------|---------------------------------------------------------------|
| `setValue()` 							| Setzt den Elementwert. 										|
|---------------------------------------|---------------------------------------------------------------|
| `getValue()` 							| Gibt den Elementwert zurück. 									|
|---------------------------------------|---------------------------------------------------------------|
| `setLabel()` 							| Setzt die Bezeichnung, die für dieses Element verwendet wird. |
|---------------------------------------|---------------------------------------------------------------|
| `getLabel()` 							| Gibt die für dieses Element verwendete Label-String zurück. 	|
|---------------------------------------|---------------------------------------------------------------|
| `setLabelAttributes()` 				| Setzt die Attribute für die Beschriftung. 					|
|---------------------------------------|---------------------------------------------------------------|
| `getLabelAttributes()` 				| Gibt die Attribute zurück, die mit dem Label verwendet werden	|
|										| sollen. 														|
|---------------------------------------|---------------------------------------------------------------|
| `setLabelOptions()` 					| Setzt bestimmt Optionen für das Label. 						|
|---------------------------------------|---------------------------------------------------------------|
| `getLabelOptions()` 					| Gibt bestimmt Optionen für das Label zurück. 					|
|---------------------------------------|---------------------------------------------------------------|

### Methode 2: Verwenden der Array-Spezifikation

Das zweite Beispiel unten (entspricht dem ersten) zeigt, wie man ein Element durch eine Beschreibung
mit Hilfe eienes Arrays dem Formular hinzufügt. Diese Methode wird bevorzugt, da man
weniger Code schreiben braucht.

I> Wenn Sie die Array-Spezifikation zum Hinzufügen eines Elements zu einem Formular verwenden, wird das Element
I> automatisch instanziiert und konfiguriert. Intern wird dies mit der
I> Hilfe der Factory-Klasse @`Zend\Form\Factory` erledigt (siehe Abbildung 7.13).

![Abbildung 7.13. Die Logik der Methode add()](images/forms/factory_graph.png)

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

// Define an alias for the class name
use Zend\Form\Form;

// A feedback form model
class ContactForm extends Form
{
  // Constructor.   
  public function __construct()
  {
    // Add "subject" field
    $this->add([
      'type'  => 'text',        // Element type
      'name' => 'subject',      // Field name
      'attributes' => [         // Array of attributes
        'id'  => 'subject',     
      ],
      'options' => [            // Array of options
         'label' => 'Subject',  // Text label
      ],
    ]);    
  }
}
~~~

In Zeile 14 oben rufen wir die Methode `add()` des Formularmodells auf, um das Element zum Formular hinzuzufügen.
Wir übergeben die Eigenschaften des Elements an die Methode `add ()` in Form eines Arrays. Das Array
hat folgenden typischen Schlüssel:

* Der Schlüssel `type` (Zeile 15) definiert den Klassennamen, der für die Instantiierung des Elements verwendet werden soll. Hierzu
  kann entweder den vollständige Klassennamen (z.B. `Text::class`) oder seinen kurzen Alias ​​[^alias] (z.B. "text") verwendet werden.

* Der Schlüssel `name` (Zeile 16) definiert den Namen für das Feld ("Betreff").

* Der Schlüssel `attributes` (Zeile 17) definiert eine Liste der zu setzenden HTML-Attribute (hier setzen wir das Attribut "id").

* Das Array `options` (Zeile 18) ermöglicht Ihnen, die Textbeschriftung für das Element anzugeben.
  
[^alias]: Wenn Sie verwirrt sind, woher wir Element-Aliase nehmen, sollten Sie
          wissen, dass sie in der Klasse @`Zend\Form\FormElementManager\FormElementManagerTrait` definiert sind.
  
## Beispiel: Erstellen eines FormModel für ein Kontakt-Formular

Nun wissen wir, wie Sie die Attribute für den Formularnamen, die Action und die Methode festlegen können und wie Sie
Felder (Elemente) hinzufügen können. Für das Formular erstellen wir die vollständige Modellklasse für ein Kontaktformular.
Dieses haben wir in unseren vorherigen Beispielen verwendet.

Wie wir wissen, liegen die Modell-Klassen für das Modul `Application'
im Namensraum `Application\Form`. Also müssen wir eine Datei
*ContactForm.php* innerhalb des Verzeichnisses *Form* unter dem
Quellverzeichnis des Moduls *Application* erstellen (Abbildung 7.14).

![Abbildung 7.14. Formularverzeichnis](images/forms/form_dir.png)

Wir werden zwei Methoden in unserer Formularklasse haben:

* Der Konstruktor `__construct()` definiert den Formularnamen und die Methode (POST) und
  initialisiert das Formular, indem er die Elemente hinzufügen.
* Die private Methode `addElements()` enthält den eigentlichen Code zum
  Hinzufügen von Formularelementen und wird vom Konstruktor aufgerufen.
  
I> Wir haben die Feld-Erstellungslogik in die private Methode `addElements()` ausgelagert,
I> um den Code des Formularmodells besser zu strukturieren.

Der Code der Klasse `ContactForm` ist nachfolgend dargestellt:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;

/**
 * This form is used to collect user feedback data like user E-mail, 
 * message subject and text.
 */
class ContactForm extends Form
{
  // Constructor.   
  public function __construct()
  {
    // Define form name
    parent::__construct('contact-form');

    // Set POST method for this form
    $this->setAttribute('method', 'post');
        	
    // Add form elements
    $this->addElements();    
  }
    
  // This method adds elements to form (input fields and 
  // submit button).
  private function addElements() 
  {
    // Add "email" field
    $this->add([
	        'type'  => 'text',
            'name' => 'email',
            'attributes' => [                
                'id' => 'email'
            ],
            'options' => [
                'label' => 'Your E-mail',
            ],
        ]);
        
    // Add "subject" field
    $this->add([
            'type'  => 'text',
            'name' => 'subject',
            'attributes' => [
              'id' => 'subject'  
            ],
            'options' => [
                'label' => 'Subject',
            ],
        ]);
        
    // Add "body" field
    $this->add([
            'type'  => 'text',
            'name' => 'body',			
            'attributes' => [                
			  'id' => 'body'
            ],
            'options' => [
                'label' => 'Message Body',
            ],
        ]);
        
    // Add the submit button
    $this->add([
            'type'  => 'submit',
            'name' => 'submit',
            'attributes' => [                
                'value' => 'Submit',
            ],
        ]);
    }        
}
~~~

In Zeile 10 oben definieren wir die Klasse `ContactForm`, die von 
der Basisklasse @`Form`[Zend\Form\Form] abgeleitet wird.

In den Zeilen 13-23 haben wir die Konstruktormethode. Er ruft den Konstruktor der Basisklasse
auf (Zeile 16) und übergibt den Formularnamen als Argument ("contact-form").
In Zeile 19 wird die Methode `setAttribute()` der Basisklasse aufgerufen, mit der Sie die Übertragungsmethode
für das Formular festlegen (wir legen die POST-Methode fest).

In Zeile 22 wird die private Methode `addElements()` aufgerufen, die die eigentliche Arbeit erledigt.
Diese fügt die Elemente zum Formular hinzu. Der Code der Methode `addElements()` befindet sich in den Zeilen 27-73.
Um dem Formular Elemente hinzuzufügen, rufen wir die Methode `add()` auf, die von der Basisklasse bereitgestellt wird.
Diese Methode akzeptiert als Argument nur ein Array, das die Konfiguration für ein
Element enthält. Wir fügen vier Felder hinzu: `email`, `subject`, `body` und `submit'.

In Abbildung 7.15 sehen Sie eine schematische grafische Darstellung des Formularmodells.

![Abbildung 7.15. Das Kontakt-Formular-Modell und seine Elemente](images/forms/form_model.png)

## Formularfilterungs- und Überprüfungsregeln hinzufügen

Formularvalidierung ist das Verfahren zum Filtern und Überprüfen der an den Server übergebenen Daten
während der Formularübergabe. Zum Beispiel möchten wir an unserem Kontakt-Formular
die folgenden Überprüfungen durchführen:

* Wir möchten testen, dass die E-Mail-Adresse, der Nachrichten Betreff und der Text immer sind
  vorhanden (weil diese *Pflicht*-Felder sind).
* Wir möchten sicherstellen, dass der Benutzer eine gültige E-Mail-Adresse wie *name@example.com* eingegeben hat.
* Benutzer können Leerzeichen am Anfang und/oder am Ende der E-Mail-Adresse hinzufügen.
  Solche Zeichen möchten wir herausfiltern (entfernen von Whitespaces von Anfang und Ende eines Strings).
* Es wäre sinnvoll, nach der minimal und maximal zulässigen Länge des Betreffs der Nachricht zu prüfen.
* Für den Betreff der Nachricht möchten wir Zeilenumbrüche und HTML-Tags [^html] herausfiltern (strippen).
* Wir möchten auch HTML-Tags aus dem Nachrichtentext entfernen.

[^html]: Es kann böswillige Benutzer geben, die HTML-Code in die Nachricht einfügen. Wenn Sie
         solchen Code in Ihrem Browser öffnen, können Sie einige unerwünschte Inhalte sehen. Dafür
         müssen wir HTML-Tags in Betreff und Text der Nachricht ersetzen.

Die obigen Anforderungen werden *Filter- und Validierungsregeln* genannt. Diese Regeln sind in
in zwei Kategorien unterteilt: Filter und Validatoren.

Die *Filter* transformieren die vom Benutzer eingegebenen Daten, um mögliche Fehler zu beheben
oder um sicherzustellen, dass die Daten einem bestimmten Format entsprechen. Filter werden in der Regel zuerst angewendet,
Validatoren werden in der letzten Runde angewendet.

*Validatoren* überprüfen, ob die Daten akzeptabel sind oder nicht. Wenn alle Daten korrekt sind,
wird das Formular als gültig betrachtet und die Daten können von der Geschäftslogikebene sicher verwendet werden.
Wenn ein bestimmtes Feld ungültig ist, löst ein Validierer ein Fehlerflag aus. In diesem Fall wird das Formular
dem Benutzer normalerweise erneut angezeigt und der Benutzer wird aufgefordert, Eingabefehler zu korrigieren und
das Formular erneut zum Server zu senden.

Q> **Was passiert, wenn ich keine Validierungsregel für ein bestimmtes Formularfeld hinzufüge?**
Q>
Q> Wenn Sie keine Validierungsregel hinzufügen, wird der vom Benutzer gesendete Feldwert ungeprüft verwendet.
Q> Dies hinterlässt ein Loch in der Sicherheit Ihrer Website. Es wird empfohlen
Q> für jedes vom Benutzer eingegebene Formularfeld immer eine Validierungsregel hinzufügen und so viele
Q> Überprüfungen für jedes Feld nach Bedarf hinzuzufügen, um so Ihr Formular sicher zu halten.

### Eingabefilter

In ZF3 sind die Filter- und Validierungsregeln in der Klasse @`InputFilter`[Zend\InputFilter\InputFilter] enthalten.
Die Klasse @`InputFilter`[Zend\InputFilter\InputFilter] ist in der Komponente @`Zend\InputFilter` definiert.
Der Eingabefilter ist ein Container für so genannte *Inputs*. In der Regel fügen Sie eine Eingabe
für jedes Feld des Formularmodells hinzu.

I> Eine Eingabe kann aus Filtern und / oder Validatoren und einigen zusätzlichen Informationen bestehen.
I> Zum Beispiel kann eine Eingabe das Flag enthalten, das anzeigt, ob es ein Pflichtfeld ist oder ob sein Wert
I> über den HTTP-Request nicht übertragen wurde.

Analog zum Hinzufügen von Formularmodellfeldern gibt es zwei Möglichkeiten zum Hinzufügen
von Inputs an den Eingabefilter-Container: Entweder durch Übergabe einer Instanz einer Input-Klasse 
als Argument der Methode `add()` oder durch Übergabe einer Array-Spezifikation[^inputfactory].
Im nächsten Abschnitt werden wir die letztere Methode beschreiben (diese ist einfacher,
weil es weniger Code zum Schreiben benötigt).

[^inputfactory]: Im letzteren Fall (Array-Spezifikation) wird die Eingabe
                 automatisch mit Hilfe der Klasse @`Zend\InputFilter\Factory` erstellt.

### Hinzufügen von Eingaben zum Eingabefilter

Um dem Eingabefilter eine Eingabe hinzuzufügen, verwenden Sie die Methode `add()`, die ein einziges
Argument verwendet - eine Array-Spezifikation der Eingabe in der folgenden Form:

{line-numbers=on, lang=php}
~~~
[
  'name'     => '<name>',
  'type'     => '<type>',
  'required' => <required>,
  'filters'  => [
     // Add filters configuration here ...
  ],                
  'validators' => [
     // Add validators configuration here ...
  ]
]
~~~

Im obigen Array haben wir folgende Schlüssel:

* Den Schlüssel `name` (Zeile 2) definiert den Namen der Eingabe. Der Name sollte der gleiche sein,
  wie der Name des Formularmodells Feld. Wenn der Name der Eingabe nicht gleich
  dem Namen des entsprechenden Formularmodells ist, wird die Validierungsregel
  nicht auf das Feld angewendet.
  
* Der Schlüssel `type' (Zeile 3) definiert den Klassennamen der Eingabe. Dieser Schlüssel ist optional.
  Standardmäßig (wenn dieser Schlüssel weggelassen wird) wird die Klasse @`Zend\InputFilter\Input` verwendet.
  Verfügbare Eingabeklassen sind in Abbildung 7.16 dargestellt. In Abbildung 7.16 ist die Klasse @`Input'[Zend\InputFilter\Input]
  für die Verwendung mit regulären Skalarwerten gedacht, @`ArrayInput` wird verwendet,
  um Array-Werte zu Filtern/Validieren und @`FileInput` wird zum Überprüfen hochgeladener Dateien verwendet.
  
* Der Schlüssel `required` (Zeile 4) gibt an, ob das Formularfeld erforderlich oder optional ist. Wenn es
  ein Pflichtfeld ist, dann muss der Site-Benutzer es ausfüllen, sonst wird er einen Validierungsfehler
  erhalten.
  
* Die Schlüssel `filters` (Zeile 5) und` validators` (Zeile 8) können die Konfiguration für keine,
  einen oder mehrere Filter und/oder Validatoren enthalten, die auf das Feld des Formularmodells angewendet werden sollen.

![Abbildung 7.16. Vererbung der Eingabeklasse](images/forms/input_inheritance.png)

#### Filterkonfiguration

Eine typische Filterkonfiguration ist nachfolgend dargestellt:

{line-numbers=on, lang=php}
~~~
[
  'name' => '<filter_name>',  
  'priority' => <priority>,
  'options' => [
    // Filter options go here ...
  ]
],                    
~~~

Der Schlüssel `name` (Zeile 2) ist der Name für den Filter. Dieser kann der
vollständige Filterklassenname (z.B. `StringTrim::class`) sein oder ein Alias ​​(z.B. @`StringTrim`).

Der optionale Schlüssel `priority` (Zeile 3) definiert die Filterpriorität in der Filterliste. Die Priorität
muss eine ganze Zahl sein. Die Filter mit der höchsten Priorität werden zuerst angewendet. Standardmäßig
wird die Konstante `FilterChain::DEFAULT_PRIORITY` (Wert 1000) wird zugewiesen.

Das Array `options` (Zeile 4) ist spezifisch für einen bestimmten Filter und kann
Parameter zum Konfigurieren des Filters enthalten.

#### Validiererkonfiguration

Eine typische Validiererkonfiguration wird im Folgenden vorgestellt:
  
{line-numbers=on, lang=php}
~~~
[
  'name' => '<validator_name>',
  'break_chain_on_failure' => <flag>,
  'options' => [
    // Validator options go here ...
  ]
],                    
~~~
  
Der Schlüssel `name` (Zeile 2) ist der Name des Validators. Dieser  ann der
vollständige Validierungsklassenname (z.B. `EmailAddress::class`) sein oder ein Alias
(z.B. @`EmailAddress`).

Der optionale Schlüssel `break_chain_on_failure` (Zeile 3) definiert das Verhalten,
falls die Validierungsprüfung fehlschlägt. Wenn auf `true` gesetzt, werden nachfolgende Validatoren
in der Liste nicht ausgeführt; andernfalls wird jede Regel in der Liste ausgeführt,
unabhängig von dem Ergebnis anderer Validatoren.

Das Array `options` (Zeile 4) ist spezifisch für bestimmte Validator-Klassen und kann
Parameter zum Konfigurieren des Validators enthalten.
    
### Eingabefilter für das Kontaktformular erstellen

Nun haben Sie eine allgemeine Vorstellung, wie Sie den Eingabefilter-Container definieren können
und wie Sie ihn mit Filtern und Validatoren für jedes Formularfeld füllen können. Lassen Sie uns
unsere `ContactForm`-Formmodellklasse vervollständigen. Unten fügen wir die private Methode `addInputFilter()` 
hinzu, die die Filter-und Validierungsregeln definiert und im Eingangsfilter-Container speichert wird:

{line-numbers=on, lang=php}
~~~
<?php
// ...
use Zend\InputFilter\InputFilter;

class ContactForm extends Form
{
  public function __construct()
  {
    // ... call this method to add filtering/validation rules
    $this->addInputFilter();
  }
    
  // ...
    
  // This method creates input filter (used for form filtering/validation).
  private function addInputFilter() 
  {
    // Get the default input filter attached to form model.
    $inputFilter = $this->getInputFilter();
        
    $inputFilter->add([
        'name'     => 'email',
        'required' => true,
        'filters'  => [
           ['name' => 'StringTrim'],                    
        ],                
        'validators' => [
           [
            'name' => 'EmailAddress',
            'options' => [
              'allow' => \Zend\Validator\Hostname::ALLOW_DNS,
              'useMxCheck' => false,                            
            ],
          ],
        ],
      ]
    );
        
    $inputFilter->add([
        'name'     => 'subject',
        'required' => true,
        'filters'  => [
           ['name' => 'StringTrim'],
           ['name' => 'StripTags'],
           ['name' => 'StripNewlines'],
        ],                
        'validators' => [
           [
            'name' => 'StringLength',
              'options' => [
                'min' => 1,
                'max' => 128
              ],
           ],
        ],
      ]
    );
    
    $inputFilter->add([
        'name'     => 'body',
        'required' => true,
        'filters'  => [                    
          ['name' => 'StripTags'],
        ],                
        'validators' => [
          [
            'name' => 'StringLength',
            'options' => [
              'min' => 1,
              'max' => 4096
            ],
          ],
        ],
      ]
    );                
  }  
}
~~~

Wie Sie aus dem obigen Code sehen können, deklarieren wir zunächst den Alias ​​für die
@`Zend\InputFilter\InputFilter` Klasse (Zeile 3).

Im Konstruktor des Formularmodells (Zeile 10) rufen wir die Methode `addInputFilter()` auf,
welche wir in den Zeilen 16-76 definieren.

Das Ziel der Methode `addInputFilter()` ist es Filter-und Validierungsregeln für den Container `InputFilter`
hinzuzufügen (Zeilen 21-75). Zum Einfügen von Filter-und Validierungsregeln in den Eingabefiltercontainer,
verwenden wir die Methode `add()`, welche von der Klasse `InputFilter` bereitgestellt wird, welche die Arrayspezifikation
einer zu erstellenden Eingabe verwendet.

Wir fügen drei Eingaben hinzu (für jedes Feld unseres Formularmodells, mit Ausnahme des Buttons "Submit"):

* Für das Feld `email` setzen wir das Flag `required` auf `true`, um dieses als
  Pflichtfeld zu deklarieren. Wir verwenden den Filter @`StringTrim`, um Leerstellen aus der E-Mail-Adresse von Anfang 
  und am Ende zu entfernen; und den Validator @`EmailAddress`, um die Richtigkeit, der vom Benutzer eingebenen
  E-Mail-Adresse, zu überprüfen. Wir konfigurieren den Validator @`EmailAddress` so,
  dass er Domänennamen in den E-Mail-Adressen zulässt (den Flag `\Zend\Validator\Hostname::ALLOW_DNS`)
  und deaktivieren die Überprüfung des MX-Datensatzes (setzen die Option `useMxCheck` auf `false`).

* Für das Feld `subject` machen wir es analog und verwenden den Filter @`StringTrim`
  um Leerstellen vom Anfang und vom Ende zu entfernen. Zusätzlich verwenden wir die Filter @`StripNewlines`
  und @`StripTags`, um die Zeilenumbrüche bzw. die HTML-Tags herauszufiltern.
  Wir beschränken die Länge der Betreffzeile auf 1 bis 128 Zeichen, indem wir den
  @`StringLength` Validator verwenden.

* Das Feld `body` markieren wir als Pflichtfeld und wir wenden den Filter @`StripTags` an, um
  HTML-Tags aus dem E-Mail-Text entfernen. Wir benutzen auch den Validator @`StringLength`, um
  die Länge des E-Mail-Textes zwischen 1 und 4096 Zeichen zu beschränken.

In Abbildung 7.17 finden Sie die schematische grafische Darstellung der Eingabe
Filter, den wir erstellt haben.
  
![Abbildung 7.17. Der Eingabefilter für ContactForm](images/forms/input_filter.png)
  
T> Oben haben wir kurz beschrieben, wie ein Eingabefilter für das Formularmodell erstellt wird.
T> Detaillierte Informationen zu den oben genannten (und anderen) Filtern und Validatoren und deren
T> Anwendungsbeispiele finden Sie unter [Transformieren von Eingabedaten mit Filtern](#filters) und
T> [Eingabedaten mit Validatoren prüfen](#validators).

## Verwenden des Formulars in der Aktion eines Controllers

Wenn die Formularmodellklasse bereit ist, können Sie das Formular schließlich in einer
Aktionsmethode des Controllers verwenden.

Wie Sie vielleicht bereits wissen, ist die Art, wie der Seite-Benutzer mit dem Formular arbeitet, normalerweise
ein iterativer Prozess (schematisch in Abbildung 7.18 dargestellt):

![Abbildung 7.18. Typischer Ablauf einer Formularverwendung](images/forms/form_workflow.png)

 * Zuerst zeigen Sie das Formular und seine Felder auf einer Webseite an und fordern den Benutzer
   zur Eingabe auf. Sobald der Benutzer die Formularfelder ausgefüllt hat, klickt er auf den Button *Submit*
   und die Daten an den Server sendet.
 * Als nächstes extrahiert Ihr Controller die übermittelten
   Daten und ruft das Formularmodell auf, welches die Daten validiert. Wenn Eingabefehler aufgetreten sind,
   wird das Formular erneut an angezeigt und den Benutzer gebeten, die Eingabefehler zu korrigieren. Wenn die Daten
   richtig sind, werden die Daten mit Ihrer Business-Logik-Ebene verarbeiten und (in der Regel)
   der Benutzer wird auf eine andere Webseite umgeleitet.
   
Die Basisklasse @`Form`[Zend\Form\Form] bietet mehrere Methoden, um dieses zu erreichen (siehe Tabelle 7.11).

{title="Tabelle 7.11. Methoden der Formular-Basisklasse"}
|---------------------------------------|-----------------------------------------------------------|
| *Methodenname* 						| *Beschreibung* 											|
|---------------------------------------|-----------------------------------------------------------|
| `setData($data)` 						| Setzt Formulardaten für die Validierung. 					|
|---------------------------------------|-----------------------------------------------------------|
| `getData($flag)` 						| Gibt die validierten Daten zurück. 						|
|---------------------------------------|-----------------------------------------------------------|
| `isValid()` 							| Prüft das Formular. 										|
|---------------------------------------|-----------------------------------------------------------|
| `hasValidated()` 						| Prüft, ob das Formular validiert wurde. 					|
|---------------------------------------|-----------------------------------------------------------|
| `getMessages($elementName = null)` 	| Gibt eine Liste von Validierungsfehlermeldungen zurück.	|
| 										| Falls vorhanden für ein einzelnes Element oder für alle	|
|										| Formularelemente. 										|
|---------------------------------------|-----------------------------------------------------------|

Ein typischer Ablauf einer Formularnutzung ist also der folgende:

* Überprüfen Sie, ob die Formulardaten übermittelt wurden. Wenn nicht, zeigen Sie das Formular auf der Webseite an.

* Wenn die Daten vom Seiten-Benutzer gesendet wurden, die Rohdaten aus
  den Variablen `POST` (und/oder `GET`) als Form eines Arrays abgerufen.

* Die Daten werden den Formularmodellfeldern mit der Methode `setData()` des Formulars zugewiesen.

* Die Filterung und Validierung erfolgt mit der Methode `isValid()` des Formulars
  (Dies führt zur Ausführung der Eingabefilter, die an das Formular angehängt sind).
  Wenn ein bestimmtes Feld ungültig ist, zeigen Sie das Formular erneut an und bitten Sie den Benutzer, die Eingabe zu korrigieren.

* Sobald die Daten gefiltert und/oder validiert wurden, erhalten Sie die Daten von der
  Model Klasse mit der Methode `getData()` und können die Daten an andere Modelle übergeben
  oder diese anderweitig verweden.

Das folgende Codebeispiel veranschaulicht, wie dieser typische Ablauf
in der Aktionsmethode Ihres Controllers implementiert wird:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Controller;

use Application\Form\ContactForm;
// ...

class IndexController extends AbstractActionController 
{
  // This action displays the feedback form
  public function contactUsAction() 
  {
    // Create Contact Us form
    $form = new ContactForm();
        
    // Check if user has submitted the form
    if($this->getRequest()->isPost()) 
    {
      // Fill in the form with POST data
      $data = $this->params()->fromPost();            
      $form->setData($data);
            
      // Validate form
      if($form->isValid()) {
                
        // Get filtered and validated data
        $data = $form->getData();
                
        // ... Do something with the validated data ...
		
        // Redirect to "Thank You" page
        return $this->redirect()->toRoute('application', ['action'=>'thankYou']);
      }            
    } 
        
    // Pass form variable to view
    return new ViewModel([
          'form' => $form
       ]);
  }
}
~~~

Im obigen Code definieren wir die Aktionsmethode `contactUsAction()` in der
Klasse `IndexController` (Zeile 10). In der Aktionsmethode erstellen wir eine Instanz
der Klasse `ContactForm` (Zeile 13).

In Zeile 16 prüfen wir dann, ob es sich beim HTTP-Request um einen POST-Request handelt (Prüfung
der Startzeile im HTTP-Request).

In Zeile 19 rufen wir die Rohdaten ab, die vom Benutzer gesendet wurden. Wir extrahieren alle POST-Variablen
mit Hilfe des Controller-Plugins @`Params`. Die Daten werden in Form eines Arrays zurückgegeben und werden
in der Variable `$data` gespeichert.

Die vom Benutzer übermittelten Daten können Fehler enthalten und sollten, vor weiteren Verwendung, gefiltert 
sowie validiert werden. Um dies zu tun, übergeben wir in Zeile 20 die Daten in das Formularmodell mit dem
Methode `setData()`, welche die Basisklasse `Form` zur Verfügung stellt. Wir validieren die Formulardaten mit
der Methode`isValid ()` (Zeile 23), die bei erfolgreicher Validierung `true` zurückgibt.
Wenn die Validierung erfolgreich ist, rufen wir die validierten Daten mit der Methode `getData ()` ab
(Zeile 26) und können dann die Daten an unsere Business-Logik-Ebene übergeben.

Sobald wir die validierten Daten verwendet haben, leiten wir in Zeile 31 den Web-Benutzer an die Seite
*Danke* weiter. Die Weiterleitung erfolgt mit dem Controller-Plugin @`Redirect`.
Die Methode `toRoute()` des Plugins @`Redirect` benötigt zwei Parameter: der erste Parameter ist der
Name der Route ("application"), und der zweite ist ein Array von Parametern,
die der Route übergeben werden. Diese identifizieren die Webseite, auf die Sie den Benutzer umleiten.

I> Wir bereiten die Aktion des Controllers vor und sehen das View-Template für die *Danke*-Seite
I> etwas später an.

In Zeile 37 übergeben wir das Formularmodell über die Variable `$form` an das View-Template. Das View-Template
greift auf diese Variable zu und verwendet sie zum Rendern des Formulars (und zeigt mögliche
Validierungsfehler an).

### Übergeben von Formulardaten an ein Modell

Um Ihnen ein realistisches Beispiel dafür zu geben, wie Sie die validierten Daten des Kontakt-Formulars verwenden können,
erstellen wir ein diesem Abschnitt eine einfache Modell-Klasse `MailSender`[^service] Sie
kann zum Senden einer E-Mail-Nachricht an eine E-Mail-Adresse verwendet werden. Wenn der Benutzer das Formular abschickt,
werden wir die Formulardaten validieren und die validierten Daten an das Modell `MailSender` übergeben und ihm mitteilen,
dass die E-Mail-Nachricht an den Empfänger gesendet wurde.

[^service]: In DDD-Begriffen kann der `MailSender` auf Servicemodelle bezogen sein, da sein Ziel es
            ist, Daten zu manipulieren und nicht um Daten zu speichern.

T> Das Lesen dieses Abschnitts ist optional und hauptsächlich für Anfänger gedacht. Sie können es überspringen
T> und mit dem nächsten Abschnitt *Formularpräsentation* fortfahren.
       
Das Modell `MailSender` verwendet intern die Komponente @`Zend\Mail`. Die Komponente @`Zend\Mail`
ist eine Komponente von Zend Framework 3 und wurde entwickelt, um Ihnen die komfortable Funktionalität
zum Verfassen von Mail-Nachrichten (die Klasse @`Zend\Mail\Message`) zu bieten. Ebenso bietet Die Komponente mehrere Möglichkeiten
für das Senden von Mails (in diesem Beispiel werden wir die Klasse @`Zend\Mail\Transport\Sendmail` verwenden, die
verwendet das Programm *sendmail* für die Zustellung von E-Mails).

I> Installieren Sie die Komponente @`Zend\Mail` mit Composer, indem Sie den folgenden Befehl eingeben:
I>
I> `php composer.phar require zendframework/zend-mail`

I> Das Programm [sendmail] (http://www.sendmail.com/sm/open_source/) ist ein kostenloser Open-Source-Mail-Transfer-Agent für das Betriebssystem Linux/Unix.
I> Es akzeptiert Nachrichten, die ein PHP-Skript dem Programm sendmail übergibt. Basierend auf der Nachrichten-Header, welcher über die
I> Übermittlungsmethode entscheidet, wird  die Nachricht über das SMTP - Protokoll an einen
I> geeignete Mailserver (wie Google Mail) für die Zustellung an den Empfänger übergeben und gesendet.

Beginnen Sie mit der Erstellung der Datei *MailSender.php* im Verzeichnis *Service* unter dem Quellverzeichnis
des Moduls (siehe zum Beispiel Abbildung 7.19).

![Abbildung 7.19. Erstellen der Datei MailSender.php](images/forms/mailsender.png)

Im folgenden der Code, der in die Datei *MailSender.php* geschrieben werden sollte:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Service;

use Zend\Mail;
use Zend\Mail\Message;
use Zend\Mail\Transport\Sendmail;

// This class is used to deliver an E-mail message to recipient.
class MailSender 
{
  // Sends the mail message.
  public function sendMail($sender, $recipient, $subject, $text) 
  {
    $result = false;
    try {
        
      // Create E-mail message
      $mail = new Message();
      $mail->setFrom($sender);
      $mail->addTo($recipient);
      $mail->setSubject($subject);
      $mail->setBody($text);
	  
      // Send E-mail message
      $transport = new Sendmail('-f'.$sender);
      $transport->send($mail);
      $result = true;
    } catch(\Exception $e) {
      $result = false;
    }
        
    // Return status 
    return $result;
  }
}
~~~

Im obigen Code definieren wir den Namensraum `Application\Service` (Zeile 2), weil
die Klasse `MailSender` steht mit den Service-Models in Beziehung (ihr Ziel ist es Daten zu manipulieren, 
nicht um diese zu speichern).

In den Zeilen 4-6 deklarieren wir die Aliase für die Klassen @`Mail`, @`Message`[Zend\Mail\Message] und @`Zend\Mail\Transport\Sendmail`, 
die von der Komponente @`Zend\ Mail` bereitgestellt werden.

In den Zeilen 9-35 definieren wir die Klasse `MailSender`. Die Klasse hat als einzigste Methode
`sendMail()` (Zeile 12), die vier Argumente annimmt: die E-Mail-Adresse des Absenders, die E-Mail-Adresse des Empfängers,
den Nachrichtenbetreff und schließlich den Nachrichtentext.

In Zeile 18 erstellen wir eine Instanz der Klasse @`Message`[Zend\Mail\Message]. Wir verwenden die zur Verfügung gestellten Methoden
dieser Klasse zum Verfassen der Nachricht (setzen des Betreffs, Nachrichtentext, usw.) in den Zeilen 19-22.

In Zeile 25 erstellen wir eine Instanz der Klasse @`Sendmail`, die das Programm *sendmail* verwendet,
um die Nachricht an den entsprechenden Mail-Server zu übergeben (siehe Zeilen 25-26). Seit die Klassen
von der Komponente @`Zend\Mail` zur Verfügung gestellt werden, kann eine Exception ausgelöst werden, wenn ein Fehler auftritt.
Aus diesem Grund umschließen wir den Codeblock mit einem `try`-`catch`-Statement.

Die Methode `sendMail()` gibt `true` zurück, wenn die E-Mail-Nachricht erfolgreich gesendet wurde. Andernfalls
es `false` zurückgeben (Zeile 33).

I> Das Mailsystem für Ihren Webserver zu konfigurieren ist eine ziemlich komplexe Aufgabe. Es
I> erfordert die Installation von sendmail und die Konfiguration des MX-DNS-Eintrags des Servers für bestimmte
I> Mail-Server (entweder lokaler Mail-Server, z.B. [Postfix](http://www.postfix.org/),
I> oder einen Remote-Server, wie Google Mail).
I> Wegen der Komplexität des Themas wird es in diesem Buch nicht diskutiert. Sie können
I> zusätzliche Informationen zum Konfigurieren der E-Mail für Ihr spezielles System online finden.

Registrieren Sie nun den Service `MailSender` in Ihrer Datei `module.config.php` wie folgt:

{line-numbers=off, lang=php}
~~~
return [
    //...
    'service_manager' => [
        'factories' => [
            Service\MailSender::class => InvokableFactory::class,
        ],
    ],
    
    //...
];
~~~

Später können Sie das Modell `MailSender` in Ihrer Methode `IndexController::contactUsAction()` instanziieren
und übergeben Sie die validierten Formulardaten.

I> Da wir den Service `MailSender` in unserem Controller verwenden, ist dieser Dienst eine *Abhängigkeit* für den Controller.
I> Also müssen wir eine Factory für den Controller erstellen und die Abhängigkeit in den Konstruktor des Controllers injizieren.
I> Sieht auf den ersten Blick komplex aus, aber wenn Sie Ihre Fähigkeiten verbessern, werden Sie feststellen, dass dies ziemlich einfach und die
I> Struktur Ihres Codes deutliche verbessert.

Lassen Sie uns die Factory für den `IndexController` erstellen (fügen Sie es in das Unterverzeichnis `Factory` im Unterverzeichnis `Controller` ein).
Sie können sehen, dass die einzigste Aufgabe der Factory-Klasse darin besteht, das Erstellen des Controllers und das Übergeben der Abhängigkeit ist.

{line-numbers=off, lang=php}
~~~
<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\MailSender;
use Application\Controller\IndexController;

class IndexControllerFactory
{
    public function __invoke(ContainerInterface $container, 
                             $requestedName, array $options = null)
    {
        $mailSender = $container->get(MailSender::class);
        
        // Instantiate the controller and inject dependencies
        return new IndexController($mailSender);
    }
}
~~~

Ändern Sie die Datei `module.config.php`, um die benutzerdefinierte Factory zu verwenden, die wir gerade erstellt haben:

{line-numbers=off, lang=php}
~~~
return [
    //...
    'controllers' => [
        'factories' => [
            Controller\IndexController::class => Controller\Factory\IndexControllerFactory::class,
        ],
    ],
    
    //...
];
~~~

Fügen Sie als nächstes dem Konstruktor die Methoden `contactUsAction()`, `thankYouAction ()` und `sendErrorAction ()`
zum Controller hinzu. Im Folgenden wird der vollständige Code dargestellt:

{line-numbers=on, lang=php}
~~~
<?php
// ...
use Application\Service\MailSender;

class IndexController extends AbstractActionController 
{
  private $mailSender;
    
  public function __construct($mailSender) 
  {
    $this->mailSender = $mailSender;
  }
    
  public function contactUsAction() 
  {
    // Create Contact Us form
    $form = new ContactForm();
        
    // Check if user has submitted the form
    if($this->getRequest()->isPost()) {
            
      // Fill in the form with POST data
      $data = $this->params()->fromPost();            
            
      $form->setData($data);
            
      // Validate form
      if($form->isValid()) {
                
        // Get filtered and validated data
        $data = $form->getData();
        $email = $data['email'];
        $subject = $data['subject'];
        $body = $data['body'];
                
        // Send E-mail
        if(!$this->mailSender->sendMail('no-reply@example.com', $email, 
                        $subject, $body)) {
          // In case of error, redirect to "Error Sending Email" page
          return $this->redirect()->toRoute('application', 
                        ['action'=>'sendError']);
        }
                
        // Redirect to "Thank You" page
        return $this->redirect()->toRoute('application', 
                        ['action'=>'thankYou']);
      }            
    } 
        
    // Pass form variable to view
    return new ViewModel([
      'form' => $form
    ]);
  }
    
  // This action displays the Thank You page. The user is redirected to this
  // page on successful mail delivery.
  public function thankYouAction() 
  {
    return new ViewModel();
  }
    
  // This action displays the Send Error page. The user is redirected to this
  // page on mail delivery error.
  public function sendErrorAction() 
  {
    return new ViewModel();
  }
}
~~~

Wie Sie aus dem obigen Code sehen können, machen wir folgendes:

* In Zeile 3 deklarieren wir einen Alias ​​für die Klasse `Application\Service\MailSender`.
  Dadurch können Sie auf die Modellklasse anhand ihres Kurznamens verweisen.
  
* In den Zeilen 32-34, nachdem wir das Formular validiert haben, extrahieren wir die validierte
  Feldwerte in die PHP-Variablen `$email`, `$subject` und `$body`.

* In Zeile 37 rufen wir die Methode `sendMail()` des Services `MailSender` auf und übergeben ihr vier Parameter:
  die Adresse des Absenders (hier verwenden wir "no-reply@example.com", aber Sie können
  dies mit der Adresse Ihres *sendmail* ersetzen); die E-Mail-Adresse des Empfängers,
  den Betreff und die Textnachricht.

* Wenn die Mail erfolgreich versendet wurde (wenn die Methode `sendMail()` `true` zurückgegeben hat),
  leiten wir den Benutzer auf die Seite *Danke* um (Zeile 45). Bei einem Fehler (wenn Methode `sendMail()`
  `false` zurück gab, leiten wir den Benutzer auf die Seite *Send Error* um (Zeile 40).
  
* In den Zeilen 58-61 haben wir die Methode `thankYouAction()`, die die Seite
  *Danke* anzeigt. Diese Seite wird angezeigt, wenn die E-Mail-Nachricht erfolgreich gesendet wurde.
  
* In Zeile 65-68 haben wir die Methode `sendErrorAction()`, die die Seite
  *Fehler beim Senden der E-Mail* anzeigt. Diese Seite wird bei fehlgeschlagenem E-Mail-Versand angezeigt.
  
## Formularpräsentation

Wenn die Aktion Ihres Controllers fertig ist, müssen Sie nur das View-Template `.phtml` vorbereiten,
um Ihr Formular auf einer Webseite anzuzeigen. In dem View-Template definieren Sie
das Markup mit den HTML-Tags `<form>`, `<label>`, `<input>` und möglicherweise anderen HTML-Tags.

Außerdem müssen Sie bei der Formularvalidierung Fehlermeldungen anzeigen. 
Weil diese Arbeit ziemlich langweilig ist, bietet Zend Framework 3 Ihnen
mit speziellen View-Helpern hilfe, die zum Rendern der Formulars bestimmt sind.

T> Für einfache Formulare (die keine Fehlermeldungen anzeigen) können Sie unformatierte HTML-Tags
T> zum Rendern des Formulars verwenden und die von ZF3-bereitgestellten Form-View-Helper ignorieren.
T> Form-View-Helfer sind wirklich unvermeidlich zum Rendern
T> komplexer Formulare, die Validierungsfehler anzeigen und/oder zum hinzufügen
T> von dynamischen Felder.

### Vorbereiten des Formularmodells für das Rendern

Vor dem Rendern müssen Sie die Methode `prepare()` der Instanz des Formularmodell 
aufrufen (siehe Tabelle 7.12). Wenn Sie vergessen, diese Methode aufzurufen, kann dies unerwünschte
Auswirkungen haben.

{title="Tabelle 7.12. Von der Basisklasse Form bereitgestellte Methoden"}
|-------------------|-------------------------------------------------------------------|
| *Methodenname*	| *Beschreibung* 													|
|-------------------|-------------------------------------------------------------------|
| `prepare()` 		| Stellt sicher, dass der Formularstatus zur Verwendung bereit ist.	|
|-------------------|-------------------------------------------------------------------|

Die Methode `prepare()` macht folgende Modellvorbereitungen:
  
  * Es ruft den Eingabefiltercontainer auf, der an das Formularmodell angehängt ist.
    So wird sichergestellen, dass Fehlermeldungen verfügbar sind;
  * Es bereitet alle Elemente und/oder Feldsets vor, die vorbereitet werden müssen[^wrapping].

[^wrapping]: Dies führt in der Regel dazu, dass Feldnamen mit dem Namen des Formulars/Feldsets umbrochen werden
             (Beispielsweise wird der Name des Feldes "email" zu "contact-form[email]")
             was technisch zu einer bequemeren Feldgruppierung in einem HTTP-Request führt.

## Standard Form View Helper

Von ZF3 bereitgestellte Standard-Form-View-Helper sind in den folgenden Tabellen 7.13 - 7.16 dargestellt. Diese Klassen
befinden sich im Namensraum @`Zend\Form\View\Helper`[Zend\Form]. Wie Sie in der Tabelle sehen können,
können die View-Helper in folgende Kategorien eingeteilt werden:

* *Generische Form-View-Helper.* Diese Klassen sind entworfen worden, um das
  ganzes Formular (@`Form`[Zend\Form\View\Helper\Form] Helper) oder sein einzelnes Element (@`FormElement` Helper)
  und mögliche Validierungsfehler (@`FormElementErrors` Helper).

* *View-Helper zum Rendern von HTML-Feldern bestimmter Typen.* Damit können Sie HTML Markup
  für konkrete Formularfelder (z.B. @`FormButton`, @`FormRadio` usw.)
  und ein Textlabel (@`FormLabel`) generieren.
  
* *View-Helper zum Rendern von Formularfeldern, die in HTML5 eingeführt wurden.* Dies sind
  analog zu den View-Helper aus der vorherigen Kategorie, aber zum Renern von
  HTML5-Feldern (z. B. @`FormDate`, @`FormUrl` usw.)
   
* *Andere View-Helper.* In dieser Kategorie können wir die View-Helper-Klassen für das Rendering
  ZF3-spezifische Felder einfügen, wie @`FormMultiCheckbox`, @`FormCaptcha`, etc.

-----------
HIER WEITER
-----------

{title="Tabelle 7.13. View-Helper für die Verwendung mit Formularen"}
|---------------------------------------|-----------------------------------------------------------------------|
| *Methodenname* 						| *Beschreibung* 														|
|---------------------------------------|-----------------------------------------------------------------------|
| *Übergeordnete Helfer* 				| 																		|
|---------------------------------------|-----------------------------------------------------------------------|
| @`Form`[Zend\Form\View\Helper\Form]	| Rendert das gesamte Formular und alle seine Elemente. 				|
|---------------------------------------|-----------------------------------------------------------------------|
| @`FormElement` 						| Rendert ein übergeordnetes Formularelement. 							|
|---------------------------------------|-----------------------------------------------------------------------|
| @`FormElementErrors` 					| Übergibt Validierungsfehler für ein Formularelement. 					|
|---------------------------------------|-----------------------------------------------------------------------|
| @`FormRow` 							| Rendert die Beschriftung eines Feldes und dessen Validierungsfehler.	|
|---------------------------------------|-----------------------------------------------------------------------|

{title=""Tabelle 7.14. HTML 4 Element-Helper"}
|-------------------|-------------------------------------------------------|
| *Methodenname* 	| *Beschreibung* 										|
|-------------------|-------------------------------------------------------|
| @`FormButton` 	| Rendert das Formularfeld `<button>`. 					|
|-------------------|-------------------------------------------------------|
| @`FormCheckbox` 	| Rendert das Eingabefeld `<input type="checkbox">`. 	|
|-------------------|-------------------------------------------------------|
| @`FormFile` 		| Rendert das Eingabefeld `<input type="file">`. 		|
|-------------------|-------------------------------------------------------|
| @`FormHidden` 	| Rendert das Eingabefeld `<input type="hidden">`. 		|
|-------------------|-------------------------------------------------------|
| @`FormInput` 		| Rendert das Formularfeld `<input>`. 					|
|-------------------|-------------------------------------------------------|
| @`FormImage` 		| Rendert das Eingabefeld `<input type="image">`. 		|
|-------------------|-------------------------------------------------------|
| @`FormLabel` 		| Rendert den Tag `<label>`. 							|
|-------------------|-------------------------------------------------------|
| @`FormPassword` 	| Rendert das Eingabefeld `<input type="password">`.	|
|-------------------|-------------------------------------------------------|
| @`FormRadio` 		| Rendert das Eingabefeld `<input type="radio">`. 		|
|-------------------|-------------------------------------------------------|
| @`FormReset` 		| Rendert das Eingabefeld `<input type="reset">`. 		|
|-------------------|-------------------------------------------------------|
| @`FormSelect` 	| Rendert das Auswahlfeld `<select>`. 					|
|-------------------|-------------------------------------------------------|
| @`FormSubmit` 	| Rendert das Eingabefeld `<input type="submit">`. 		|
|-------------------|-------------------------------------------------------|
| @`FormText` 		| Rendert das Eingabefeld `<input type="text">`. 		|
|-------------------|-------------------------------------------------------|
| @`FormTextarea`	| Rendert das mehrzeilige Textfeld `<textarea>`. 		|
|-------------------|-------------------------------------------------------|


{title="Tabelle 7.15. HTML 5 Element-Helper"}
|-----------------------|-----------------------------------------------------------|
| *Methodenname* 		| *Beschreibung* 											|
|-----------------------|-----------------------------------------------------------|
| @`FormColor` 			| Rendert das Eingabefeld HTML5 `<input type="color">`. 	|
|-----------------------|-----------------------------------------------------------|
| @`FormDate` 			| Rendert das Eingabefeld HTML5. `<input type="date">`		|
|-----------------------|-----------------------------------------------------------|
| @`FormDateTime` 		| Rendert das Eingabefeld HTML5 `<input type="date">`. 		|
|-----------------------|-----------------------------------------------------------|
| @`FormDateTimeLocal`	| Rendert das Eingabefeld HTML5 `<input type="date">`. 		|
|-----------------------|-----------------------------------------------------------|
| @`FormEmail` 			| Rendert das Eingabefeld HTML5 `<input type="email">`. 	|
|-----------------------|-----------------------------------------------------------|
| @`FormMonth` 			| Rendert das Eingabefeld HTML5 `<input type="month">`. 	|
|-----------------------|-----------------------------------------------------------|
| @`FormNumber` 		| Rendert das Eingabefeld HTML5 `<input type="number">`.	|
|-----------------------|-----------------------------------------------------------|
| @`FormRange` 			| Rendert das Eingabefeld HTML5 `<input type="range">`. 	|
|-----------------------|-----------------------------------------------------------|
| @`FormTel` 			| Rendert das Eingabefeld HTML5 `<input type="tel">`. 		|
|-----------------------|-----------------------------------------------------------|
| @`FormTime` 			| Rendert das Eingabefeld HTML5 `<input type="time">`. 		|
|-----------------------|-----------------------------------------------------------|
| @`FormUrl` 			| Rendert das Eingabefeld HTML5 `<input type="url">`. 		|
|-----------------------|-----------------------------------------------------------|
| @`FormWeek` 			| Rendert das Eingabefeld HTML5 `<input type="week">`. 		|
|-----------------------|-----------------------------------------------------------|

{title="Tabelle 7.16. Andere Helper"}
|-----------------------|-----------------------------------------------|
| *Methodenname* 		| *Beschreibung* 								|
|-----------------------|-----------------------------------------------|
| @`FormCaptcha` 		| Rendert das CAPTCHA-Sicherheitsfeld. 			|
|-----------------------|-----------------------------------------------|
| @`FormDateSelect` 	| Rendert das Datumsauswahlfeld. 				|
|-----------------------|-----------------------------------------------|
| @`FormDateTimeSelect`	| Rendert das Datum oder Uhrzeit-Auswahlfeld.	|
|-----------------------|-----------------------------------------------|
| @`FormMonthSelect` 	| Rendert das Monatsauswahlfeld. 				|
|-----------------------|-----------------------------------------------|
| @`FormMultiCheckbox` 	| Rendert das mehrere Checkboxen. 				|
|-----------------------|-----------------------------------------------|
| @`FormCollection` 	| Rendert die Sammlung von Elementen. 			|
|-----------------------|-----------------------------------------------|

In den nächsten Abschnitten geben wir einen Überblick ,über häufig verwendete Formular-View-Helper
und ihre Anwendungsbeispiele.

### Rendern eines Formularelements

Sie können ein Formularfeld mit dem Helper @`FormElement`. Dieser ist flexibel gestaltet.
Dadurch kann dieser viele Feldtypen wie möglich verarbeiten. Mit diesem View-Helper
können Sie HTML-Markup für Textfelder, Buttons, Auswahl-Listen und so weiter erstellen.

Die von diesem View-Helper bereitgestellten Methoden sind in Tabelle 7.17 aufgeführt.

{title="Tabelle 7.17. Vom View-Helper-FormElement bereitgestellte Methoden"}
|-----------------------|-------------------------------------------------------------------|
| *Methodenname* 		| *Beschreibung* 													|
|-----------------------|-------------------------------------------------------------------|
| `render($element)` 	| PHP's Magic-Methode, die das angegebene Formularfeld rendert. 	|
|-----------------------|-------------------------------------------------------------------|
| `__invoke($element)`	| PHP's magische Methode, die das gegebene Formularfeld rendert. 	|
| 						| (Der Effekt ist der gleiche wie `render ()`). 					|
|-----------------------|-------------------------------------------------------------------|

Wie Sie sehen können, gibt es zwei Methoden, die das Gleiche tun:

  * Die Methode `render()` erzeugt das HTML Markup für das
    Formularfeld. Es akzeptiert das einzelne Argument -- die Instanz des zu rendernden Elements. Sie können
    das Formularelement mit der Methode `get()` des Formularmodells abrufen (siehe Beispiel unten).
  * Die Methode `__invoke()` ist eine Methode für die Bequemlichkeit, die weniger Code zum Schreiben benötigt.

{line-numbers=off, lang=php}
~~~
<?php 
// We assume that the form model is stored in $form variable.
// Render the E-mail field with the render() method.
echo $this->formElement()->render($form->get('email')); ?>

// The same, but with __invoke
echo $this->formElement($form->get('email')); 
~~~

Bei der Ausführung generiert der obige Code den HTML-Code wie folgt:

{line-numbers=off, lang=html}
~~~
<input type="text" name="email" id="email" value="">
~~~

T> In der Regel ist es nicht erforderlich, View-Helper für.
T> Felder (z.B. @`FormText`, @`FormSubmit` usw.) konkretes HTML (oder HTML5) aufzurufen.
T> Stattdessen können Sie den übergeordneten View-Helper @`FormElement` verwenden, der den
T> Feldtyp automatisch und den benötigten HTML-Code erzeugt.

### Rendering Validierungsfehler eines Elements

Mit der Helper-Klasse @`FormElementErrors` können Sie HTML-Markup für
Feldvalidierungsfehler (falls vorhanden) erstellen. Wenn es keine Validierungsfehler für
bestimmten Element gibt, erzeugt dieser View-Helper keine Ausgabe.

Ein Beispiel für die Verwendung des View-Helpers @`FormElementErrors` ist im folgenden dargestellt:

{line-numbers=off, lang=php}
~~~
<?php 
// We assume that the form model is stored in $form variable.
// Render validation errors for the E-mail field.
echo $this->formElementErrors($form->get('email')); 
~~~

Wenn Validierungsfehler aufgetreten sind, generiert dieser Code die ungeordnete Liste
der Fehler mit dem HTML-Tag `<ul>`. Die Liste wird so viele Elemente enthalten, wie
es Fehler für bestimmte Felder gibt. Ein Beispiel für eine solche Liste für das E-Mail-Feld
aus unserem Kontakt-Formular ist unten dargestellt:

{line-numbers=off, lang=html}
~~~
<ul>
  <li>&#039;hostname&#039; is not a valid hostname for the email address</li>
  <li>The input does not match the expected structure for a DNS hostname</li>
  <li>The input appears to be a local network name but local network names are not allowed</li>
</ul> 
~~~

### Rendern eines Element-Labels

Der Helper @`FormLabel` erlaubt Ihnen, die Textbeschriftung für ein Element zu rendern:

{line-numbers=off, lang=php}
~~~
<?php 
// We assume that the form model is stored in $form variable.
// Render text label for the E-mail field.
echo $this->formLabel($form->get('email')); 
~~~

Bei der Ausführung generiert der obige Code den HTML-Code wie folgt:

{line-numbers=off, lang=html}
~~~
<label for="email">Your E-mail</label>
~~~

### Rendern einer Formularzeile

Der View-Helper @`FormRow` soll das Rendern eines Formularfeldes mit Label und Validierungsfehler 
vereinfachen. Mit dieser Klasse können Sie diese 3 in einem einzigen Schritt rendern.
Dieser Helper ist flexibel konfigurierbar, so dass Sie einen anderen für die Dekoration der 
Formularreihe anwenden können. Die Methoden dieser View-Helper-Klasse sind in Tabelle 7.18 aufgeführt.

{title="Tabelle 7.18. Vom View-Helper-FormRow bereitgestellte Methoden"}
|-------------------------------------------|---------------------------------------------------------------|
| *Methodenname* 							| *Beschreibung* 												|
|-------------------------------------------|---------------------------------------------------------------|
| `render($element)` 						| Rendert die Formularzeile. 									|
|-------------------------------------------|---------------------------------------------------------------|
| `__invoke($element, $labelPosition, $renderErrors, $partially)`	| Rendert die Formularzeile.			|
|																	| Bequemlichkeitsmethode. 				|
|-------------------------------------------|---------------------------------------------------------------|
| `setInputErrorClass($inputErrorClass)`	| Legt die CSS-Klasse der Eingabefehler fest. 					|
|-------------------------------------------|---------------------------------------------------------------|
| `setLabelAttributes($labelAttributes)` 	| Legt Labelattribute fest. 									|
|-------------------------------------------|---------------------------------------------------------------|
| `setLabelPosition($labelPosition)` 		| Legt die Label-Position fest (vor oder nach dem Feld). 		|
|-------------------------------------------|---------------------------------------------------------------|
| `setRenderErrors($renderErrors)` 			| Legen fest, ob die Fehler von diesem Helper gerendert werden.	|
|-------------------------------------------|---------------------------------------------------------------|
| `setPartial($partial)` 					| Legen Sie ein Partial-View-Template fest, das zum Rendern der	|
|											| Zeile verwendet werden soll. 									|
|-------------------------------------------|---------------------------------------------------------------|

Ein Beispiel für die Verwendung des View-Helpers @ `FormRow` ist unten dargestellt:

{line-numbers=off, lang=php}
~~~
<?php 
// We assume that the form model is stored in $form variable.
// Render the E-mail field, its label and (possible) validation errors.
echo $this->formRow($form->get('email')); 
~~~

Bei der Ausführung generiert der obige Code den HTML-Code wie folgt:

{line-numbers=off, lang=html}
~~~
<label for="email">Your E-mail</label>
<input type="text" name="email" id="email">
<ul>
  <li>&#039;hostname&#039; is not a valid hostname for the email address</li>
  <li>The input does not match the expected structure for a DNS hostname</li>
  <li>The input appears to be a local network name but local network names 
      are not allowed</li>
</ul> 
~~~

### Rendern des gesamten Formulars

Der Helper @`Form`[Zend\Form\View\Helper\Form] erlaubt Ihnen, den öffnende HTML-Tag `<form>` und seine Attribute zu rendern
sowie den schließendeden HTML-Tag `</form>`. Aber sein Hauptzweck ist es, das gesamte Formular und
alle seine Felder mit einer einzelnen Codezeile zu rendern. Öffentliche Methoden des Helper-Klasse @`Form`[Zend\Form\View\Helper\Form]
sind in Tabelle 7.19 zusammengefasst.

{title="Tabelle 7.19. Vom View-Helper Form bereitgestellte Methoden"}
|-------------------|-------------------------------------------------------------------|
| *Methodenname* 	| *Beschreibung* 													|
|-------------------|-------------------------------------------------------------------|
| `render($form)` 	| Rendert das gesamte Formular und alle seine Elemente. 			|
|-------------------|-------------------------------------------------------------------|
| `__invoke($form)`	| PHP's magische Methode, die das gesamte Formular und alle seine	|
| 					| Elemente rendert (der Effekt ist der gleiche wie `render()`). 	|
|-------------------|-------------------------------------------------------------------|
| `openTag($form)` 	| Rendert das öffnende Tag `<form>`. 								|
|-------------------|-------------------------------------------------------------------|
| `closeTag()` 		| Rendert das schließende Tag `</form>`. 							|
|-------------------|-------------------------------------------------------------------|

Sie können das ganze Formular mit Hilfe der Methode @`Form`[Zend\Form\Form]` `render()` wie folgt rendern:

{line-numbers=off, lang=php}
~~~
// We assume that the form model is stored in $form variable

// Render the whole form
echo $this->form()->render($form);
~~~

Der gleiche Effekt kann mit der magischen Methode `__invoke` erreicht werden (siehe Beispiel unten):

{line-numbers=off, lang=php}
~~~
// The same, but with `__invoke`
echo $this->form($form);
~~~

## Beispiel: Erstellen des View-Template für das Kontaktformular

Jetzt sind wir bereit, die Präsentation für unser Kontakt-Formular zu definieren.
Wenn Sie sich erinnern, haben wir vorher das View-Template *contact-us.phtml*
im Verzeichnis *application/index/* des Verzeichnisses unter *view/*  dem Modul
hinzugefügt. Ersetzen Sie den Code in dieser Datei durch folgenden Code:

{line-numbers=on, lang=php}
~~~
<?php
$form = $this->form;
$form->prepare();
?>

<?= $this->form()->openTag($form); ?>
	
<?= $this->formLabel($form->get('email')); ?>
<?= $this->formElement($form->get('email')); ?>
<?= $this->formElementErrors($form->get('email')); ?>                  
	
<?= $this->formLabel($form->get('subject')); ?>
<?= $this->formElement($form->get('subject')); ?>
<?= $this->formElementErrors($form->get('subject')); ?>
   
<?= $this->formLabel($form->get('body')); ?>
<?= $this->formElement($form->get('body')); ?>
<?= $this->formElementErrors($form->get('body')); ?>                  
	
<?= $this->formElement($form->get('submit')); ?>
	
<?= $this->form()->closeTag(); ?>
~~~

Wie Sie im obigen Code sehen können, machen wir folgende Schritte, um das Formular zu rendern:

* In Zeile 2 greifen wir auf die Variable `$form` zu, die von der Aktion des Controllers übergeben wurde.

* In Zeile 3 rufen wir die Methode `prepare()` von @`Form`[Zend\Form\Form] auf, um das Formular für das Rendering vorzubereiten.
  Bitte beachten Sie, dass der Aufruf dieser Methode sehr wichtig ist. Wenn Sie das vergessen,
  kann es einige unerwünschte Rendering-Probleme geben.

* In Zeile 6 rufen wir dieM ethode `openTag()` des View-Helpers @`Form`[Zend\Form\View\Helper\Form] auf. Sein Zweck besteht
  darin, den öffneten Tag `<form>` und seine Attribute zu rendern. Die Methode benötigt eine einziges
  Argument - eine Instanz des Formularmodells. Der schließendende Tag `</form>` wird in Zeile 22
  mit Hilfe der Methode `closeTag()` des View-Helpers @`Form`[Zend\Form\View\Helper\Form] gerendert.
  
* In den Zeilen 8-10 geben wir das Label des E-Mail-Feldes, des Textfeldes selbst und (falls)
  Validierungsfehler mit Hilfe durch die View-Helper @`FormLabel`, @`FormElement` und @`FormElementErrors`
  an. Diese Helper nehmen die Instanz des Formularmodellelements als einzelnes Argument entgegen. Wir
  erhalten eine Instanz des Elements mit der Methode `get()`, die von der Basisklasse @`Form`[Zend\Form\Form] bereitgestellt wird.

* In den Zeilen 12-14 geben wir analog das Feld für den Betreff, seine Bezeichnung und die Validierungsfehler wieder.

* Und in den Zeilen 16-18 rendern wir das Label, das Feld und die Validierungsfehler für das
  Nachrichtentext Feld.

* In Zeile 20 rendern wir den Button *Submit*.
  
Wenn der Renderer den Code unseres View-Templates auswertet, wird die folgende HTML-Ausgabe erzeugt:

{line-numbers=off, lang=html}
~~~
<form action="/contact" method="post" name="contact-form">
  <label for="email">Your E-mail</label>
  <input type="text" name="email" id="email" value="">
        
  <label for="subject">Subject</label>
  <input name="subject" type="text" id="subject" value="">

  <label for="body">Message Body</label>
  <textarea name="body" id="body"></textarea>
       
  <input name="submit" type="submit" value="Submit">
</form>
~~~

I> Im obigen Code verwendeten wir meistens die View-Helper @`FormElement`, @`FormElementErrors`
I> und @`FormLabel`. Sie können die übergeordneten View-Helper @`FormRow` oder @`Form`[Zend\Form\View\Helper\Form] verwenden,
I> wenn Sie die Menge an Code zum Schreiben reduzieren wollen, aber das
I> kann zu weniger Kontrolle der Formdekoration führen.

Wenn bestimmte Felder Validierungsfehler aufweisen, werden diese Fehler
unterhalb des Feldes als ungeordneten HTML-Liste ausgegeben.
Wenn Sie beispielsweise "123@hostname" in das E-Mail-Formularfeld eingeben,
würden Sie die folgenden Validierungsfehler erhalten:

{line-numbers=off, lang=html}
~~~
<label for="email">Your E-mail</label>
<input type="text" name="email" value="123@hostname">
<ul>
  <li>&#039;hostname&#039; is not a valid hostname for the email address</li>
  <li>The input does not match the expected structure for a DNS hostname</li>
  <li>The input appears to be a local network name but local network names 
      are not allowed</li>
</ul> 
~~~

### Anwenden des Bootstrap-CSS-Stile auf ein Formular

Dem obigen HTML-Markup fehlt das CSS-Styling. Was wir wollen erreichen, die
Twitter Bootstrap CSS-Klassen auf unser Formular anzuwenden. Das gibt unserem Formular ein schöneres und professionelles
Aussehen. Um dem Formular den Bootstrap-Stil hinzuzufügen, müssen wir den Code der Datei *.phtml* ändern.
Dies sieht wie folgt aus:

{line-numbers=on, lang=php}
~~~
<?php
$form = $this->form;
$form->prepare();

$form->get('email')->setAttributes([
  'class'=>'form-control', 
  'placeholder'=>'name@example.com'
  ]);
  
$form->get('subject')->setAttributes([
  'class'=>'form-control', 
  'placeholder'=>'Type subject here'
  ]);
  
$form->get('body')->setAttributes([
  'class'=>'form-control', 
  'rows'=>6, 
  'placeholder'=>'Type message text here'
  ]);
  
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
?>

<h1>Contact Us</h1>

<p>
  Please fill out the following form to contact us. 
  We appreciate your feedback. 
</p>

<div class="row">
  <div class="col-md-6">
    <?= $this->form()->openTag($form); ?>
        
    <div class="form-group">
      <?= $this->formLabel($form->get('email')); ?>
      <?= $this->formElement($form->get('email')); ?>
      <?= $this->formElementErrors($form->get('email')); ?>
    </div>
        
    <div class="form-group">
      <?= $this->formLabel($form->get('subject')); ?>
      <?= $this->formElement($form->get('subject')); ?>
      <?= $this->formElementErrors($form->get('subject')); ?>
    </div>
        
    <div class="form-group">
      <?= $this->formLabel($form->get('body')); ?>
      <?= $this->formElement($form->get('body')); ?>
      <?= $this->formElementErrors($form->get('body')); ?>
    </div>
        
    <?= $this->formElement($form->get('submit')); ?>
        
    <?= $this->form()->closeTag(); ?>
  </div>    
</div>
~~~

Im obigen Code haben wir die CSS-Klasse `.form-control` zu jedem Eingabefeld im Formular hinzugefügt.
Das machen wir mit der Methode `setAttribute()` (siehe Zeilen 5, 10 und 15).
Mit dieser Methode haben wir auch das Attribut "placeholder" hinzugefügt, um einen 
gut aussehenden Platzhaltertext anzuzeigen, wenn ein Feld leer ist. Für das Feld "body"
haben wir das Attribut "rows" hinzugefügt, das die Höhe des Feldes definiert (6 Zeilen).

Für den Button *Submit* des Formulars verwenden wir die CSS-Klassen 
`.btn` und` .btn-primary` (siehe Zeile 21).

Wir setzen auch Label-Input-Paare innerhalb des Elementes `<div>` mit der 
CSS-Klasse `.form-group` (Zeilen 35, 41, 47).

Wir fügen das Formular in die Gitterzelle mit 6 Spalten ein, dass das Formular nur Hälfte
der Breite des Bildschirms einnimmt (siehe Zeilen 31-32).

T> Manchmal ist es nicht möglich, das Bootstrap-Design von Twitter mit standardmäßigen ZF3-Formular-View-Helpern zu verwenden.
T> Zum Beispiel können Standard-View-Helper @`FormCheckbox` und @`FormRadio` nicht zur Unterstützung für den
T> Bootstrap-Stile optimiert werden. Glücklicherweise gibt es ein Drittanbieter-Modul [neilime/zf2-twb-bundle](https://github.com/neilime/zf2-twb-bundle),
T> dass Sie mit Composer installieren können (nicht mit dem Namen der Module verwechselt - es unterstützt auch ZF3). Dieses Modul bietet komfortable Hilfe zum Anzeigen von ZF3-Formularen
T> und wendet das Bootstrap-Styling auf sie an. Es funktioniert transparent, also sobald Sie das Modul installiert haben, werden die Standard-ZF3-Form-View-Helper
T> durch die Form-View-Helper des installierte Moduls ersetzt, sodass Sie den Code des View-Templates nicht ändern müssen.

### Styling der Validierungsfehlerliste

Die Fehlermeldungen in Ihrem Formular sehen standardmäßig wie eine typische ungeordnete Liste aus (`<ul>`).
Um ihnen eine schöne visuelle Erscheinung zu geben, fügen wir der Datei *style.css* einige CSS-Regeln hinzu.
Die Datei liegt im Verzeichnis *APP_DIR/public*:

{line-numbers=off, lang=css}
~~~
form ul {
  list-style-type: none;
  padding: 0px;
  margin: 0px 5px;
}

form ul li {    
  color: red;        
}
~~~

Die obigen CSS-Regeln entfernen Aufzählungszeichen aus der Liste und
Validierungsfehlermeldungen werden in rot angezeigt.

### Hinzufügen der Seiten "Thank You" und "Error Sending Email"

Die letzte kleine Sache, die wir tun werden, wir erstellen die View-Templates für
die Seiten "Thank You" und "Error Sending Email".

Erstellen Sie ein View-Template *thank-you.phtml* im Verzeichnis *application/index/* im Verzeichnis
*view/* unserem Moduls. Fügen Sie das folgende HTML-Markup in das View-Template ein:

{line-numbers=off, lang=html}
~~~
<h1>Thank You!</h1>

<p>
  <div class="alert alert-success">
    We will respond to the E-mail address you have provided.
  </div>
</p>
~~~

Erstellen Sie als Nächstes das View-Template *send-error.phtml*.
Das HTML-Markup für die Seite *Error Sending Email* ist unten dargestellt:

{line-numbers=off, lang=html}
~~~
<h1>Error Sending Email!</h1>

<p>
  <div class="alert alert-warning">
    Sorry, but we had an unexpected problem when trying to deliver 
    your message. Please try again later.
  </div>
</p>
~~~

### Ergebnisse

Herzliche Glückwünsche! Wenn Sie jetzt die URL "http://localhost/ contactus"
in Ihrem Webbrowser öffnen, sollten Sie eine Seite wie in Abbildung 7.20 sehen.

{width=80%}
![Abbildung 7.20. Kontaktformular](images/forms/contact_form.png)

Wenn Sie ungültige Daten in das Formular eingeben und auf den Submit-Button klicken, sollten Sie
die Validierungsfehler sehen (Abbildung 7.21).

![Abbildung 7.21. Formularüberprüfungsfehler](images/forms/validation_errors_page.png)

Bei Eingabe der korrekten E-Mail-Adresse, des Betreffs und des Nachrichtentexte und das Absenden des
Formulars führt zum Senden der Nachricht und zum Anzeigen der *Thank You* (siehe Abbildung 7.22).

![Abbildung 7.22. Seite Thank You](images/forms/thank_you_page.png)

Bei einem Sendefehler wird die Seite *Error Sending Email* angezeigt (siehe Abbildung 7.23):

![Abbildung 7.23. Seite Error Sending Email](images/forms/send_error_page.png)

T> Sie können das *Kontaktformular* in Aktion *Form Demo* im Beispiel *Form Demo* sehen.
T> Diese Anwendung ist mit diesem Buch gebündelt.

## Zusammenfassung

Formulare sind die Möglichkeit, von Benutzern eingegebene Daten auf Webseiten zu sammeln. Ein Formular
besteht normalerweise aus Elementen (Eingabefeld + Label-Paare). Elemente können optional
in Fieldsets gruppiert sein.

In einer MVC-basierten Website ist die Formularfunktionalität in Formularmodelle unterteilt.
Diese sind verantwortlich für Elementdefinition und-validierung und Formularpräsentation.
Sie werden mit Hilfe von speziellen View-Helpern implementiert.

Um ein Formularmodell zu erstellen, schreiben Sie eine Klasse, die von der Basisklasse @`Form`[Zend\Form\Form] abgeleitet wird.
Das Formularmodell wird initialisiert, indem seine Elemente mit Hilfe der von der Basisklasse bereitgestellen 
Methoden hinzugefügt werden.

Um Formulardaten an den Server zu senden, klickt der Benutzer auf die Button *Senden* und dann werden die Daten
als Teil eines HTTP-Request gesendet. Sobald der Benutzer das Formular übermittelt hat, können Sie die Daten aus 
dem Formular in Ihrem Controller extrahieren und das Formularmodell abfragen, um es zu validieren.

Zum Überprüfen und Filtern der vom Benutzer eingegebenen Daten, werden Filter und Validatoren
verwendet. Sie verwenden die Klasse @`InputFilter`[Zend\InputFilter\InputFilter], welcher der Container für die Validierung 
der Regeln ist.

Wenn Eingabefehler auftreten, zeigen Sie das Formular erneut an und bitten den Benutzer, die Eingabefehler im Formular 
zu korrigieren. Wenn die Daten korrekt sind, verarbeiten Sie die Daten mit Ihrer Geschäftslogikschicht.

