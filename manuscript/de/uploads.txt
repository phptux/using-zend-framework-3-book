# Hochladen von Dateien mit Formularen {#uploads}

In diesem Kapitel erfahren Sie, wie Sie Dateien mit Formularen hochladen. Zuerst werden wir die Grundlagen behandeln,
wie die Funktion HTTP-Datei-Upload und binäre Übertragung von Inhalten funktioniert. Dann werden wir an einem
vollständigen Beispiel eine Bildergalerie erstellen. Dabei zeigen wir Ihnen, wie Bilder auf einen Webserver hochgeladen werden.

In diesem Kapitel behandelte ZF3-Komponenten:

|-----------------------|-------------------------------------------------------|
| *Komponente* 			| *Beschreibung* 										|
|-----------------------|-------------------------------------------------------|
| @`Zend\Form` 			| Enthält Basisformularmodellklassen. 					|
|-----------------------|-------------------------------------------------------|
| @`Zend\Filter` 		| Enthält verschiedene Filterklassen. 					|
|-----------------------|-------------------------------------------------------|
| @`Zend\Validator` 	| Implementiert verschiedene Validator-Klassen. 		|
|-----------------------|-------------------------------------------------------|
| @`Zend\InputFilter`	| Implementiert einen Container für Filter/Validatoren.	|
|-----------------------|-------------------------------------------------------|

## Über HTTP-Dateiuploads

HTML-Formulare können beliebig große Dateien hochladen [^rfc-1867].
Die Dateien werden normalerweise über die HTTP-POST-Methode [^get] übertragen.

[^rfc-1867]: Das Hochladen von HTTP-Dateien wird in [RFC-1867] (http://www.ietf.org/rfc/rfc1867.txt) beschrieben. Dieser Mechanismus
             ermöglicht das Hochladen großer Dateien mithilfe der binären Codierung des Inhalts während der Übertragung.
             Es wird der Codierungstyp "multipart/form-data" für diesen Zweck verwendet.
             
[^get]: Die HTTP-GET-Methode ist für das Hochladen von Dateien ineffizient, da die URL-Länge eine
        obere Begrenzung hat. Außerdem erhöht die URL-Codierung der Dateidaten die URL-Länge erheblich.

HTTP verwendet standardmäßig die *URL-Codierung* für die Übertragung von Formulardaten.
Wie diese Kodierung aussieht, haben wir in den vorherigen Kapiteln gesehen. Diese Codierung ist jedoch für das Hochladen großer Dateien ineffizient,
weil binäre Daten die URL-Kodierung drastisch erhöhen und der HTTP-Request wird länger.
Für das Hochladen von Dateien wird stattdessen die Verwendung des sogenannten "binary transfer encoding" 
empfohlen. Dies beschreiben wir im nächsten Abschnitt.

### HTTP Binary Transfer Encoding

Ein einfaches HTML-Formular, das Dateien hochladen kann, wird im folgenden Codebeispiel gezeigt. Der binäre
Codierungstyp wird aktiviert, indem das Attribut `enctype` des Formulars mit dem Wert
von "multipart/form-data" gesetzt wird:

{line-numbers=on, lang=html}
~~~
<form action="upload" method="POST" enctype="multipart/form-data">
    <input type="file" name="myfile">
    <br/>
    <input type="submit" name="Submit">
</form>
~~~

In Zeile 1 setzen wir die Formularkodierung (Attribut `enctype`) explizit auf "multipart/form-data".
Dadurch verwendet das Formular die binäre Übertragung von binären Inhalten.

In Zeile 2 definieren wir ein Eingabefeld mit dem Typ "file" und dem Namen "myfile". Dieses Eingabefeld
ermöglicht es dem Website-Besucher, die Datei für den Upload auszuwählen.

Wenn Sie nun das oben genannte Markup in einer *.html*-Datei speichern und in Ihren Webbrowser öffnen,
sehen Sie die Seite wie in Abbildung 10.1.

![Abbildung 10.1. Ein einfaches HTML-Formular, das Datei hochladen kann](images/uploads/html_upload_form.png).

Das Dateielement hat den Button *Durchsuchen ...*, mit der Sie eine Datei zum Hochladen auswählen können.
Wenn der Site-Benutzer eine Datei auswählt und im Formular auf den Button *Submit* klickt, wird der Webbrowser
eine HTTP-Anforderung an den Webserver senden und der HTTP-Request enthält die Daten der hochzuladenden Datei.
Das folgende Beispiel veranschaulicht, wie der HTTP-Request aussehen kann:

{line-numbers=on, lang=text}
~~~
POST http://localhost/upload HTTP/1.1
Host: localhost
Content-Length: 488
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Content-Type: multipart/form-data; boundary=----j1bOrwgLvOC3dy7o
Accept-Encoding: gzip,deflate,sdch

------j1bOrwgLvOC3dy7o
Content-Disposition: form-data; name="myfile"; filename="Somefile.txt"
Content-Type: text/html

(file binary data goes here)
------j1bOrwgLvOC3dy7o
Content-Disposition: form-data; name="Submit"

Submit Request
------j1bOrwgLvOC3dy7o--
~~~

Wie Sie im obigen Beispiel sehen können, sieht der HTTP-Request mit dem Codierungstyp "multipart/form-data"
analog zu einem gewöhnlichen HTTP-Request aus (hat die Statuszeile, die Header und den Inhaltsbereich).
Es gibt jedoch die folgenden wichtigen Unterschiede:

* Zeile 5 setzt den Header "Content-Type" mit dem Wert "multipart/form-data". Die Felder des Formulars werden
  durch die "boundary" ("Begrenzung") gekennzeichnet - eine eindeutige zufällig erzeugte Folge von Zeichen,
  die die Felder voneinander abgrenzt.
  
* Die Zeilen 8-17 repräsentieren den Inhalt des HTTP-Requests. Die Formularfelder werden durch "boundary" 
  begrenzt (Zeilen 8, 13, 17). Die Daten der hochzuladenden Datei werden im Binärformat übertragen
  (Zeile 12), wodurch die Größe des Inhalts auf ein Minimum reduziert werden kann.

W> Standardmäßig erlauben die Einstellungen der PHP-Engine nicht, große Dateien (größer als 2 MB) hochzuladen. Um
W> große Dateien hochzuladen, müssen Sie möglicherweise die Konfigurationsdatei *php.ini* von PHP bearbeiten und die Direktiven `post_max_size`
W> und `upload_max_filesize` ändern (Informationen dazu finden Sie im [Anhang A. Konfigurieren der Webentwicklungsumgebung](#devenv)).
W> Wenn Sie dieser Direktiven mit `100M` zuweisen, können Sie Dateien mit einer Größe von bis zu 100 MB hochladen. Dies ist normalerweise ausreichend.
W> Wenn Sie sehr große Dateien mit einer Größe von bis zu 1 GB hochladen möchten, sollten Sie dieser besser mit 1024 MB zuweisen.
W> Vergessen Sie nicht, den Apache Web Server nach dem Bearbeiten der Konfigurationsdatei neu zu starten.

### Super-Globales Array $_FILES in PHP
  
Wenn ein Websitebesucher Dateien auf Ihren Apache Web Server hochlädt, werden die Dateien an einem temporären Speicherort abgelegt
(normalerweise in ein temporäres Systemverzeichnis, das unter Linux */tmp * und unter Windows *C:\\Windows\\Temp* ist).
Das PHP-Skript empfängt die Dateiinformationen und speichert diese in das globale Array mit dem Namen `$_FILES`.

I> Das Array `$ _FILES` ist analog zu den Super-Globalen Variablen `$_GET` und `$_POST`. Die letzten beiden
I> dienen zum Speichern der Variablen GET bzw. POST, während die erste Variable verwendet wird,
I> um Informationen zu den hochgeladenen Dateien zu speichern.

Für das oben erwähnte einfache Upload-Formular wird beispielsweise das super-globale Array `$_FILES`
wie folgt aussehen (die Ausgabe wird mit der PHP-Funktion `var_dump()` generiert):

{line-numbers=on, lang=text}
~~~
array (size=1)
    'myfile' => 
        array (size=5)
            'name' => string 'somefile.txt' (length=12)
            'type' => string 'text/plain' (length=10)
            'tmp_name' => string '/tmp/phpDC66.tmp' (length=16)
            'error' => int 0
            'size' => int 18
~~~

Wie Sie im obigen Beispiel sehen können, enthält das Array `$_FILES` einen Eintrag
je hochgeladener Datei. Für jede hochgeladene Datei enthält sie folgende Informationen:

  * `name` - ursprünglicher Dateiname (Zeile 4).
  * `type` - MIME [^mime] - Typ der Datei (Zeile 5).
  * `tmp_name` - temporärer Name für die hochgeladene Datei (Zeile 6).
  * `error` - Fehlermeldung über den Status des Uploads (Zeile 7);
     Fehlercode `0` bedeutet, dass die Datei korrekt hochgeladen wurde.
  * `size` - Dateigröße in Bytes (Zeile 8).

[^mime]: Der MIME-Typ, auch als "Inhaltstyp" bezeichnet, ist ein Standard-Bezeichner, der im Internet
         den Datentyp angibt bzw. welche Daten eine Datei enthält. Zum Beispiel der MIME-Typ "text/plain"
         wird einer Textdatei zugewiesen, der MIME-Typ "application/octet-stream"
         ist einer binären Datei zugeordnet.
  
Die PHP-Engine speichert die hochgeladenen Dateien an einem temporären Speicherort, der bereinigt wird, sobald PHP die
Skriptausführung beendet hat. Wenn Sie also die hochgeladenen Dateien zur späteren Verwendung in einem Verzeichnis speichern möchten,
müssen Sie die PHP-Funktion `move_uploaded_file()` verwenden. Die Funktion `move_uploaded_file()`
nimmt zwei Argumente entgegen: Das erste ist der Name der temporären Datei und das zweite ist der Dateiname
als Ziel.

T> Es kann Sie verwirrt etwas verwirren, warum Sie die übliche PHP-Funktion `rename()` zum Verschieben von
T> temporär hochgeladenen Dateien in einen Zielpfad nicht verwenden können. Aus Sicherheitsgründen hat PHP eine 
T> spezielle Funktion zum Verschieben, um hochgeladene Dateien zu verschieben. Die Funktion `move_uploaded_file()` ist analog zu
T> der Funktion `rename ()`. Es sind jedoch einige zusätzliche Überprüfungen erforderlich, um sicherzustellen, dass die Datei wirklich
T> über einen HTTP-POST-Request übertragen wurde und der Upload-Vorgang ohne Fehler abgeschlossen wurde.

Das folgende Codebeispiel zeigt, wie Sie die mit der hochgeladene Datei verschieben können.
Das Beispiel bezieht sich auf das einfache Formular, welches wir oben betrachtet haben:

{line-numbers=on, lang=php}
~~~
$destPath = '/path/to/your/upload/dir';
$result = move_uploaded_file($_FILES['myfile']['tmp_name'], $destPath);
if(!$result) {
    // Some error occurred.
}
~~~
  
Oben in Zeile 1 setzen wir den `$destPath` mit dem Verzeichnisnamen, in dem die hochgeladene Datei 
gespeichert werden soll.

In Zeile 2 rufen wir die Funktion `move_uploaded_file()` auf und übergeben ihr zwei Argumente: den Pfad zur
temporäre Datei und den Zielpfad.

T> Die Angabe des Verzeichnisnamens als zweites Argument der Funktion `move_uploaded_file()`
T> ist ausreichend, wenn Sie die Datei nicht umbenennen möchten. Wenn Sie die hochgeladene Datei unter einem anderen Namen 
T> als dem ursprünglichen Namen speichern müssen, können Sie anstelle des Verzeichnisnamens den vollständigen Dateipfad angeben.

In Zeile 3 überprüfen wir den Rückgabewert der Funktion. Wenn die Operation erfolgreich ist,
gibt die Funktion `true` zurück. Wenn ein Fehler auftritt (z.B. wenn die Verzeichnisberechtigungen
nicht ausreichen, um die Datei zu speichern), wird das boolesche `false` zurückgegeben.
  
## Zugriff auf hochgeladene Dateien in ZF3

In Ihrer Controller-Klasse kommunizieren Sie normalerweise nicht mit dem Array `$_FILES`.
Sie können stattdessen die Klasse @`Request`[Zend\Http\Request] oder das Controller-Plugin @` Params` verwenden,
wie im folgenden Codebeispiel gezeigt:

{line-numbers=on, lang=php}
~~~
<?php 
//...
class IndexController extends AbstractActionController 
{
    // An example controller action intended for handling file uploads.
    public function uploadAction() 
    {
        // Get the whole $_FILES array.
        $files = $this->getRequest()->getFiles();
  
        // The same, but with Params controller plugin.
        $files = $this->params()->fromFiles();
  
        // Get a single entry of the $_FILES array.
        $files = $this->params()->fromFiles('myfile');
  }
}
~~~

In Zeile 9 des obigen Codes verwenden wir für den Zugriff die Methode `getRequest()' der Controller-Klasse,
die das Objekt @`Request`[Zend\Http\Request] zurück gibt und dann die Methode `getFiles()` des Request-Objekts, um die Informationen
aller Upload-Dateien auf einmal abzurufen.

In Zeile 12 machen wir dasselbe mit dem Controller-Plugin @`Params`. Wir verwenden die Methode `fromFiles()`
um Informationen über alle hochgeladenen Dateien zu erhalten.

Bei Bedarf können Sie die Informationen nur für eine bestimmte Datei abrufen. In Zeile 15 verwenden wir die dasselbe
Methode `fromFiles ()` und übergeben ihr den Namen des abzurufenden Dateifeldes. Dadurch wird die nur ein
Dateieintrag aus dem super-globalen Array `$ _FILES` zurückgegeben.
  
## Datei-Uploads & das ZF3-Formularmodell

Um Ihrem Formularmodell die Funktion zum Hochladen von Dateien hinzuzufügen, müssen Sie ein Element 
der Klasse @`Zend\Form\Element\File` wie folgt hinzufügen:

{line-numbers=on, lang=php}
~~~
    // Add the following code inside of form's addElements() method.
  
    // Add the "file" field.
    $this->add([
        'type'  => 'file',
        'name' => 'file',
        'attributes' => [                
            'id' => 'file'
        ],
        'options' => [
            'label' => 'Upload file',
        ],
    ]);
~~~

Im obigen Code rufen wir die Methode `add()`, die von der Basisklasse @`Form`[Zend\Form\Form] bereitgestellt wird,
auf und übergeben ihr das Konfigurations-Array, welches das Element beschreibt. 
Der Schlüssel des Arrays `type` (Zeile 5) muss entweder der vollständige Klassenname @`Zend\Form\Element\File` sein
oder sein Kurzalias "file".

## Hochgeladene Dateien überprüfen

Hochgeladene Dateien müssen wie alle anderen Formulardaten auf ihre Richtigkeit überprüft werden. Zum Beispiel,
sollten Sie folgendes überprüfen:

  * Die Datei(en) wurden wirklich über einen HTTP POST-Request hochgeladen und nicht nur aus einem Verzeichnis kopiert.
  
  * Die Datei(en) wurden erfolgreich hochgeladen (der Fehlercode ist `0`);
  
  * Die Dateinamen und/oder Erweiterungen sind zulässig (z.B. möchten Sie nur JPEG-Dateien speichern und alle anderen ablehnen).
  
  * Die Dateigröße liegt im zulässigen Bereich (Sie möchten beispielsweise sicherstellen, dass die Datei nicht zu groß ist).
  
  * Die Gesamtanzahl der hochgeladenen Dateien überschreitet nicht ein zulässiges Limit.

Für die oben beschriebenen Prüfungen bietet ZF3 eine Reihe nützlicher Dateiprüfer (in Tabelle 10.1 aufgeführt).
Diese Validator-Klassen gehören zur Komponente @`Zend\Validator` und befinden sich im Namensraum @`Zend\Validator\File`[Zend\Validator].

{title="Tabelle 10.1. Standard-File-Validatoren"}
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| *Klassenname* 					| *Kurzer Alias* 			| *Beschreibung* 																						|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Count` 							| `FileCount` 				| Überprüft, ob die Anzahl der Dateien in einem bestimmten Bereich liegen (min, max). 					|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`WordCount` 						| `FileWordCount` 			| Berechnet die Anzahl der Wörter in einer Datei und prüft, ob sie in einem bestimmten Bereich liegen. 	|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Upload` 						| `FileUpload` 				| Führt Sicherheitsüberprüfungen durch, um sicherzustellen, dass alle angegebenen Dateien wirklich über	|
|																|| HTTP POST hochgeladen wurden und keine Uploadfehler aufgetreten sind. 								|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`UploadFile` 					| `FileUploadFile` 			| Führt Sicherheitsüberprüfungen durch, um sicherzustellen, dass eine Datei wirklich über HTTP POST		|
|																|| hochgeladen wurde und keine Upload-Fehler aufgetreten ist. 											|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Size` 							| `FileSize` 				| Überprüft, ob die Dateigröße in einem bestimmten Bereich liegt. 										|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`FilesSize` 						| `FileFilesSize` 			| Überprüft, ob die Gesamtgröße aller angegebenen Dateien in einem bestimmten Bereich liegt.			|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Extension` 						| `FileExtension` 			| Überprüft, ob die Erweiterung einer Datei zu einer Gruppe zulässiger Erweiterungen gehört. 			|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`ExcludeExtension` 				| `FileExcludeExtension`	| Überprüft, ob die Erweiterung einer Datei NICHT zu einer Gruppe von Erweiterungen gehört. 			|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`MimeType` 						| `FileMimeType` 			| Überprüft, ob der MIME-Typ einer Datei zur Liste der zulässigen MIME-Typen gehört. 					|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`ExcludeMimeType` 				| `FileExcludeMimeType` 	| Überprüft, ob der MIME-Typ einer Datei NICHT zur Liste der MIME-Typen gehört. 						|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`IsImage` 						| `FileIsImage` 			| Überprüft, ob es sich bei der Datei um ein grafisches Bild handelt (JPEG, PNG, GIF usw.)				|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`ImageSize` 						| `FileImageSize` 			| Überprüft, ob die Größe der Bilddatei in einem bestimmten Bereich liegen. 							|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Exists` 						| `FileExists` 				| Überprüft, ob die Datei auf der Festplatte vorhanden ist. 											|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`NotExists` 						| `FileNotExists` 			| Überprüft, ob die Datei nicht auf der Festplatte vorhanden ist. 										|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`IsCompressed` 					| `FileIsCompressed` 		| Überprüft, ob es sich bei der Datei um ein Archiv handelt (ZIP, TAR usw.) 							|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Hash`[Zend\Validator\File\Hash]	| `FileHash` 				| Überprüft, ob der Dateiinhalt mit dem angegebenen Hash(es) übereinstimmt. 							|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Crc32` 							| `FileCrc32` 				| Überprüft, ob der Dateiinhalt die angegebene CRC32-Prüfsumme aufweist. 								|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Sha1` 							| `FileSha1` 				| Überprüft, ob der Dateiinhalt den angegebenen SHA-1-Hash hat. 										|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|
| @`Md5` 							| `FileMd5` 				| Überprüft, ob der Dateiinhalt den angegebenen MD5-Hash hat. 											|
|-----------------------------------|---------------------------|-------------------------------------------------------------------------------------------------------|

Wie Sie der obigen Tabelle entnehmen können, können Datei-Validatoren grob in die folgenden Gruppen unterteilt werden:

 * Validatoren, die prüfen, ob die Datei(en) wirklich über HTTP POST hochgeladen wurden und der Upload-Status OK ist.
 * Validatoren, die die Anzahl der hochgeladenen Dateien und die Dateigröße überprüfen;
 * Validatoren, die die Dateierweiterung und den MIME-Typ überprüfen;
 * Validatoren, die prüfen, ob es sich bei der Datei um ein grafisches Bild handelt und die die Bildgröße überprüfen;
 * Validatoren, die den Datei-Hash prüfen (oder die Prüfsumme) [^hash].
  
[^hash]: Ein Datei-Hash wird zur Überprüfung der Dateidatenintegrität verwendet (z.B. um sicherzustellen,
         dass die Dateidaten beschädigt nicht beschädigt sind). Es gibt verschiedene Hash-Algorithmen (MD5, SHA-1, CRC32 usw.).

T> Bitte beachten Sie, dass die Datei-Validatoren im Namensraum @`Zend\Validator\File`[Zend\Validator] liegen. Ihr kurzer Aliasname
T> (den Sie beim Erstellen eines Validators mit einer Factory verwenden) beginnt mit dem Präfix `File`. Zum Beispiel,
T> der Validator @`IsImage` hat den Alias `FileIsImage`.
         
In einem Codebeispiel einer *Bildergallerie* zeigen wir Ihnen später in diesem Kapitel, wie Sie einige dieser 
Datei-Validatoren verwenden können.

## Hochgeladene Dateien filtern

Zend Framework 3 bietet mehrere Filter zum "Umwandeln" von Dateifeldern. Diese filtern
Klassen (in Tabelle 10.2 aufgelistet) gehören zur @ Zend \ Filter-Komponente und leben im @ `Zend \ Filter \ File`-Namespace.

{title="Tabelle 10.2. Standard-Datei-Filter"}
|---------------------------------------|-----------------------|---------------------------------------------------------------------------------------|
| *Klassenname* 						| *Kurzer Alias* 		| *Beschreibung* 																		|
|---------------------------------------|-----------------------|---------------------------------------------------------------------------------------|
| @`Rename` 							| `FileRename` 			| Benennt eine beliebige Datei um oder verschiebt sie. 									|
|---------------------------------------|-----------------------|---------------------------------------------------------------------------------------|
| @`RenameUpload` 						| `FileRenameUpload`	| Benennt eine beliebige Datei um oder verschiebt diese mit einer Sicherheitsprüfungen.	|
|---------------------------------------|-----------------------|---------------------------------------------------------------------------------------|
| @`Encrypt`[Zend\Filter\File\Encrypt]	| `FileEncrypt` 		| Verschlüsselt eine bestimmte Datei und speichert den verschlüsselten Dateiinhalt. 	|
|---------------------------------------|-----------------------|---------------------------------------------------------------------------------------|
| @`Decrypt`[Zend\Filter\File\Decrypt]	| `FileDecrypt` 		| Entschlüsselt eine bestimmte Datei und speichert den entschlüsselten Dateiinhalt. 	|
|---------------------------------------|-----------------------|---------------------------------------------------------------------------------------|
| @`LowerCase` 							| `FileLowerCase` 		| Konvertiert den Inhalt der Datei in Kleinbuchstaben. 									|
|---------------------------------------|-----------------------|---------------------------------------------------------------------------------------|
| @`UpperCase` 							| `FileUpperCase` 		| Konvertiert den Dateiinhalt in Großbuchstaben. 										|
|---------------------------------------|-----------------------|---------------------------------------------------------------------------------------|

In der Tabelle können Sie sehen, dass die Filter in folgenden Gruppen unterteilt werden können:

  * Filter zum Verschieben hochgeladener Dateien von einem temporären Speicherort in ihr endgültiges Verzeichnis;
  * Filter für die Verschlüsselung und Entschlüsselung von Dateien;
  * Filter zum Konvertieren von Textdateien in Groß-und Kleinbuchstaben.

T> Bitte beachten Sie, dass Dateifilter im Namensraum @`Zend\Filter\File`[Zend\Filter] liegen. Ihre kurzen Aliasnamen
T> (die Sie beim Erstellen eines Filters mit der Factory verwenden) beginnen mit dem Präfix `File`. Zum Beispiel,
T> hat der Filter @`RenameUpload` den Alias ​​`FileRenameUpload`.
  
Die Filter @`Encrypt`[Zend\Filter\File\Encrypt] und @`Decrypt`[Zend\Filter\File\Decrypt] ermöglichen die Anwendung verschiedener Verschlüsselungs-und Entschlüsselungsalgorithmen.
an die hochgeladene Datei (Der konkrete Algorithmus wird durch Angabe des jeweiligen Adapters festgelegt.) Die Filter @`LowerCase` und
@`UpperCase` eignen sich zum Konvertieren von Textdateien in Klein-bzw. Großbuchstaben [^four].

[^four]: Nach Meinung des Autors sind die oben genannten letzten vier Filter beim Arbeiten mit hochgeladenen Dateien 
         nicht sehr nützlich, da Sie eine hochgeladene Datei selten verschlüsseln oder in eine Datei in
         Kleinbuchstaben konvertieren müssen.

Mit dem Filter @`Rename` können Sie eine beliebige Datei (nicht nur eine hochgeladene Datei) umbenennen und/oder verschieben.
Der Filter verwendet intern die PHP-Funktion `rename()`. Daher wird es im Allgemeinen nicht empfohlen,
diesen Filter aus Sicherheitsgründen für hochgeladene Dateien zu verwenden.

Der Filter  @`RenameUpload` ist viel nützlicher als andere Filter, da er für das verschieben/benennen der hochgeladenen Datei(en)
von einem temporären Speicherort zu seinem endgültigen Verzeichnis die PHP-Funktion `move_uploaded_file()` verwendet. 
Wir zeigen Ihnen später in diesem Kapitel ein Codebeispiel, wie Sie den Filter @`RenameUpload` in der *Bildergallerie* 
verwenden können.
  
## InputFilter Container und Datei-Uploads

Wie Sie sich vielleicht erinnern, handelt es sich in der Regel um Filter und Validatoren, die an ein Formularmodell durch
den Container  @`InputFilter`[Zend\InputFilter\InputFilter] angehängt werden und gespeichert werden, welcher aus *Eingaben* besteht (eine Eingabe wird normalerweise
von der Klasse @`Input`[Zend\InputFilter\Input] entnommen, die zum Namensraum @`Zend\InputFilter` gehört.) Für gewöhnliche Formularfelder werden die Filter
*vor* den Validatoren ausgeführt und Validatoren *werden nach* den Filtern ausgeführt.

Beim Hochladen von Dateien gibt es jedoch einige wichtige Unterschiede:

  1. zum Speichern von Validierungsregeln für hochgeladene Dateien sollte die spezielle Klasse namens @`FileInput`
     anstelle der Klasse @`Input`[Zend\InputFilter\Input] verwendet werden;
  2. und Validatoren werden *vor* dem Filtern (!) angewendet.
     
### FileInput

Um Validierungsregeln für hochgeladene Dateien zu speichern, müssen Sie die Klasse @`FileInput` anstelle der
üblichen Klasse @`Input`[Zend\InputFilter\Input] verwenden.

In der privaten Methode `addInputFilter()` Ihres Formularmodells fügen Sie die Validierungsregeln für die
Dateiübertragung wie folgt hinzu:

{line-numbers=on, lang=php}
~~~
    $inputFilter->add([
        'type'     => 'Zend\InputFilter\FileInput',
        'name'     => 'file',  // Element's name.
        'required' => true,    // Whether the field is required.
        'filters'  => [        // Filters.
            // Put filter info here.   
        ],                
        'validators' => [      // Validators.
            // Put validator info here.
        ]        
    ]); 
~~~

Oben setzen wir den Schlüssel "type" (Zeile 2) mit dem Klassennamen @`Zend\InputFilter\FileInput`.
Die übrigen Schlüssel entsprechen denen, die wir zuvor beim Hinzufügen von Validierungsregeln für ein Formularmodell verwendet haben.

Das Verhalten der Klasse @`FileInput` unterscheidet sich vom @`Input`[Zend\InputFilter\Input] in folgenden Aspekten:

 1. Sie erwartet, dass die Daten ihr aus dem Array `$_FILES` übergeben werden (ein Array-Eintrag mit
    `tmp_name`,` error`, `type` keys).
    
 2. Vor allen anderen Validatoren wird automatisch ein Validator @`Zend\Validator\File\Upload`
    der Validatoren-Liste hinzugefügt.

 3. Die in die Validator-Liste eingefügten Validatoren werden *vor den* Filter in der Filter-Liste ausgeführt.
    Dies steht im Gegensatz zum Verhalten der Klasse @`Input`[Zend\InputFilter\Input].

### Validatoren vor den Filtern ausführen

Bei üblichen Formularfeldern werden die Filter normalerweise *vor* den Validatoren ausgeführt und
*danach* die Validatoren. Bei Datei-Uploads ist diese Reihenfolge jedoch umgekehrt.

I> Für Datei-Uploads werden Validatoren *vor* den Filtern ausgeführt. Dieses Verhalten ist umgekehrt zur
I> üblichen Vorgehensweise.

Wenn Sie mit hochgeladenen Dateien arbeiten, müssen Sie zunächst die aus dem super-globale Array `$ _FILES` erhaltenen Daten
auf Korrektheit prüfen, und dann müssen Sie mit den Dateien etwas anderes tun (Verschieben der Datei in ein
Speicherverzeichnis, umbenennen usw.) Aus diesem Grund müssen Dateivalidierer zuerst ausgeführt werden als die
Filter. Diese werden zuletzt ausgeführt.

Sehen wir uns einen typischen Arbeitsablauf für ein Formular an, um zu sehen, wie dieses ausgeführt wird:

 * Zuerst rufen wir die Methode `setData()` auf, um das Formular mit Daten zu füllen.
 * Rufen dann die Methode `isValid()` auf, um registrierte Filter und Validatoren des Formulars auszuführen.
 * Rufen dann, nach erfolgreicher Validierung, `getData()` auf, um die gefilterten und validierten Daten zu erhalten.
 * Rufen dann bei einem Fehler `getMessages()` auf, um die Fehlermeldungen abzurufen.

Wenn Sie @`FileInput` verwenden, ist der Arbeitsablauf derselbe. Es ist jedoch wichtig zu wissen, was
schrittweise passiert:

 * Ruft die Methode `setData()` auf, um das Formular mit Daten zu füllen.
 * Ruft die Methode `isValid()` auf, um registrierte **Validatoren** im Eingabefilter des Formular auszuführen.
 * Ruft nach erfolgreicher Validierung die Funktion `getData()` auf, um die **Filter auszuführen** und
   die validierte Daten an den Eingabefilter des Formular zu übergeben.
 * Ruft bei einem Fehler `getMessages()` auf, um die Fehlermeldungen abzurufen.
 
I> Bitte beachten Sie, dass bei @`FileInput` die registrierten Filter nur dann ausgeführt werden, wenn die
I> Methode `getData()` wird aufgerufen.

Wenn Sie sowohl @`Input`[Zend\InputFilter\Input] als auch @`FileInput` als Eingabefilter Ihres Formulars verwenden (was ein üblicher Fall ist),
dann werden die Filter für gewöhnliche Eingaben immer noch zuerst ausgeführt, für Dateieingaben jedoch zuerst der Validator.

## Controller-Aktion und Datei-Uploads

In diesem Abschnitt stellen wir ein kurzes Codebeispiel vor, in dem beschrieben wird, wie Datei-Uploads in einer
Controller-Aktionsmethode behandelt werden. Wir werden Sie auf die Aspekte aufmerksam machen, die für das Hochladen von Dateien gelten.

Angenommen, wir möchten eine Seite hinzufügen, die ein Formular enthält (nennen wir es `YourForm`), das Dateien hochladen kann.
Für diese Seite müssen wir die Methode `uploadAction()` der Controller-Klasse hinzufügen:

{line-numbers=on, lang=php}
~~~
<?php
//...
class IndexController extends AbstractActionController 
{
    // This is the "upload" action displaying the Upload page.
    public function uploadAction() 
    {
        // Create the form model.
        $form = new YourForm();
        
        // Check if user has submitted the form.
        if($this->getRequest()->isPost()) {
            
            // Make certain to merge the files info!
            $request = $this->getRequest();
            $data = array_merge_recursive(
                $request->getPost()->toArray(),
                $request->getFiles()->toArray()
            );
            
            // Pass data to form.
            $form->setData($data);
            
            // Execute file validators.
            if($form->isValid()) {
                
                // Execute file filters.
                $data = $form->getData();
                
                // Redirect the user to another page.
                return $this->redirect()->toRoute('application', ['action'=>'index']);
            }                        
        } 
        
        // Render the page.
        return new ViewModel([
                 'form' => $form
            ]);
    }
}
~~~

Wie Sie aus dem obigen Code sehen können, sieht die Methode `uploadAction()` aus, wie eine gewöhnliche Controller-Aktion.
Sie implementiert einen typischen Formular-Ablauf. Doch die Methode weist einige Aspekte auf, die für das Hochladen von Dateien spezifisch sind (markiert
mit **fett**):

  * In Zeile 9 erstellen wir eine Instanz des Formularmodells `YourForm` mithilfe des Operators `new`.

  * In Zeile 12 prüfen wir, ob es sich bei dem Request, um einen HTTP-POST-Request handelt. **Wenn ja, bekommen wir die Daten von `$ _POST`
    und `$ _FILES` aus den super-globale PHP-Arrays und fassen sie zu einem einzigen Array zusammen (Zeilen 15-19). Das ist
    erforderlich, um hochgeladene Dateien korrekt zu behandeln. Dann übergeben wir dieses Array mit
    der Methode `setData()` an das Formularmodell (Zeile 22)**.

  * In Zeile 25 rufen wir die `isValid ()` - Methode des Formularmodells auf. Diese Methode führt den Eingabefilter des
    Formularmodell aus. Bei @`FileInput` werden **nur die registrierten Validatoren ausgeführt**.

  * Wenn die Daten gültig sind, rufen wir die Methode `getData()` (Zeile 28) auf. Für @`FileInput` gilt, dass
    **die angehängten Dateifilter ausgeführt werden**. Die Dateifilter könnten beispielsweise die hochgeladenen Dateien
	in das gewüschte Verzeichnis verschieben.

  * Bei Erfolg leiten wir den Benutzer in Zeile 31 zur Aktion "index" des Controllers um.
  
I> In der Controller-Aktion oben sollten Sie drei Dinge beachten: 1) Die super-global Arrays werden `$ _POST` und `$ _FILES` 
I> zusammengeführen, bevor Sie sie an die Methode `setData()` des Formulars übergeben werden; 2) Verwenden Sie die Methode `isValid()`
I> zum prüfen der hochzuladenen Dateien auf Korrektheit (Validatoren ausführen); 3) Verwenden Sie die Methode `getData()` zum Ausführen
I> der Filterung der Dateien.
  
## Beispiel: Bildergalerie

Um die Verwendung von Datei-Uploads in Zend Framework 3 zu demonstrieren, erstellen wir eine Bildergalerie.
Diese besteht aus zwei Webseiten: der Seite zum Hochladen von Bildern. Über diese kann ein Bild hochgeladen werden (Abbildung 10.2).
Die zweite Seite zeigt die Galerie mit einer Liste der hochgeladenen Bilder (Abbildung 10.3).

T> Sie können das funktionierende Beispiel *Image Gallery* in der Beispielanwendung *Form Demo* ansehen,
T> welches diesem Buch beiliegt.

{width=80%}
![Abbildung 10.2. Seite Bild-Upload](images/uploads/upload_image_form.png)

{width=80%}
![Abbildung 10.3. Seite Bildergalerie](images/uploads/image_gallery.png)

Für dieses Beispiel erstellen wir folgenden Dinge:
  
  * Das Formularmodell `ImageForm`, das Bilddateien hochladen kann;
  * Die Service-Klasse `ImageManager` zum Abrufen der Liste der hochgeladenen Bilder, Abrufen von Informationen zu einem Bild und Ändern der Bildgröße.
  * Die Klasse `ImageController`, die Aktionsmethoden für die Webseiten enthält;
  * Die Factory `ImageControllerFactory`, die den Controller instanziiert und Abhängigkeiten einfügt;
  * ein View-Template (.phtml) für jede Aktionsmethode des Controllers.

### Modell ImageForm hinzufügen

Für dieses Beispiel benötigen wir ein Formularmodell, das für das Hochladen von Bilddateien verwendet wird. Wir werden
diese Formmodellklasse `ImageForm` nennen. Diese Klasse ermöglicht es uns, eine Bilddatei an den Server hochzuladen.
Das Formular enthält die folgenden Felder:

  * Im Feld `file` kann der Benutzer eine Bilddatei zum Hochladen auswählen.
    
  * und das Feld `submit`, um die Formulardaten an den Server zu senden.

Der Code des Formularmodells `ImageForm` ist unten dargestellt. Die Datei *ImageForm.php* sollte im
Verzeichnis *Form* im Quellverzeichnis des Moduls gespeichert sein:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;

// This form is used for uploading an image file.
class ImageForm extends Form
{
    // Constructor.     
    public function __construct()
    {
        // Define form name.
        parent::__construct('image-form');
     
        // Set POST method for this form.
        $this->setAttribute('method', 'post');
                
        // Set binary content encoding.
        $this->setAttribute('enctype', 'multipart/form-data');
				
        $this->addElements();        
    }
    
    // This method adds elements to form.
    protected function addElements() 
    {
        // Add "file" field.
        $this->add([
            'type'  => 'file',
            'name' => 'file',
            'attributes' => [                
                'id' => 'file'
            ],
            'options' => [
                'label' => 'Image file',
            ],
        ]);        
          
        // Add the submit button.
        $this->add([
            'type'  => 'submit',
            'name' => 'submit',
            'attributes' => [                
                'value' => 'Upload',
                'id' => 'submitbutton',
            ],
        ]);               
    }
}
~~~

Wir haben bereits die Erstellung des Formularmodells besprochen und der obige Code sollte keine Problem sein
ihn zu vertsehen. Wir möchten nur die Aufmerksamkeit des Lesers darauf lenken, dass wir in Zeile 19
den Wert "multipart/form-data" für das Attribut "enctype" des Formulars setzen, damit das Formular binär verwendet wird
die Daten korrekt kodiert.

T> Das explizite Setzen des Attributs "enctype" im Konstruktor ist optional, weil
T> @`Zend\Form\Element\File` das automatisch ausführt, wenn Sie die Methode `prepare() `des Formulars.

### Validierungsregeln dem Model ImageForm hinzufügen

Um die Verwendung von Validatoren und Filtern zu demonstrieren, die für das Arbeiten mit Datei-Uploads entwickelt wurden,
fügen wir diese der Formularklasse `ImageForm` hinzu. Wir wollen folgende Ziele erreichen:

 * Prüfen, ob die hochgeladene Datei wirklich über die HTTP-POST-Methode wurde. Dafür verwenden wir den Validator @`UploadFile`.
 * Vergewissern wir uns, dass es sich bei der hochgeladenen Datei um ein Bilddatei (JPEG, PNG, GIF usw.) handelt, indem wir den Validator @`IsImage` verwenden.
 * Prüfen, ob sich die Bildabmessungen innerhalb der zulässigen Grenzen befinden. Wir machen das mit dem Validator @`ImageSize`.
 * Wir verschieben die hochgeladene Datei mit dem Filter @`RenameUpload` in das gewünschte Verzeichnis.
 
Um Regeln zur Formularüberprüfung hinzuzufügen, ändern Sie den Code der Klasse `ImageForm` wie folgt:
 
{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;

use Zend\InputFilter\InputFilter;

// This form is used for uploading an image file.
class ImageForm extends Form
{
    // Constructor
    public function __construct()
    {
        // ...
	
        // Add validation rules
        $this->addInputFilter();          
    }
  
    // ...
	
    // This method creates input filter (used for form filtering/validation).
    private function addInputFilter() 
    {
        $inputFilter = new InputFilter();   
        $this->setInputFilter($inputFilter);
     
        // Add validation rules for the "file" field.	 
        $inputFilter->add([
                'type'     => 'Zend\InputFilter\FileInput',
                'name'     => 'file',
                'required' => true,   
                'validators' => [
                    ['name'    => 'FileUploadFile'],
                    [
                        'name'    => 'FileMimeType',                        
                        'options' => [                            
                            'mimeType'  => ['image/jpeg', 'image/png']
                        ]
                    ],
                    ['name'    => 'FileIsImage'],
                    [
                        'name'    => 'FileImageSize',
                        'options' => [
                            'minWidth'  => 128,
                            'minHeight' => 128,
                            'maxWidth'  => 4096,
                            'maxHeight' => 4096
                        ]
                    ],
                ],
                'filters'  => [                    
                    [
                        'name' => 'FileRenameUpload',
                        'options' => [  
                            'target' => './data/upload',
                            'useUploadName' => true,
                            'useUploadExtension' => true,
                            'overwrite' => true,
                            'randomize' => false
                        ]
                    ]
                ],   
            ]);                
    }
}
~~~

Im obigen Code fügen wir die folgenden Datei-Validatoren hinzu:

  * Validator @`UploadFile` (Zeile 32) prüft, ob die hochgeladene Datei wirklich über
    die HTTP-POST-Methode hochgeladen wurde.

  * Validator @`MimeType` (Zeile 34) prüft, ob es sich bei der hochgeladenen Datei um ein JPEG-oder PNG-Bild handelt.
    Dazu werden MIME-Informationen aus den Dateidaten gelesen.
    
  * Validator @`IsImage` (Zeile 39) prüft, ob es sich bei der hochgeladenen Datei um eine Bilddatei (PNG, JPG,
    usw.) handelt. Dazu werden MIME-Informationen aus den Dateidaten gelesen.

  * Validator @`ImageSize` (Zeile 41) ermöglicht die Überprüfung, ob die Bildabmessungen in einem zulässigen Bereich liegen.
    Im obigen Code überprüfen wir, ob das Bild zwischen 128 und 4096 Pixel breit ist und
    die Bildhöhe zwischen 128 Pixel und 4096 Pixel liegt.

In Zeile 52 fügen wir den Filter @`RenameUpload` hinzu und konfigurieren ihn so, um die hochgeladene Datei
im Verzeichnis *APP_DIR/data/upload* zu speichern. Der Filter verwendet denselben Dateinamen für die Zieldatei
wie der Name der Originaldatei lautet (Option `useUploadName`). Wenn eine Datei bereits mit solchen einen Namen
vorhanden ist, wird der Filter sie überschreiben (Option `overwrite`).
     
W> Damit die Validatoren @`MimeType` und @`IsImage` funktionieren, müssen Sie die PHP-Erweiterung `fileinfo` aktivieren. Diese Erweiterung
W> ist bereits in Linux Ubuntu aktiviert, jedoch nicht in Windows. Vergessen Sie nicht, den Apache-HTTP-Server neu zu starten.

### ImageManager Service schreiben

--------------
HIER WEITER
--------------

Da wir uns bemühen, Code zu schreiben, der dem Muster "Domain Driven Design" entspricht. Wir
erstellen Sie eine Service Model-Klasse, die die Funktionalität für das Image-Management enthält. Wir 
nennen diese Klasse `ImageManager` und erstellen sie im Namensraum `Application\Service`. Wir werden
diesen Dienst in der Komponente Service-Manager der Webanwendung registrieren.

Die Serviceklasse `ImageManager` verfügt über die folgenden öffentlichen Methoden (in Tabelle 10.3 aufgeführt):

{title="Tabelle 10.3. Öffentliche Methoden der Klasse ImageManager."}
|-------------------------------------------|---------------------------------------------------------------------------|
| *Methode* 								| *Beschreibung* 															|
|-------------------------------------------|---------------------------------------------------------------------------|
| `getSaveToDir()` 							| Gibt den Pfad zum Verzeichnis zurück, in dem die Bilddateien				|
|											| gespeichert werden. 														|
|-------------------------------------------|---------------------------------------------------------------------------|
| `getSavedFiles()` 						| Gibt das Array der gespeicherten Dateinamen zurück. 						|
|-------------------------------------------|---------------------------------------------------------------------------|
| `getImagePathByName($fileName)` 			| Gibt den Pfad zur gespeicherten Bilddatei zurück. 						|
|-------------------------------------------|---------------------------------------------------------------------------|
| `getImageFileInfo($filePath)` 			| Gibt die Dateiinformationen (Größe, MIME-Typ) über den Bildpfad zurück. 	|
|-------------------------------------------|---------------------------------------------------------------------------|
| `getImageFileContent($filePath)` 			| Gibt den Inhalt der Bilddatei zurück. Bei einem Fehler wird boolean		|
|											| `false` zurückgegeben. 													|
|-------------------------------------------|---------------------------------------------------------------------------|
| `resizeImage($filePath, $desiredWidth)`	| Ändert die Größe des Bildes unter Beibehaltung der Seitenverhältnisse.	|
|-------------------------------------------|---------------------------------------------------------------------------|

T> Tatsächlich könnten wir den Code, den wir dem Service hinzufügen möchten, in die Controller-Aktionen einfügen, aber das
T> würde den Controller fett und schlecht prüfbar machen. Durch die Einführung der Serviceklasse verbessert die
T> Trennung von Logik und Wiederverwendbarkeit unseres Codes.

Erstellen Sie die Datei *ImageManager.php* im Verzeichnis *Service* unter
Quellverzeichnis des Moduls. Fügen Sie der Datei den folgenden Code hinzu:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Service;

// The image manager service.
class ImageManager 
{
    // The directory where we save image files.
    private $saveToDir = './data/upload/';
        
    // Returns path to the directory where we save the image files.
    public function getSaveToDir() 
    {
        return $this->saveToDir;
    }  
}
~~~

Wie Sie dem obigen Code entnehmen können, definieren wir in Zeile 5 die Klasse `ImageManager`. Sie hat die private Klassenvariable
`$saveToDir` [^property], die den Pfad zum Verzeichnis enthält, in dem sich unsere hochgeladenen Dateien befinden
(Zeile 8) (wir speichern hochgeladene Dateien im Verzeichnis *APP_DIR/data/upload*).

Die öffentliche Methode `getSaveToDir()` (Zeile 11) ermöglicht das Abrufen des Pfads zum Upload-Verzeichnis.

[^property]: Obwohl die Klasse `ImageManager` ein Dienst ist und sich auf die Bereitstellung von Diensten konzentriert,
             kann sie Klassenvariablen haben, die für den internen Gebrauch bestimmt sind.

Als Nächstes möchten wir die öffentliche Methode `getSavedFiles()` zur Serviceklasse hinzufügen. Die Methode durchsucht
das Upload-Verzeichnis und gibt ein Array zurück, das die Namen der hochgeladenen Dateien enthält. Um die
Methode`getSavedFiles()` hinzufügen, ändern Sie den Code auf folgende Weise:
             
{line-numbers=on, lang=php}
~~~
<?php
//...

// The image manager service.
class ImageManager 
{
    //...
  
    // Returns the array of uploaded file names.
    public function getSavedFiles() 
    {
        // The directory where we plan to save uploaded files.
        
        // Check whether the directory already exists, and if not,
        // create the directory.
        if(!is_dir($this->saveToDir)) {
            if(!mkdir($this->saveToDir)) {
                throw new \Exception('Could not create directory for uploads: ' . 
                             error_get_last());
            }
        }
        
        // Scan the directory and create the list of uploaded files.
        $files = [];        
        $handle  = opendir($this->saveToDir);
        while (false !== ($entry = readdir($handle))) {
            
            if($entry=='.' || $entry=='..')
                continue; // Skip current dir and parent dir.
            
            $files[] = $entry;
        }
        
        // Return the list of uploaded files.
        return $files;
    }  
}
~~~ 

In der Methode `getSavedFiles()` überprüfen wir zuerst, ob das Upload-Verzeichnis existiert (Zeile 16). Falls es nicht,
exisitiert versuchen wir es zu erstellen (Zeile 17). Dann erstellen wir eine Liste der Dateien im Verzeichnis (Zeilen 24-32) und
geben diese zurück.

Als Nächstes fügen wir die drei Methoden hinzu, um Informationen zu einer hochgeladenen Datei zu erhalten:
 
  * Der Methode `getImagePathByName()` wird der Dateinamen übergeben und sie stellt den Pfad zum Uploadverzeichnis
    den Dateinamen voran;
    
  * Die Methode `getImageFileInfo()` ruft die MIME-Informationen über die Datei und ihre Größe in Byte ab.
  
  * und `getImageFileContent()` liest die Dateiinhalte und gibt diese als String zurück.
  
Um diese drei Methoden hinzuzufügen, ändern Sie den Code wie folgt:

{line-numbers=on, lang=php}
~~~
<?php
//...

// The image manager service.
class ImageManager 
{
    //...  
  
    // Returns the path to the saved image file.
    public function getImagePathByName($fileName) 
    {
        // Take some precautions to make file name secure.
        $fileName = str_replace("/", "", $fileName);  // Remove slashes.
        $fileName = str_replace("\\", "", $fileName); // Remove back-slashes.
                
        // Return concatenated directory name and file name.
        return $this->saveToDir . $fileName;                
    }
  
    // Returns the image file content. On error, returns boolean false. 
    public function getImageFileContent($filePath) 
    {
        return file_get_contents($filePath);
    }
    
    // Retrieves the file information (size, MIME type) by image path.
    public function getImageFileInfo($filePath) 
    {
        // Try to open file        
        if (!is_readable($filePath)) {            
            return false;
        }
            
        // Get file size in bytes.
        $fileSize = filesize($filePath);

        // Get MIME type of the file.
        $finfo = finfo_open(FILEINFO_MIME);
        $mimeType = finfo_file($finfo, $filePath);
        if($mimeType===false)
            $mimeType = 'application/octet-stream';
    
        return [
            'size' => $fileSize,
            'type' => $mimeType 
        ];
    }  
}
~~~
             
Schließlich möchten wir die Methode zur Änderung der Bildgröße der Klasse `ImageManager` hinzufügen. Die Methode zum
Ändern der Bildgröße wird zum Erstellen kleiner Miniaturbilder (Thumbnails) verwendet. Fügen Sie der Methode `resizeImage()`
der Klasse `ImageManager` folgendes  hinzu:

{line-numbers=on, lang=php}
~~~
<?php
//...
class ImageManager 
{
    //...    
  
    // Resizes the image, keeping its aspect ratio.
    public  function resizeImage($filePath, $desiredWidth = 240) 
    {
        // Get original image dimensions.
        list($originalWidth, $originalHeight) = getimagesize($filePath);

        // Calculate aspect ratio
        $aspectRatio = $originalWidth/$originalHeight;
        // Calculate the resulting height
        $desiredHeight = $desiredWidth/$aspectRatio;

        // Get image info
        $fileInfo = $this->getImageFileInfo($filePath); 
        
        // Resize the image
        $resultingImage = imagecreatetruecolor($desiredWidth, $desiredHeight);
        if (substr($fileInfo['type'], 0, 9) =='image/png')
            $originalImage = imagecreatefrompng($filePath);
        else
            $originalImage = imagecreatefromjpeg($filePath);
        imagecopyresampled($resultingImage, $originalImage, 0, 0, 0, 0, 
            $desiredWidth, $desiredHeight, $originalWidth, $originalHeight);

        // Save the resized image to temporary location
        $tmpFileName = tempnam("/tmp", "FOO");
        imagejpeg($resultingImage, $tmpFileName, 80);
        
        // Return the path to resulting image.
        return $tmpFileName;
    }
}
~~~

Die obige Methode `resizeImage()` benötigt zwei Argumente: `$filePath` (der Pfad zur Bilddatei)
und `$desiredWidth` (die Breite des Miniaturbildes). Innerhalb der Methode berechnen wir zuerst
eine geeignete Miniaturbildhöhe (Zeilen 11-16), wobei das Seitenverhältnis beibehalten wird. Dann ändern wir die Größe
des Originalbildes nach Bedarf und speichern es in eine temporären Datei (Zeilen 19-32).

Da die Klasse `ImageManager' ist fertig. Nun müssen Sie den Service `ImageManager` als Service
der Manager-Komponente Ihrer Webanwendung registrieren. Dies tun Sie, indem Sie der Konfigurationsdatei *module.config.php* 
die folgenden Zeilen hinzufügen:

{line-numbers=off, lang=php}
~~~
<?php
return [
    // ...    
    'service_manager' => [
        // ...
        'factories' => [
            // Register the ImageManager service
            Service\ImageManager::class => InvokableFactory::class,            
        ],
    ],    
    // ...
];
~~~

### ImageController hinzufügen

Für das Beispiel *Bildergallerie* erstellen wir die Controller-Klasse `ImageController`. Der Controller
verfügt über die folgenden Aktionsmethoden (in Tabelle 10.4 aufgeführt):

{title="Tabelle 10.4. Aktionsmethoden der Klasse ImageController."}
|-------------------|---------------------------------------------------------------------------------------|
| *Aktionsmethode* 	| *Beschreibung* 																		|
|-------------------|---------------------------------------------------------------------------------------|
| `__construct()` 	| Erlaubt das Einfügen der Abhängigkeit `ImageManager` in den Controller. 				|
|-------------------|---------------------------------------------------------------------------------------|
| `uploadAction()`	| Zeigt die Bild-Upload-Seite an, über die ein einzelnes Bild hochgeladen werden kann. 	|
|-------------------|---------------------------------------------------------------------------------------|
| `indexAction()` 	| Zeigt die Bildergalerie mit der Liste der hochgeladenen Bilder an. 					|
|-------------------|---------------------------------------------------------------------------------------|
| `fileAction()` 	| Bietet die Möglichkeit, ein Bild in voller Größe oder ein kleines Miniaturbild für	|
|					| ein Bild herunterzuladen. 															|
|-------------------|---------------------------------------------------------------------------------------|

Erstellen Sie als erstes die Datei *ImageController.php* im Verzeichnis *Application/Controller* im
Quellverzeichnis des Moduls. Fügen Sie den folgenden Code in die Datei ein:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Application\Form\ImageForm;

// This controller is designed for managing image file uploads.
class ImageController extends AbstractActionController 
{
    // The image manager.
    private $imageManager;
  
    // The constructor method is used for injecting the dependencies 
    // into the controller.
    public function __construct($imageManager)
    {
        $this->imageManager = $imageManager;
    }
  
    // This is the default "index" action of the controller. It displays the 
    // Image Gallery page which contains the list of uploaded images.
    public function indexAction() 
    {                
    }
    
    // This action shows the image upload form. This page allows to upload 
    // a single file.
    public function uploadAction() 
    {
    }
    
    // This is the 'file' action that is invoked when a user wants to 
    // open the image file in a web browser or generate a thumbnail.     
    public function fileAction() 
    {        
    }    
}
~~~

Im obigen Code haben wir die Klasse `ImageController` definiert, die sich im Namensraum `Application\Controller` befindet.
Wir haben der Klasse die Konstruktormethode und drei Aktionsmethoden hinzugefügt: `indexAction()`,
`uploadAction()` und `fileAction()`. Als Nächstes füllen wir diese Aktionsmethoden mit dem Code.

#### Upload-Aktion und entsprechende View-Templates hinzufügen

Zuerst nehmen wir uns die Methode `uploadAction()` unseres Controllers vor. Diese Aktionsmethode ist zuständig für die Seite
*Laden Sie ein neues Bild hoch*, welches das Formular zum Hochladen enthält. Das Formular bietet die Möglichkeit, eine
Bilddatei in die Galerie hochzuladen.

Ändern Sie die Datei *ImageController.php* wie folgt:

{line-numbers=on, lang=php}
~~~
<?php
//...
class ImageController extends AbstractActionController 
{
    //...
    public function uploadAction() 
    {
        // Create the form model.
        $form = new ImageForm();
        
        // Check if user has submitted the form.
        if($this->getRequest()->isPost()) {
            
            // Make certain to merge the files info!
            $request = $this->getRequest();
            $data = array_merge_recursive(
                $request->getPost()->toArray(),
                $request->getFiles()->toArray()
            );
            
            // Pass data to form.
            $form->setData($data);
                
            // Validate form.
            if($form->isValid()) {
                    
                // Move uploaded file to its destination directory.
                $data = $form->getData();
                    
                // Redirect the user to "Image Gallery" page.
                return $this->redirect()->toRoute('images');
            }                        
        } 
        
        // Render the page.
        return new ViewModel([
                     'form' => $form
                 ]);
    }
}
~~~

In der Methode `uploadAction()` führen wir Folgendes aus.

In Zeile 9 erstellen wir eine Instanz des Formularmodells `ImageForm` mit Hilfe des Operators` new`.

In Zeile 12 prüfen wir, ob es sich bei dem Request um einen HTTP-POST-Request handelt. Wenn ja, erhalten wir die Daten von den super-globalen
PHP-Arrays `$ _POST` und `$ _FILES` und fassen sie zu einem einzigen Array zusammen (Zeilen 15-19). Das ist
erforderlich, um hochgeladene Dateien korrekt zu behandeln. Dann übergeben wir dieses Array dem Formularmodell
durch die Methode `setData()` (Zeile 22).

In Zeile 25 rufen wir die Methode `isValid()` des Formularmodells auf. Diese Methode führt den Eingabefilter aus, der an das Formularmodell angehängt ist.
Wir haben nur eine Dateieingabe im Eingabefilter, diese führt nun unsere drei Datei-Validatoren aus:
@`UploadFile`, @`IsImage` und @ `ImageSize`.

Wenn die Daten gültig sind, rufen wir die Methode `getData()` (Zeile 28) auf. Für unser Dateifeld wird der
Filter @`RenameUpload` ausgeführt, welcher unsere hochgeladene Datei in das gewünschte Verzeichnis verschiebt.

In Zeile 31 leiten wir den Benutzer auf die Aktion "index" des Controllers um (wir werden später
diese Aktionsmethode mit Daten füllen).

Nun ist es an der Zeit, das View-Template für die Aktion "upload" hinzuzufügen. Erstellen Sie das View-Template *upload.phtml*
im Verzeichnis *application/image* im Verzeichnis *view* des Moduls:

{line-numbers=on, lang=php}
~~~
<?php
$form = $this->form;
$form->get('submit')->setAttributes(['class'=>'btn btn-primary']);
$form->prepare();
?>

<h1>Upload a New Image</h1>

<p>
    Please fill out the following form and press the <i>Upload</i> button.
</p>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('file')); ?>
            <?= $this->formElement($form->get('file')); ?>
            <?= $this->formElementErrors($form->get('file')); ?> 
            <div class="hint">(PNG and JPG formats are allowed)</div>
        </div>
                
        <?= $this->formElement($form->get('submit')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>    
~~~

Im Code des View-Templates setzen wir zunächst das Attribut "class" (Zeile 3). Dies wird verwendet,
um den Twitter-Bootstrap-Stile auf den Button *Submit* des Formulars anzuwenden.

Dann rendern wir das Formular mit den allgemeinen View-Helpern, die wir in [Sammeln von Benutzereingaben mit Formularen](#forms) besprochen haben.
Für das Rendern des Feldes "file" verwenden wir den übergordneten ViewHelper @`FormElement`.

I> Normalerweise verwenden Sie den übergordneten View-Helfer @`FormElement`, um das Dateifeld zu rendern.
I> Das @`FormElement` ruft intern den ViewHelder @`FormFile` auf, der das eigentliche
I> Rendering ausführt.

#### Index-Aktion & entsprechendes View-Template hinzufügen

Die zweite Aktionsmethode, die wir abschließen werden, ist die Methode `indexAction()`. Diese Aktion beinhaltet die
Seite unserer *Bildergalerie* mit einer Liste der hochgeladenen Dateien und ihren kleinen Miniaturansichten. Für jedes
Bild wird ein Buttom "In natürlicher Größe anzeigen" angezeigt, um das Bilde auf einer anderen Registerkarte des Web-Browsers
in Orginalgröße anzuzeigen.

Ändern Sie die Datei *ImageController.php* wie folgt:

{line-numbers=on, lang=php}
~~~
<?php
//...
class ImageController extends AbstractActionController 
{
    //...
    public function indexAction() 
    {
        // Get the list of already saved files.
        $files = $this->imageManager->getSavedFiles();
        
        // Render the view template.
        return new ViewModel([
            'files'=>$files
        ]);
    }
}
~~~

Im obigen Code verwenden wir zum Abrufen die Methode `getSavedFiles()` der Klasse `ImageManager`.
Sie gibt uns eine Liste der hochgeladenen Bilder zurück und wir übergeben sie zum Rendern an die View.

T> Bitte beachten Sie, wie "schlank" und einfach diese Controller-Aktion ist! Dieses haben wir erreicht, indem wir die
T> Bildverwaltungsfunktion in das Servicemodell `ImageManager` ausgelagert haben.

Erstellen Sie das View-Template *index.phtml* im Verzeichnis *application/image* im Verzeichnis *view* 
des Moduls. Der Inhalt der Datei wird unten gezeigt:

{line-numbers=on, lang=php}
~~~
<h1>Image Gallery</h1>

<p>
  This page displays the list of uploaded images.
</p>

<p>
  <a href="<?= $this->url('images', ['action'=>'upload']); ?>" 
     class="btn btn-primary" role="button">Upload More</a>
</p>

<hr/>

<?php if(count($files)==0): ?>

<p>
  <i>Es gibt keine Dateien zum Anzeigen</i>
</p>

<?php else: ?>

<div class="row">
  <div class="col-sm-6 col-md-12">

    <?php foreach($files as $file): ?>  

    <div class="img-thumbnail">
            
      <img src="<?= $this->url('images', ['action'=>'file'], 
            ['query'=>['name'=>$file, 'thumbnail'=>true]]); ?>">
            
      <div class="caption">
        <h3><?php echo $file; ?></h3>                    
        <p>
        <a target="_blank" href="<?= $this->url('images', ['action'=>'file'], 
           ['query'=>['name'=>$file]]); ?>" 
           class="btn btn-default" role="button">In natürlicher Größe anzeigen</a>
        </p>
      </div>
    </div>

    <?php endforeach; ?>
  </div>
</div>

<?php endif; ?>

<hr/>
~~~

Im obigen Code erstellen wir das HTML-Markup für den Button *Upload More*.

Unter dem Button wird überprüft, ob das Array `$files` leer ist. Wenn das Array leer ist,
geben wir die Meldung "Es gibt keine Dateien zum Anzeigen" aus. Ansonsten gehen wir die Dateien durch und geben
die Miniaturen der hochgeladenen Bilder aus.

Für das Rendern einer Miniaturansicht verwenden wir das Tag <img>. Für das Attribut `src` setzen wir die URL
zur Aktion "file" unseres Controllers `ImageController`. Wir übergeben der Aktion zwei Parameter über
den Query-String der URL: Den Bildname und das Thumbnail-Flag.

Um die Miniaturen zu gestalten, verwenden wir die von Twitter Bootstrap bereitgestellte CSS-Klasse ".img-thumbnail".

T> Weitere Informationen zu diesen Twitter-Bootstrap-Styles finden Sie in der
T> Offizielle Dokumentation von Bootstrap.

Unter jeder Miniaturansicht wird der Link "In natürlicher Größe anzeigen" angezeigt, der auf die Aktion "file"
unseres Controllers `ImageController` verweist. Wenn der Besucher auf den Link klickt, wird ihm das
Bild in natürlicher Größe angezeigt. Das Bild wird in einer neuen Registerkarte des Browsers geöffnet (beachten Sie das
Attribut des Links `target =" _ blank "`).

#### Dateiaktion hinzufügen

Als letzte Aktion füllen wir die Methode `ImageController::fileAction ()` mit Code. Diese Methode wird die
Vorschau eines hochgeladenen Bildes zulassen oder ein kleines Miniaturbild des Bildes anzeigen. Die Aktionsmethode
benötigt zwei GET-Parameter:
 
  * Der Parameter "name" definiert den Dateinamen für die Vorschau.
  * Der Parameter "thumbnail" gibt an, ob das Orgianl oder ein kleines Bild gesichert angezeigt
    werden soll.

Ändern Sie die Datei *ImageController.php* wie folgt:

{line-numbers=on, lang=php}
~~~
 <?php
//...
class ImageController extends AbstractActionController 
{
    //...
    public function fileAction() 
    {
        // Get the file name from GET variable.
        $fileName = $this->params()->fromQuery('name', '');

        // Check whether the user needs a thumbnail or a full-size image.
        $isThumbnail = (bool)$this->params()->fromQuery('thumbnail', false);
    
        // Get path to image file.
        $fileName = $this->imageManager->getImagePathByName($fileName);
        
        if($isThumbnail) {
        
            // Resize the image.
            $fileName = $this->imageManager->resizeImage($fileName);
        }
                
        // Get image file info (size and MIME type).
        $fileInfo = $this->imageManager->getImageFileInfo($fileName);        
        if ($fileInfo===false) {
            // Set 404 Not Found status code
            $this->getResponse()->setStatusCode(404);            
            return;
        }
                
        // Write HTTP headers.
        $response = $this->getResponse();
        $headers = $response->getHeaders();
        $headers->addHeaderLine("Content-type: " . $fileInfo['type']);        
        $headers->addHeaderLine("Content-length: " . $fileInfo['size']);
            
        // Write file content.
        $fileContent = $this->imageManager->getImageFileContent($fileName);
        if($fileContent!==false) {                
            $response->setContent($fileContent);
        } else {        
            // Set 500 Server Error status code.
            $this->getResponse()->setStatusCode(500);
            return;
        }
        
        if($isThumbnail) {
            // Remove temporary thumbnail image file.
            unlink($fileName);
        }
        
        // Return Response to avoid default view rendering.
        return $this->getResponse();
    }    
}
~~~

Im obigen Code erhalten wir zuerst die Parameter "name" und "thumbnail" aus dem super-globalen Array `$ _GET`
(Zeilen 9, 12). Wenn die Parameter fehlen, werden stattdessen die Standardwerte verwendet.

In Zeile 15 verwenden wir die Methode `getImagePathByName()`, die vom Service `ImageManager` bereitgestellt wird,
um den absoluten Pfad zum Bild anhand seines Namens zu erhalten.

Wenn eine Miniaturansicht angefordert wird, ändern wir die Größe des Bildes mit der Methode `resizeImage()` des
`ImageManager` (Zeile 20). Diese Methode gibt den Pfad zu einer temporären Datei zurück, die das Miniaturbild enthält.

Dann erhalten wir die Informationen über die Image-Datei (deren MIME-Typ und Dateigröße) mit der Methode
`getImageFileInfo()` des `ImageManager` (Zeile 24).

Schließlich erstellen wir ein Objekt @`Response`[Zend\Http\PhpEnvironment\Response] und füllen die Headers mit unseren Bildinformationen.
Dann setzen wir den Inhalt mit den Daten der Bilddatei (Zeilen 32-45) und geben das Objekt @`Response`[Zend\Http\PhpEnvironment\Response] vom Controller zurück
Aktion (Zeile 53).

I> Beachten Sie, dass die Rückgabe des Objekts @`Response`[Zend\Http\PhpEnvironment\Response] das Standard-Rendering von View-Templates
I> für diese Aktionsmethode deaktiviert. Aus diesem Grund erstellen wir kein View-Template *file.phtml*.

#### Factory für den Controller erstellen

Da unser `ImageController` den Service `ImageManager` verwendet, müssen wir ihm irgendwie die Instanz des
`ImageManager` übergeben (um die Abhängigkeit dem Konstruktor zu übergeben). Wir machen das mit der Hilfe
einer *Factory*.

Erstellen Sie die Datei `ImageControllerFactory.php` im Unterverzeichnis *Controller/Factory* des Quelleverzeichnisses des 
Modulss. Fügen Sie den folgenden Code in die Datei ein:

{line-numbers=off, lang=php}
~~~
<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\ImageManager;
use Application\Controller\ImageController;

/**
 * This is the factory for ImageController. Its purpose is to instantiate the
 * controller.
 */
class ImageControllerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                        $requestedName, array $options = null)
    {
        $imageManager = $container->get(ImageManager::class);
        
        // Instantiate the controller and inject dependencies
        return new ImageController($imageManager);
    }
}
~~~

#### Registrieren des ImageControllers

Damit ZF3 unseren Controller kennt, registrieren wir den `ImageController` in der Konfigurationsdatei *module.config.php*:

{line-numbers=off, lang=php}
~~~
<?php
return [
    //...
    'controllers' => [
        'factories' => [
            Controller\ImageController::class => 
                    Controller\Factory\ImageControllerFactory::class,
            //...
        ],
    ],    
    //...
];
~~~

#### Route erstellen

Wir müssen noch eine *Route* für unseren Controller `ImageController` hinzufügen. Ändern Sie dazu die Datei `module.config.php`
wie folgt:

{line-numbers=off, lang=php}
~~~
<?php
return [
    //...
    'router' => [
        'routes' => [
            'images' => [
                'type'    => Segment::class,
                'options' => [
                    'route'    => '/images[/:action]',
                    'constraints' => [
                        'action' => '[a-zA-Z][a-zA-Z0-9_-]*'
                    ],
                    'defaults' => [
                        'controller'    => Controller\ImageController::class,
                        'action'        => 'index',
                    ],
                ],
            ],
        ],
    ],    
    //...
];
~~~

Danach können wir über die URL wie "http://localhost/images" auf unsere Bildergalerie zugreifen.
"http://localhost/images/upload" oder "http://localhost/images/file".

### Ergebnisse

Passen Sie schließlich die Verzeichnisberechtigungen an, damit das Verzeichnis *APP_DIR/data* für den Apache-Webserver beschreibbar ist.
In Linux Ubuntu wird dies normalerweise durch die folgenden Shell-Befehle erreicht (ersetzen Sie den Paltzhalter `APP_DIR`
mit dem tatsächlichen Verzeichnisnamen Ihrer Webanwendung):

`chown -R www-data:www-data APP_DIR/data`

`chmod -R 775 APP_DIR/data`

Mit den Befehlen `chown` und `chmod` wird der Apache-Benutzer als Besitzer des Verzeichnisses festgelegt und es
wird dem Webserver erlaubt, in das Verzeichnis zu schreiben.

Wenn Sie jetzt die URL *http://localhost/images* in die Navigationsleiste Ihres Webbrowser
eingeben, sehen Sie die Bildergalerie wie in Abbildung 10.4 gezeigt.

{width=80%}
![Abbildung 10.4. Seite Bildergalerie](images/uploads/empty_image_gallery.png)

Durch Klicken auf den Button "Upload More" wird die Seite "Upload a New Image" geöffnet. Auf dieser Seite können Sie eine neue Bilddatei auswählen
und Hochladen. Wenn Sie eine inakzeptable Datei auswählen (kein Bild oder zu großes Bild), wird eine Fehlermeldung
angezeigt (siehe Abbildung 10.5 unten).

{width=80%}
![Abbildung 10.5. Fehlermeldung der Dateiüberprüfung](images/uploads/image_validation_errors.png)

Wenn das Hochladen der Datei erfolgreich abgeschlossen wurde, werden Sie zur Seite *Image Gallery* zurückgeleitet
und Sie sehen das hochgeladene Bild in der Liste der Miniaturbilder. Klicken Sie auf den Button *View Full Size*,
öffnet sich das Bild in einem neuen Browser-Tab (siehe Abbildung 10.6 unten).

{width=80%}
![Abbildung 10.6. Bild in natürlicher Größe öffnen](images/uploads/image_preview.png)

T> Das vollständige Beispiel für die *Bidlergalerie* finden Sie in der Beispiel-Webanwendung *Form Demo*,
T> welches dem Buch beiliegt.

## Zusammenfassung

Das Hochladen von Dateien ist eine Standardfunktion für HTML-Formulare. Das Hochladen von Dateien erfolgt durch das Festlegen
der Inhaltskodierung in binäre Kodierungsart des Formulars. Zend Framework 3 bietet komfortable Funktionen
zum Hochladen von Dateien und zum Überprüfen der hochgeladenen Dateien.

