# Erweiterte Verwendung von Formularen {#advanced-forms}

In den vorangegangenen Kapiteln haben Sie die Grundlagen zur Verwendung von Formularen kennen gelernt,
wie Sie Formularmodelle in Zend Framework 3 definieren und wie man sie anzeigt.
In diesem Kapitel erfahren Sie einige Themen zur erweiterten Verwendung der Formulare, z.B.
Formularelemente für die Sicherheit (CAPTCHA und CSRF), usw.

In diesem Kapitel werden folgende ZF3-Komponenten behandelte :

|-----------------------|-------------------------------------------------------|
| *Komponente* 			| *Beschreibung* 										|
|-----------------------|-------------------------------------------------------|
| @`Zend\Captcha` 		| Implementiert verschiedene CAPTCHA-Algorithmen. 		|
|-----------------------|-------------------------------------------------------|
| @`Zend\Form` 			| Enthält Basisformularmodellklassen. 					|
|-----------------------|-------------------------------------------------------|
| @`Zend\Filter` 		| Enthält verschiedene Filterklassen. 					|
|-----------------------|-------------------------------------------------------|
| @`Zend\Validator` 	| Implementiert verschiedene Validator-Klassen. 		|
|-----------------------|-------------------------------------------------------|
| @`Zend\InputFilter`	| Implementiert einen Container für Filter/Validatoren.	|
|-----------------------|-------------------------------------------------------|

## Sicherheitselemente für Formulare

Wir werden die Verwendung von zwei Formularsicherheitselementen kennenlernen, die uns von
Zend Framework 3 bereitgestellt werden: @`Captcha`[Zend\Form\Element\Captcha] und @`Csrf`[Zend\Form\Element\Csrf] (beide Klassen gehören
zum Namensraum @`Zend\Form\Element`[Zend\Form]). Wenn wir diese Elemente zu einem Formular-Model hinzufügen
(und das Rendern in einem View-Template) wird das Formular resistenter gegen Hackerangriffe.

### CAPTCHA

Ein CAPTCHA (steht für "Completely Automated Public Turing test to tell Computers and Humans Apart")
ist ein Frage-Antwort-Test und wird in Websites verwendet, um zu bestimmen, ob der Benutzer ein Mensch 
oder ein Roboter ist.

Es gibt verschiedene CAPTCHA-Typen. Der am häufigsten verwendete Typ erfordert vom
Benutzer eine Eingabe von Buchstaben aus einem verzerrten Bildes, welches auf der Webseite angezeigt wird (siehe
Abbildung 11.1 für einige Beispiele.

![Abbildung 11.1. Beispiele für CAPTCHA](images/forms_advanced/captcha_types.png)

Ein typischer CAPTCHA-Test funktioniert wie folgt:

1. Einige geheime Zeichenfolgen (Wörter) werden serverseitig generiert.
2. Das geheime Wort wird in einer PHP-Session-Variable gespeichert.
3. Das verzerrte Bild wird basierend auf dem geheimen Wort generiert.
   Das Bild wird dem Websitebenutzer dann auf der Webseite angezeigt.
4. Der Benutzer wird aufgefordert, die auf dem Bild angezeigten Zeichen einzugeben.
5. Wenn die vom Benutzer eingegebenen Zeichen dem geheimen Wort aus der PHP-Session
   entsprechen, gilt der Test als bestanden.

Ziel des CAPTCHA-Tests ist es, Ihr Formular vom automatischen Ausfüllen zu schützen.
Das kann durch einen automatisierten Prozess geschehen (sogenannter Roboter). Normalerweise
senden solche Roboter Spam-Nachrichten an Forens, hacken Passwörter eines Anmeldeformulares für Websites,
oder führen andere schädliche Aktionen aus.

I> Der CAPTCHA-Test erlaubt es, Menschen sicher von Robotern zu unterscheiden, weil
I> Menschen können ein verzerrtes Bild leicht erkennen und reproduzieren,
I> während Roboter dies nicht tun können (in der aktuellen Entwicklungsstufe von
I> Computer Vision Algorithmen).

#### CAPTCHA-Typen

In Zend Framework 3 stehen mehrere CAPTCHA-Typen zur Verfügung (alle gehören
zur Komponente @`Zend\Captcha`):

* *Dumb* Dies ist ein sehr einfacher CAPTCHA-Algorithmus, indem Benutzer die Wortbuchstaben
  in umgekehrter Reihenfolge eingeben müssen. Wir nicht näher auf diesen Typ eingehen,
  da dieser Typ einen zu niedrigen Schutz bietet.
 
 * *Image.* Ein CAPTCHA-Algorithmus, der ein Bild, mit einem Zusatz in Form von
   Punkten und Linienkurven, etwas verzerrt darstellt (Abbildung 11.1, a).
 
 * *Figlet.* Ein ungewöhnlicher CAPTCHA-Typ, der das FIGlet-Programm-Verzerrungsalgorithmus,
   anstelle eines Bildes verwendet. Das FIGlet ist ein Open-Source-Programm, dass ein
   CAPTCHA-Bild mit vielen kleinen ASCII-Buchstaben generiert (Abbildung 11.1, b).
 
Die Komponente @`Zend\Captcha` bietet eine einheitliche Schnittstelle für alle CAPTCHA-Typen
(die Schnittstelle @`AdapterInterface`[Zend\Captcha\AdapterInterface]). Die Basisklasse @`AbstractAdapter`[Zend\Captcha\AdapterInterface]
implementiert diese Schnittstelle und alle anderen CAPTCHA-Algorithmen werden von diesem abstrakten Adapter-Klasse [^adapter]
abgeleitet. Das Klassenvererbungsdiagramm ist unten in Abbildung 11.2 dargestellt.

![Abbildung 11.2. CAPTCHA-Adapterklassen](images/forms_advanced/captcha_adapters.png)

[^adapter]: Ein *Adapter* ist ein Entwurfsmuster, wenn existierende Klasse verwendet werden soll, deren Schnittstelle nicht 
			der benötigten Schnittstelle entspricht. Ein Adapter wird bei der Erstellung wiederverwendbarer Klassen benutzt, 
			wenn diese mit unabhängigen oder nichtvorhersehbaren Klassen zusammenarbeiten sollen.
            In der Regel haben CAPTCHA-Algorithmen unterschiedliche öffentliche Methoden.
            Da sie alle die Schnittstelle @`AbstractAdapter`[Zend\Captcha\AdapterInterface] implementieren, kann der Aufrufer einen beliebigen
            CAPTCHA-Algorithmus auf dieselbe Weise verwenden (durch Aufrufen der von der Basisschnittstelle bereitgestellten Methoden).

Wie Sie der Abbildung 11.2 entnehmen können, gibt es für alle CAPTCHA-Typen eine andere Basisklasse,
die ein geheimes Wort aus Zeichen verwenden: die Klasse @`AbstractWord`[Zend\Captcha\AbstractWord]. Diese
Basisklasse bietet Methoden zum Erzeugen einer zufälligen Zeichenfolge und zum Anpassen
der Wortgenerierung.

#### Formularelement CAPTCHA & View Helper

ZF3 stellt eine dedizierte Formularelementklasse und eine View-Helper-Klasse bereit, damit Sie CAPTCHA-Felder in Ihren Formularen verwenden können.

Um einem Formularmodell ein CAPTCHA-Feld hinzuzufügen, verwenden Sie die Klasse @`Captcha`[Zend\Form\Element\Captcha]
der Komponente @`Zend\Form`. Diese liegt im Namensraum @`Zend\Form\Element`[Zend\Form].

Die Elementklasse @`Captcha`[Zend\Form\Element\Captcha] kann mit jedem CAPTCHA-Algorithmus (im vorrigen Abschnitt
aufgelistet) von der Komponente @`Zend\Captcha` verwendet werden. Für diesen Zweck,
stellt Elementklasse die Methode `setCaptcha()` bereit, die entweder eine Instanz von einer Klasse benötigt,
die die Schnittstelle @`Zend\Captcha\AdapterInterface` implementiert, oder ein Array, das die Konfiguration[^array] des CAPTCHA 
enthält. Mit der Methode `setCaptcha()` können Sie dem Element den gewünschten CAPTCHA-Typ zuordnen.

[^array]: Im letzteren Fall (Konfigurationsarray) wird der CAPTCHA-Algorithmus
          automatisch von der Factory-Klasse @`Zend\Captcha\Factory` instanziiert und initialisiert.

Sie fügen das Element @`Captcha` wie üblich mit der Methode `add()` zu einem Formularmodell hinzu,
welche von der Basisklasse @`Zend\Form\Form` bereitgestellt wird. Wie üblich können Sie entweder eine Instanz
der Klasse @`Zend\Form\Element\Captcha` übergeben oder eine Reihe von Konfigurationsoptionen für
bestimmte CAPTCHA-Algorithmus (in diesem Fall wird das Element und den zugehörigen CAPTCHA-Algorithmus
automatisch von der Factory-Klasse instanziiert und konfiguriert).

Das folgende Codebeispiel zeigt die Verwendung der letzteren Methode (Übergeben eines Konfigurationsarrays).
Wir bevorzugen diese Methode, da zum Schreiben weniger Code erforderlich ist. Es wird davon ausgegangen, dass Sie
diesen Code innerhalb der geschützten Methode `addElements()` des Formularmodells aufrufen:

{line-numbers=on, lang=php}
~~~
<?php
// Add the CAPTCHA field to the form model
$this->add([
  'type'  => 'captcha',
  'name' => 'captcha',
  'options' => [
    'label' => 'Human check',
    'captcha' => [
      'class' => '<captcha_class_name>', //
      // Certain-class-specific options follow here ...
    ],
  ],
]);
~~~

Im obigen Beispiel rufen wir die Methode `add()` auf, die von der Basisklasse @`Form`[Zend\Form\Form] bereitgestellt wird
und übergeben ihr ein Array, das das einzufügende Element beschreibt (Zeile 3):

 * Der Schlüssel `type` des Arrays (Zeile 4) kann wie üblich entweder ein vollständigen Klassennamen des Elements sein
   (@`Zend\Form\Element\Captcha`) oder dessen kurzer Alias ​​("captcha").
 * Der Schlüssel `name` (Zeile 5) ist der Wert für das Attribut "name" des HTML-Formularfelds.
 * Der Schlüssel `options` enthält die Optionen für den beigefügten CAPTCHA-Algorithmus.
 * Der Schlüssel `class` (Zeile 9) kann entweder den vollständigen CAPTCHA-Klassennamen enthalten (z.B. @`Zend\Captcha\Image`)
   oder dessen kurzen Alias ​​(z. B. "Image"). Andere, adapterspezifische Optionen, können dem Schlüssel auch hinzugefügt
   werden. Wie das geht, zeigen wir später.

Zum Generieren des HTML-Markups für das Element können Sie die View-Helper-Klasse @`FormCaptcha` verwenden
(sie gehört zum Namesraum @`Zend\Form\View\Helper`[Zend\Form]). Aber wie Sie aus dem vorherigen Kapitel gelernt haben,
könnten wir normalerweise stattdessen den übergordneten View-Helper @`FormElement` verwenden,
wie im folgenden Code gezeigt:

{line-numbers=off, lang=php}
~~~
<?= $this->formElement($form->get('captcha')); ?>
~~~

Es wird davon ausgegangen, dass Sie den View-Helper innerhalb Ihres View-Templates aufrufen.

Als Nächstes stellen wir zwei Beispiele vor, die die Verwendung verschiedener CAPTCHA-Typen von ZF3 veranschaulichen:
das @`Image`[Zend\Captcha\Image] und @`Figlet`[Zend\Captcha\Figlet]. Wir zeigen, wie Sie ein CAPTCHA-Feld dem
Kontakt-Formular hinzufügen, welches wir in Beispielen der vorangegangenen Kapitel verwendet haben.

#### Beispiel 1: Hinzufügen von Image-CAPTCHA zum Kontakt-Formular

W> Image CAPTCHA setzt voraus, dass Sie die PHP-Erweiterung GD mit PNG
W> Unterstützung und FT-Schriftarten installiert haben.

Um das CAPTCHA @`Image`[Zend\Captcha\Image] zu Ihrem Formularmodell hinzuzufügen, rufen Sie die Methode `add()` 
des Formulars wie folgt auf:

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Form;
// ...

class ContactForm extends Form
{
    // ...    
    protected function addElements() 
    {
        // ...         
       
        // Add the CAPTCHA field
        $this->add([
            'type'  => 'captcha',
            'name' => 'captcha',
            'attributes' => [
            ],
            'options' => [
                'label' => 'Human check',
                'captcha' => [
                    'class' => 'Image',
                    'imgDir' => 'public/img/captcha',
                    'suffix' => '.png',
                    'imgUrl' => '/img/captcha/',
                    'imgAlt' => 'CAPTCHA Image',
                    'font'   => './data/font/thorne_shaded.ttf',
                    'fsize'  => 24,
                    'width'  => 350,
                    'height' => 100,
                    'expiration' => 600, 
                    'dotNoiseLevel' => 40,
                    'lineNoiseLevel' => 3
                ],
            ],
        ]);
    }
}
~~~

Der Schlüssel `captcha` des Konfigurations-Arrays (siehe Zeile 20) enthält Folgendes:
Parameter für die Konfiguration des an das Formularelement angehängten CAPTCHA-Algorithmus @`Image`[Zend\Captcha\Image]:

 * Der Parameter `class` (Zeile 21) sollte entweder der vollständige Klassenname des CAPTCHA-Adapter
   (@`\Zend\Captcha\Image`) sein oder dessen kurzer Alias ​​(@`Image`[Zend\Captcha\Image]).
   
 * Der Parameter `imgDir` (Zeile 22) sollte der Pfad zu dem Verzeichnis sein, in die die erzeugten verzerrten Bilder 
   gespeichert werden sollen (in diesem Beispiel speichern wir die Bilder im Verzeichnis
   *APP_DIR/public/img/captcha* ).
 
 * Der Parameter `suffix` (Zeile 23) definiert die Erweiterung für eine generierte Bild-Datei
   (in diesem Beispiel ".png").
 
 * Der Parameter `imgUrl` (Zeile 24) definiert den Basisteil der generierten URL zum Öffnen der
   CAPTCHA-Bilder in einem Webbrowser. In diesem Beispiel können Besucher auf das CAPTCHA-Bild 
   mit URLs wie "http://localhost/img/captcha/&lt;ID&gt;" zugreifen, wobei ID eine eindeutige eindeutige ID
   des Bild ist.
 
 * Der Parameter `imgAlt` (Zeile 25) ist ein (optionaler) alternativer Text, der angezeigt werden soll, wenn ein CAPTCHA-Bild
   vom vom Webbrowser nicht geladen werden kann (das Attribut "alt" des Tags `<img>`).
 
 * Der Parameter `font` (Zeile 26) ist der Pfad zur Font-Datei. Sie können eine kostenlose TTF-Schriftart herunterladen,
   zum Beispiel von [hier](http://www.1001freefonts.com/). In diesem Beispiel verwenden wir die Schriftart *Thorne Shaded*,
   welche wir heruntergeladen haben und die Datei *APP_DIR/data/font/thorne_shaded.ttf* hier her kopiert haben.
 
 * Der Parameter `fsize` (Zeile 27) ist eine positive ganze Zahl, die die Schriftgröße definiert.
 
 * Die Parameter `width` (Zeile 28) und `height` bestimmen die Breite und Höhe des CAPTCHA-Bildes (in Pixel).
   des erzeugten Bildes.
 
 * Der Parameter `expiration` (Zeile 30) definiert den Ablaufzeitraum (in Sekunden)
   der CAPTCHA-Bilder. Sobald ein Bild abgelaufen ist, wird es von der Festplatte entfernt.
 
 * Mit den Parameter `dotNoiseLevel` (Zeile 31) und `lineNoiseLevel` (Zeile 32) definieren Sie
   die Bilderzeugungsoptionen (Punktrauschpegel bzw. Linienrauschpegel).

Um das CAPTCHA-Feld zu rendern, fügen Sie Ihrem View-Template *contact-us.phtml* die folgenden Zeilen hinzu:

{line-numbers=off, lang=php}
~~~
<div class="form-group">
  <?= $this->formLabel($form->get('captcha')); ?>
  <?= $this->formElement($form->get('captcha')); ?>
  <?= $this->formElementErrors($form->get('captcha')); ?>
  <p class="help-block">Enter the letters above as you see them.</p>
</div>
~~~

Erstellen Sie schließlich das Verzeichnis *APP_DIR/public/img/captcha*, in dem die generierten CAPTCHA-Bilder gespeichert
werden. Passen Sie die Verzeichnisberechtigungen an, um das Verzeichnis für den Apache-Web-Server beschreibbar zu machen.
In Linux Ubuntu wird dies normalerweise durch die folgenden Shell-Befehle erreicht (ersetzen Sie den
Platzhalter `APP_DIR` mit dem tatsächlichen Verzeichnisnamen Ihrer Webanwendung):

`mkdir APP_DIR/public/img/captcha`

`chown -R www-data:www-data APP_DIR`

`chmod -R 775 APP_DIR`

Der Befehl `mkdir` erstellt das Verzeichnis und die Befehle `chown` und `chmod`
legen den Apache-User als Besitzer des Verzeichnisses fest und gewährt so dem Webserver Schreibrechte im Verzeichnisses.

Wenn Sie jetzt die Seite "http://localhost/contactus" in Ihrem Webbrowser öffnen,
wird sas CAPTCHA-Bild basierend auf einer zufälligen Folge von Buchstaben erstellt und
in der Session die Ziffern gespeichert. Sie sollten etwas in der folgenden Abbildung 11.3 sehen.

![Abbildung 11.3. CAPTCHA-Bild](images/forms_advanced/image_captcha_page.png)

Wenn Sie die Formularfelder ausfüllen und den Button *Submit* drücken, werden die eingegebenen Buchstaben im
Feld *Human Check* an den Server durch einen HTTP-Request übertragen.
Bei der Formularüberprüfung mit der Klasse @`Zend\Form\Element\Captcha`
vergleicht diese die übermittelten Buchstaben mit denen, die in der PHP-Session gespeichert sind. Wenn die Buchstaben
identisch sind, gilt das Formular als gültig; Andernfalls schlägt die Formularüberprüfung fehl.

Sobald der PHP-Renderer das View-Template verarbeitet, generiert er HTML-Markup für
das CAPTCHA-Element wie unten gezeigt:

{line-numbers=off, lang=html}
~~~
<div class="form-group">
  <label for="captcha">Human check</label>
  <img width="350" height="100" alt="CAPTCHA Image" 
       src="/img/captcha/df344b37500dcbb0c4d32f7351a65574.png">
  <input name="captcha[id]" type="hidden" 
         value="df344b37500dcbb0c4d32f7351a65574">
  <input name="captcha[input]" type="text">                              
  <p class="help-block">Enter the letters above as you see them.</p>
</div>
~~~

#### Beispiel 2: Hinzufügen eines FIGlet-CAPTCHA zum Kontakt-Formular

Ersetzen Sie die Definition des Formularelements, mit dem FIGlet-CAPTCHA-Element in Ihrem Formular,
aus dem vorherigen Beispiel, mit folgendem Code:

{line-numbers=on, lang=php}
~~~
<?php
// Add the CAPTCHA field
$this->add([
	'type'  => 'captcha',
	'name' => 'captcha',
	'attributes' => [                                                
	],
	'options' => [
		'label' => 'Human check',
		'captcha' => [
			'class' => 'Figlet',
			'wordLen' => 6,
			'expiration' => 600,                     
		],
	],
]);
~~~

Der Schlüssel `captcha` des Konfigurations-Arrays (siehe Zeile 10) enthält folgende
Parameter für die Konfiguration des an das Formularelement angehängten CAPTCHA-Algorithmus @`Figlet`[Zend\Captcha\Figlet]:

 * Der Parameter `class` (Zeile 11) sollte entweder der vollständige Klassenname des CAPTCHA-Adapter 
   sein (@`\Zend\Captcha\Figlet`) oder dessen kurzer Alias ​​(@`Figlet`[Zend\Captcha\Figlet]).
   
 * Der Parameter `wordLen` (Zeile 12) definiert die Länge des zu erzeugenden Geheimworts.
 
 * Der Parameter `expiration' (Zeile 13) definiert die Gültigkeit des CAPTCHA's (in Sekunden).
   
Öffnen Sie nun die Seite "http://localhost/contactus" in Ihrem Webbrowser.
Sie sollten eine Seite wie in Abbildung 11.4 unten sehen.

![Abbildung 11.4. Figur CAPTCHA](images/forms_advanced/figlet_captcha_page.png)

Sobald der PHP-Renderer das View-Template verarbeitet, generiert er das HTML-Markup für
das CAPTCHA-Element wie unten gezeigt:

{line-numbers=off, lang=html}
~~~
<div class="form-group">
  <label for="captcha">Human check</label>            
    <pre> 
 __   _    __   __   _    _      ___     _    _    __   __  
| || | ||  \ \\/ // | \  / ||   / _ \\  | || | ||  \ \\/ // 
| '--' ||   \ ` //  |  \/  ||  | / \ || | || | ||   \ ` //  
| .--. ||    | ||   | .  . ||  | \_/ || | \\_/ ||    | ||   
|_|| |_||    |_||   |_|\/|_||   \___//   \____//     |_||   
`-`  `-`     `-`'   `-`  `-`    `---`     `---`      `-`'   
                                                           
</pre>
<input name="captcha[id]" type="hidden" 
       value="b68b010eccc22e78969764461be62714">
<input name="captcha[input]" type="text">                              
<p class="help-block">Enter the letters above as you see them.</p>
</div>
~~~

### CSRF verhindern

Cross-Site Request Forgery (CSRF) ist eine Art Hackerangriff, der den Browser des Benutzers zwingt,
einen HTTP-Request an eine beliebige Site zu übertragen. Durch den CSRF-Angriff sendet
ein schädliches Skript unberechtigte Befehle von einem Benutzer, der der Website vertraut.
Dieser Angriff wird normalerweise auf Seiten ausgeführt, die Formulare für die Übermittlung einiger
sensible Daten enthalten (z.B. Geldüberweisungsformulare, Einkaufswagen usw.)

Um besser zu verstehen, wie dieser Angriff funktioniert, sehen Sie sich Abbildung 11.5 an.

![Abbildung 11.5. Beispiel für eines CSRF-Angriffs](images/forms_advanced/csrf_scheme.png)

Abbildung 11.5 zeigt ein Beispiel eines CSRF-Angriffs auf einer Website für ein Zahlungsgateway:

1. Sie melden sich in Ihrem Konto auf der Payment-Gateway-Website *https://payment.com* an. Bitte
   Beachten Sie, dass hier die SSL-geschützte Verbindung (HTTPS) verwendet wird. Diese schützt jedoch nicht
   vor solchen Angriffen.
   
2. Normalerweise aktivieren Sie das Kontrollkästchen "Remember Me" des Anmeldeformulars, um vermeiden, dass man seinen
   Benutzername und das Passwort oft eingeben muss. Sobald Sie sich bei Ihrem Konto angemeldet haben, wird in Ihrem Webbrowser
   Ihre Sitzungsinformationen in eine Cookie-Variable auf Ihrem Computer gespeichert.
   
3. Auf der Payment-Gateway-Site füllen Sie das Zahlungsformular
   *https://payment.com/moneytransfer.php* aus, um Waren zu kaufen. Bitte beachten Sie, das die
   Sicherheitslücke des Zahlungsformular später dazu verwendet wird, um den CSRF-Angriff auszuführen.
   
3. Als Nächstes verwenden Sie denselben Webbrowser, um eine Website zu besuchen, die Sie mögen. Nehmen wir an, die Website
   enthält coole Bilder *http: //coolpictures.com*. Unglücklicherweise,
   ist diese Website mit einem böswilligen Skript infiziert, wie von einem
   HTML-Tag `<img src="image.php">`. Nachdem Sie die HTML-Seite in Ihrem Webbrowser geöffnet haben,
   lädt es alle seine Bilder und führt so das schädliche Skript *image.php* aus.
   
4. Das schädliche Skript überprüft die Cookie-Variable und wenn diese existiert,
   führt das Script "Session-Riding" aus und kann im Auftrag des angemeldeten Benutzers handeln.
   Es ist jetzt möglich, das Zahlungsformular an die Website des Zahlungs-Gateways zu senden.

I> Der oben beschriebene CSRF-Angriff ist möglich, wenn Sie das Webformular auf der Website des Payment Gateways verwenden
I> und es nicht die Quelle des HTTP-Requests prüft. Die Leute, die die Payment-Gateway-Site betreuen,
I> müssen ihre Aufmerksamkeit darauf legen, die Formulare sicherer zu machen.

Um CSRF-Angriffe auf ein Formular zu verhindern, muss das Formular wie folgt mit einem speziellen Token versehen werden:

1. Generieren Sie für ein bestimmtes Formular eine zufällige Folge von Bytes (Token) und
   speichern sie es serverseitig in einer PHP-Session.

2. Fügen Sie dem Formular ein Hidden-Feld hinzu, und legen Sie seinen Wert mit dem Token fest.

3. Vergleichen Sie nach dem Senden des Formulars durch den Benutzer, den im Formular übergebenen versteckten Wert
   mit dem Token mit dem gespeicherten in der PHP-Session. Wenn sie übereinstimmen, sollten Sie die Formulardaten als sicher betrachten.

I> Wenn ein böswilliger Benutzer versucht, die Website durch das Senden des Formulars anzugreifen,
I> wird er nicht in der Lage sein, das richtige Token in das Formular einzugeben, weil das Token
I> nicht in Cookies gespeichert ist.

#### Beispiel: Hinzufügen eines CSRF-Elements zum Formular

In Zend Framework 3 können Sie Ihrem Formularmodell einen CSRF-Schutz hinzufügen.
Sie verwenden die Formularelementklasse @`Zend\Form\Element\Csrf`.

I> Das Element @`Csrf`[Zend\Form\Element\Csrf] hat keine visuelle Darstellung (Sie können es nicht auf dem Bildschirm sehen).

Um ein CSRF-Element in Ihr Formularmodell einzufügen, fügen Sie der Methode `addElements()` die folgenden Zeilen hinzu:

{line-numbers=on, lang=php}
~~~
// Add the CSRF field
$this->add([
  'type'  => 'csrf',
  'name' => 'csrf',
  'options' => [                
    'csrf_options' => [
      'timeout' => 600
    ]
  ],
]);
~~~

Oben verwenden wir die Methode `add()` von @`Form`[Zend\Form\Form] (Zeile 2), an die wir ein Konfigurationsarray übergeben,
welches das CSRF-Element beschreibt. Das Element wird automatisch von der Factory instanziiert und initialisiert.

In Zeile 3 geben wir den Klassennamen für das CSRF-Element an. Dies kann entweder der vollständige Klassename sein
(@`Zend\Form\Element\Csrf`) oder seinen kurzen Alias ​​("csrf").

In Zeile 4 setzen wir das Attribut "name" für das Element. In diesem Beispiel verwenden wir den Namen "csrf".
Sie können jedoch auch einen anderen Namen verwenden.

In Zeile 6 geben wir innerhalb des Arrays `csrf_options` die spezifischen Optionen für die
Klasse @`Zend\Form\Element\Csrf` an. Wir setzen die Option `timeout` auf 600 (siehe Zeile 7).
Dies bedeutet, dass die CSRF-Prüfung 600 Sekunden (10 Minuten) nach der Formularerstellung abläuft.

Um das CSRF-Feld zu rendern, fügen Sie in Ihrem View-Template *.phtml*  die folgende Zeile hinzu:

{line-numbers=off, lang=php}
~~~
<?= $this->formElement($form->get('csrf')); ?>
~~~

Wenn der PHP-Renderer das View-Template auswertet, generiert er das HTML-Markup
für das CSRF-Feld wie unten gezeigt:

{line-numbers=off, lang=html}
~~~
<input type="hidden" name="csrf" value="1bc42bd0da4800fb55d16e81136fe177"> 
~~~

T> Wie Sie anhand des HTML-Markup oben sehen können, enthält das Formular jetzt ein Hidden-Feld mit einem
T> zufällig erzeugten Token. Da das Angreifer-Skript dieses Token nicht kennt, wird es nicht
T> den korrekten Wert eingeben zu können. So wird der CSRF-Angriff verhindert.

Q> **Was passiert, wenn die CSRF-Elementüberprüfung fehlschlägt?**
Q>
Q> Wenn die CSRF-Prüfung während der Formularüberprüfung fehlschlägt, wird das Formular
Q> ungültig und der Benutzer wird es erneut sehen, um Eingabefehler zu beheben. Es aber keine Fehlermeldung
Q> für das CSRF-Element angezeigt (Wir möchten nicht, dass Hacker nicht darüber informiert werden Bescheid,
Q> was mit dem Formular nicht stimmt.)

## Validierungsgruppen verwenden

Manchmal kann es nützlich sein, die Validierung einiger Formularelemente vorübergehend zu deaktivieren. Sie können das 
mit einer Funktion tun, welche sich *Validierungsgruppen* nennt.

I> Standardmäßig werden alle Formularelemente überprüft. Eine Validierungsgruppe ermöglicht das Deaktivieren der Validierung bestimmter Felder.

Angenommen, Sie implementieren ein Formular mit dem Namen "PaymentForm", mit dem Sie eine Zahlungsmethode für mehrere Alternativen (Kreditkarte, Banküberweisung und Barzahlung) auswählen können.
Wenn der Benutzer *Kreditkarte* auswählt, soll er auch die Kreditkartennummer eingeben. Andernfalls wählt der Benutzer *Überweisung* aus,
soll er die Bankdaten eingeben; und schließlich, wenn *Barzahlung* ausgewählt, muss der Benutzer keine zusätzlichen Informationen eingeben.

T> Für dieses Formular müssen Sie abhängige Felder im Browser des Clients mit JavaScript dynamisch ausblenden und anzeigen.

Wie würden Sie ein solches Formular in der Aktion Ihres Controllers bestätigen? Das Problem ist, dass einige Felder *von anderen abhängen*. Das Feld `card_number` ist nur erforderlich,
wenn `payment_method` die "Kreditkarte" ist, ansonsten ist diese optional. Dasselbe gilt für das Feld `bank_account`. Es ist nur erforderlich
wenn `payment_method` die "Überweisung" ist.

Wir können diesen Fall elegant mit der Validierungsgruppe lösen. Die Klasse @`Form`[Zend\Form\Form] stellt die Methode `setValidationGroup()` bereit.
Sie akzeptiert eine Liste mit Feldern, die Sie überprüfen möchten. Alle anderen Felder werden unterdrückt und nicht überprüft.

{line-numbers=off, lang=php}
~~~
// First, we will validate the "payment_method" field.
$form->setValidationGroup(['payment_method']);
if ($form->isValid())
{
    $data = $form->getData();
    
    $paymentMethod = $data['payment_method'];
    
    // Next, validate the dependent fields
    if ($paymentMethod=='credit_card') {
        $form->setValidationGroup(['payment_method', 'card_number']);
    } else if ($paymentMethod=='bank_account') {
        $form->setValidationGroup(['payment_method', 'bank_account']);
    }
    
    if ($form->isValid()) {
        $data = $form->getData();
        
        // Do something with the data
        // ...
    }
}
~~~ 

T> Sie können dieses Beispiel in der Beispiel-Webanwendung *Form Demo* sehen, die mit diesem Buch mitgeliefert wird. Geben Sie einfach
T> die URL "http://localhost/payment" in Ihrem Browser ein.

## Implementieren von mehrstufigen Formularen {#multi-step-forms}

In diesem Abschnitt erhalten Sie Anweisungen, wie Sie ein *mehrstufiges* Formular mit ZF3 implementieren können. Ein mehrstufiges Formular
ist ein Formular mit vielen Feldern, welches in mehreren Schritten angezeigt wird. Um den aktuellen Schritt und die vom Benutzer eingegebenen Daten zu speichern,
werden *PHP-Sessions* verwendet.

I> Zum Beispiel kann die Benutzerregistrierung in mehreren Schritten durchgeführt werden: Im ersten Schritt zeigen Sie die Seite an, die die Eingabe von
I> Login und Passwort zulässt. Im zweiten Schritt zeigen Sie die Seite an, auf der der Websitebesucher seine persönlichen Informationen eingeben kann.
I> Im dritten Schritt kann der Besucher Rechnungsinformationen eingeben.
I>
I> Ein anderes Beispiel für ein mehrstufiges Formular ist ein Umfrageformular. Dieses Formular würde eine Frage und mögliche Varianten der Antwort anzeigen.
I> Dieses Formular hätte so viele Schritte wie viele Fragen in der Umfrage sind.

In diesem Abschnitt implementieren wir das Formular *User Registration*, mit dem Informationen über den registrierten Benutzer erfasst werden können.

T> Sie können dieses vollständige Arbeitsbeispiel in der Beispielanwendung *Form Demo* sehen, welche mit diesem Buch mitgeliefert wird.

### Session aktivieren

T> Wenn Sie mit der PHP-Session-Funktion noch nicht vertraut sind, lesen Sie bitte [Arbeiten mit Sessions](#session), bevor Sie diesen Abschnitt lesen.

Die Sitzungsunterstützung ist in der Komponente @`Zend\Session` implementiert. Sie müssen sie also installieren, wenn Sie dies noch nicht getan haben.

Ändern Sie als Nächstes Ihre Konfigurationsdatei *APP_DIR/config/global.php * wie folgt:

{line-numbers=off,lang=php}
~~~
<?php
use Zend\Session\Storage\SessionArrayStorage;
use Zend\Session\Validator\RemoteAddr;
use Zend\Session\Validator\HttpUserAgent;

return [
    // Session configuration.
    'session_config' => [
        // Session cookie will expire in 1 hour.
        'cookie_lifetime' => 60*60*1, 
        // Store session data on server maximum for 30 days.
        'gc_maxlifetime'  => 60*60*24*30,
    ],
    // Session manager configuration.
    'session_manager' => [
        // Session validators (used for security).
        'validators' => [
            RemoteAddr::class,
            HttpUserAgent::class,
        ]
    ],
    // Session storage configuration.
    'session_storage' => [
        'type' => SessionArrayStorage::class
    ],
    
    // ...
];
~~~
 
Fügen Sie dann die folgenden Zeilen zu Ihrer *module.config.php* hinzu, um den Session-Container *UserRegistration* zu registrieren:

{line-numbers=off,lang=php}
~~~
<?php
return [
    // ...
    'session_containers' => [
        'UserRegistration'
    ],
];
~~~

Erledigt! Jetzt können wir Session-Container in unserem Code verwenden. Als Nächstes implementieren wir das
Formularmodell `RegistrationForm`.

### Formularmodel RegistrationForm hinzufügen

Das Formular `RegistrationForm` wird verwendet, um Daten über vom Benutzer (E-Mail, vollständiger Name,
Passwort, persönliche Informationen und Rechnungsinformationen) zu erhalten. Wir werden dem Formular in drei Teilen Elemente hinzufügen.
Dadurch kann es als mehrstufiges Formular verwendet werden.

Erstellen Sie zum Hinzufügen des Formularmodells die Datei *RegistrationForm.php*
im Verzeichnis *Form* im Quellverzeichnis des Moduls *Application*:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Form;

use Zend\Form\Form;
use Zend\InputFilter\InputFilter;
use Application\Validator\PhoneValidator;

/**
 * This form is used to collect user registration data. This form is multi-step.
 * It determines which fields to create based on the $step argument you pass to
 * its constructor.
 */
class RegistrationForm extends Form
{
    /**
     * Constructor.     
     */
    public function __construct($step)
    {
        // Check input.
        if (!is_int($step) || $step<1 || $step>3)
            throw new \Exception('Step is invalid');
        
        // Define form name
        parent::__construct('registration-form');
     
        // Set POST method for this form
        $this->setAttribute('method', 'post');
                
        $this->addElements($step);
        $this->addInputFilter($step); 
    }
    
    /**
     * This method adds elements to form (input fields and submit button).
     */
    protected function addElements($step) 
    {
        if ($step==1) {
            
            // Add "email" field
            $this->add([           
                'type'  => 'text',
                'name' => 'email',
                'attributes' => [
                    'id' => 'email'
                ],
                'options' => [
                    'label' => 'Your E-mail',
                ],
            ]);
            
            // Add "full_name" field
            $this->add([           
                'type'  => 'text',
                'name' => 'full_name',
                'attributes' => [
                    'id' => 'full_name'
                ],
                'options' => [
                    'label' => 'Full Name',
                ],
            ]);
            
            // Add "password" field
            $this->add([           
                'type'  => 'password',
                'name' => 'password',
                'attributes' => [
                    'id' => 'password'
                ],
                'options' => [
                    'label' => 'Choose Password',
                ],
            ]);
            
            // Add "confirm_password" field
            $this->add([           
                'type'  => 'password',
                'name' => 'confirm_password',
                'attributes' => [
                    'id' => 'confirm_password'
                ],
                'options' => [
                    'label' => 'Type Password Again',
                ],
            ]);           
            
        } else if ($step==2) {
            
            // Add "phone" field
            $this->add([
                'type'  => 'text',
                'name' => 'phone',
                'attributes' => [                
                    'id' => 'phone'
                ],
                'options' => [
                    'label' => 'Mobile Phone',
                ],
            ]);

            // Add "street_address" field
            $this->add([
                'type'  => 'text',
                'name' => 'street_address',
                'attributes' => [                
                    'id' => 'street_address'
                ],
                'options' => [
                    'label' => 'Street address',
                ],
            ]);
            
            // Add "city" field
            $this->add([
                'type'  => 'text',
                'name' => 'city',
                'attributes' => [                
                    'id' => 'city'
                ],
                'options' => [
                    'label' => 'City',
                ],
            ]);
            
            // Add "state" field
            $this->add([
                'type'  => 'text',
                'name' => 'state',
                'attributes' => [                
                    'id' => 'state'
                ],
                'options' => [
                    'label' => 'State',
                ],
            ]);
            
            // Add "post_code" field
            $this->add([
                'type'  => 'text',
                'name' => 'post_code',
                'attributes' => [                
                    'id' => 'post_code'
                ],
                'options' => [
                    'label' => 'Post Code',
                ],
            ]);
            
            // Add "country" field
            $this->add([            
                'type'  => 'select',
                'name' => 'country',
                'attributes' => [
                    'id' => 'country',                                
                ],                                    
                'options' => [                                
                    'label' => 'Country',
                    'empty_option' => '-- Please select --',
                    'value_options' => [
                        'US' => 'United States',
                        'CA' => 'Canada',
                        'BR' => 'Brazil',
                        'GB' => 'Great Britain',
                        'FR' => 'France',
                        'IT' => 'Italy',
                        'DE' => 'Germany',
                        'RU' => 'Russia',
                        'IN' => 'India',
                        'CN' => 'China',
                        'AU' => 'Australia',
                        'JP' => 'Japan'
                    ],                
                ],
            ]);
            
            
        } else if ($step==3) {
            
            // Add "billing_plan" field
            $this->add([            
                'type'  => 'select',
                'name' => 'billing_plan',
                'attributes' => [
                    'id' => 'billing_plan',                                
                ],                                    
                'options' => [                                
                    'label' => 'Billing Plan',
                    'empty_option' => '-- Please select --',
                    'value_options' => [
                        'Free' => 'Free',
                        'Bronze' => 'Bronze',
                        'Silver' => 'Silver',
                        'Gold' => 'Gold',
                        'Platinum' => 'Platinum'
                    ],                
                ],
            ]);
            
            // Add "payment_method" field
            $this->add([            
                'type'  => 'select',
                'name' => 'payment_method',
                'attributes' => [
                    'id' => 'payment_method',                                
                ],                                    
                'options' => [                                
                    'label' => 'Payment Method',
                    'empty_option' => '-- Please select --',
                    'value_options' => [
                        'Visa' => 'Visa',
                        'MasterCard' => 'Master Card',
                        'PayPal' => 'PayPal'
                    ],                
                ],
            ]);
        }
        
        // Add the CSRF field
        $this->add([
            'type'  => 'csrf',
            'name' => 'csrf',
            'attributes' => [],
            'options' => [                
                'csrf_options' => [
                     'timeout' => 600
                ]
            ],
        ]);
        
        // Add the submit button
        $this->add([
            'type'  => 'submit',
            'name' => 'submit',
            'attributes' => [                
                'value' => 'Next Step',
                'id' => 'submitbutton',
            ],
        ]);        
    }
    
    /**
     * This method creates input filter (used for form filtering/validation).
     */
    private function addInputFilter($step) 
    {
        $inputFilter = new InputFilter();        
        $this->setInputFilter($inputFilter);
        
        if ($step==1) {

            $inputFilter->add([
                    'name'     => 'email',
                    'required' => true,
                    'filters'  => [
                        ['name' => 'StringTrim'],                    
                    ],                
                    'validators' => [
                        [
                            'name' => 'EmailAddress',
                            'options' => [
                                'allow' => \Zend\Validator\Hostname::ALLOW_DNS,
                                'useMxCheck'    => false,                            
                            ],
                        ],
                    ],
                ]);
            
            $inputFilter->add([
                'name'     => 'full_name',
                'required' => true,
                'filters'  => [
                    ['name' => 'StringTrim'],
                    ['name' => 'StripTags'],
                    ['name' => 'StripNewlines'],
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 1,
                            'max' => 128
                        ],
                    ],
                ],
            ]);
           
            // Add input for "password" field
            $inputFilter->add([
                    'name'     => 'password',
                    'required' => true,
                    'filters'  => [                    
                    ],                
                    'validators' => [
                        [
                            'name'    => 'StringLength',
                            'options' => [
                                'min' => 6,
                                'max' => 64
                            ],
                        ],
                    ],
                ]);  

            // Add input for "confirm_password" field
            $inputFilter->add([
                    'name'     => 'confirm_password',
                    'required' => true,
                    'filters'  => [
                    ],       
                    'validators' => [
                        [
                            'name'    => 'Identical',
                            'options' => [
                                'token' => 'password',                            
                            ],
                        ],
                    ],
                ]);
            
        } else if ($step==2) {
        
            $inputFilter->add([
                'name'     => 'phone',
                'required' => true,                
                'filters'  => [                    
                ],                
                'validators' => [
                    [
                        'name'    => 'StringLength',
                        'options' => [
                            'min' => 3,
                            'max' => 32
                        ],
                    ],
                    [
                        'name' => PhoneValidator::class,
                        'options' => [
                            'format' => PhoneValidator::PHONE_FORMAT_INTL
                        ]                        
                    ],
                ],
            ]);
            
            // Add input for "street_address" field
            $inputFilter->add([
                    'name'     => 'street_address',
                    'required' => true,
                    'filters'  => [
                        ['name' => 'StringTrim'],
                    ],                
                    'validators' => [
                        ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]]
                    ],
                ]);

            // Add input for "city" field
            $inputFilter->add([
                    'name'     => 'city',
                    'required' => true,
                    'filters'  => [
                        ['name' => 'StringTrim'],
                    ],                
                    'validators' => [
                        ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>255]]
                    ],
                ]);

            // Add input for "state" field
            $inputFilter->add([
                    'name'     => 'state',
                    'required' => true,
                    'filters'  => [
                        ['name' => 'StringTrim'],
                    ],                
                    'validators' => [
                        ['name'=>'StringLength', 'options'=>['min'=>1, 'max'=>32]]
                    ],
                ]); 
            
            // Add input for "post_code" field
            $inputFilter->add([
                    'name'     => 'post_code',
                    'required' => true,
                    'filters'  => [                                        
                    ],                
                    'validators' => [
                        ['name' => 'IsInt'],
                        ['name'=>'Between', 'options'=>['min'=>0, 'max'=>999999]]
                    ],
                ]);

            // Add input for "country" field
            $inputFilter->add([
                    'name'     => 'country',
                    'required' => false,                
                    'filters'  => [
                        ['name' => 'Alpha'],
                        ['name' => 'StringTrim'],
                        ['name' => 'StringToUpper'],
                    ],                
                    'validators' => [
                        ['name'=>'StringLength', 'options'=>['min'=>2, 'max'=>2]]
                    ],
                ]);     
            
        } else if ($step==3) {
            
            // Add input for "billing_plan" field
            $inputFilter->add([
                    'name'     => 'billing_plan',
                    'required' => true,                
                    'filters'  => [
                    ],                
                    'validators' => [
                        [
                            'name' => 'InArray', 
                            'options' => [
                                'haystack'=>[
                                    'Free', 
                                    'Bronze',
                                    'Silver',
                                    'Gold',
                                    'Platinum'
                                ]
                            ]
                        ]
                    ],
                ]);
            
            // Add input for "payment_method" field
            $inputFilter->add([
                    'name'     => 'payment_method',
                    'required' => true,                
                    'filters'  => [
                    ],                
                    'validators' => [
                        [
                            'name' => 'InArray', 
                            'options' => [
                                'haystack'=>[
                                    'PayPal', 
                                    'Visa',
                                    'MasterCard',
                                ]
                            ]
                        ]
                    ],
                ]);
        }
    }
}
~~~

Wie Sie dem obigen Code entnehmen können, handelt es sich bei `RegistrationForm` um ein übliches Formularmodell, das jedoch das Argument `$step` akzeptiert.
In seinem Konstruktor können Sie angeben, welche Formularelemente für den aktuellen Schritt verwendet werden sollen.

### RegistrationController hinzufügen

Als Nächstes fügen wir die Controller-Klasse `RegistrationController` hinzu. Erstellen Sie dazu die Datei *RegistrationController.php*
im Verzeichnis *Controller* und fügen Sie den folgenden Code hinzu:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Application\Form\RegistrationForm;
use Zend\Session\Container;

/**
 * This is the controller class displaying a page with the User Registration form.
 * User registration has several steps, so we display different form elements on
 * each step. We use session container to remember user's choices on the previous
 * steps.
 */
class RegistrationController extends AbstractActionController 
{
    /**
     * Session container.
     * @var Zend\Session\Container
     */
    private $sessionContainer;
    
    /**
     * Constructor. Its goal is to inject dependencies into controller.
     */
    public function __construct($sessionContainer) 
    {
        $this->sessionContainer = $sessionContainer;
    }
    
    /**
     * This is the default "index" action of the controller. It displays the 
     * User Registration page.
     */
    public function indexAction() 
    {
        // Determine the current step.
        $step = 1;
        if (isset($this->sessionContainer->step)) {
            $step = $this->sessionContainer->step;            
        }
        
        // Ensure the step is correct (between 1 and 3).
        if ($step<1 || $step>3)
            $step = 1;
        
        if ($step==1) {
            // Init user choices.
            $this->sessionContainer->userChoices = [];
        }
                       
        $form = new RegistrationForm($step);
        
        // Check if user has submitted the form
        if($this->getRequest()->isPost()) {
            
            // Fill in the form with POST data
            $data = $this->params()->fromPost();            
            
            $form->setData($data);
            
            // Validate form
            if($form->isValid()) {
                
                // Get filtered and validated data
                $data = $form->getData();
                
                // Save user choices in session.
                $this->sessionContainer->userChoices["step$step"] = $data;
                
                // Increase step
                $step ++;
                $this->sessionContainer->step = $step;
                
                // If we completed all 3 steps, redirect to Review page.
                if ($step>3) {
                    return $this->redirect()->toRoute('registration', 
                                ['action'=>'review']);
                }
                
                // Go to the next step.
                return $this->redirect()->toRoute('registration');
            }
        }
        
        $viewModel = new ViewModel([
            'form' => $form
        ]);
        $viewModel->setTemplate("application/registration/step$step");
        
        return $viewModel;
    }
    
    /**
     * The "review" action shows a page allowing to review data entered on previous
     * three steps.
     */
    public function reviewAction()
    {
        // Validate session data.
        if(!isset($this->sessionContainer->step) || 
           $this->sessionContainer->step<=3 || 
           !isset($this->sessionContainer->userChoices)) {
            throw new \Exception('Sorry, the data is not available for review yet');
        }
        
        // Retrieve user choices from session.
        $userChoices = $this->sessionContainer->userChoices;
        
        return new ViewModel([
            'userChoices' => $userChoices
        ]);
    }
}
~~~

In der Klasse oben haben wir drei Methoden:

  * Der Konstruktor `__construct()`. Er wird verwendet, um die Abhängigkeit - den Sitzungscontainer - dem Controller zu übergeben.

  * Die Aktionsmethode `indexAction()` extrahiert den aktuellen Schritt aus der Session und initialisiert das Formularmodell.
    Wenn der Benutzer das Formular gesendet hat, extrahieren wir die Daten aus dem Formular und speichern sie in der Session, wodurch der Schritt erhöht wird.
    Wenn der Schritt größer als 3 ist, leiten wir den Benutzer auf die Seite "Überprüfen" um.
    
  * Die Aktionsmethode `reviewAction()` extrahiert die vom Benutzer in allen drei Schritten eingegebenen Daten und übergibt sie an
    die View zum Rendern.

#### RegistrationControllerFactory hinzufügen

Als nächstes fügen wir die Factory für den `RegistrationController` hinzu. Erstellen Sie dazu die Datei *RegistrationControllerFactory.php*
im Verzeichnis *Controller/Form* im Quellverzeichnis des Moduls. Fügen Sie den folgenden Code ein:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Controller\RegistrationController;

/**
 * This is the factory for RegistrationController. Its purpose is to instantiate the
 * controller and inject dependencies into it.
 */
class RegistrationControllerFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                       $requestedName, array $options = null)
    {
        $sessionContainer = $container->get('UserRegistration');
        
        // Instantiate the controller and inject dependencies
        return new RegistrationController($sessionContainer);
    }
}
~~~

T> Vergessen Sie nicht, den Controller in der Datei *module.config.php* zu registrieren!

### Hinzufügen der View-Templates

Fügen wir nun die View-Templates für die Controller-Aktionen hinzu. Wir haben vier View-Templates: *step1.phtml*, *step2.phtml*,
*step3.phtml* und *review.phtml*. Die ersten drei werden von der `indexAction()` und die letzte von `reviewAction()` verwendet.

Erstellen Sie die Datei *step1.phtml* im Verzeichnis *application/registration* und fügen Sie den folgenden Code ein:

{line-numbers=off,lang=php}
~~~
<?php
$form->get('email')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'name@yourcompany.com'
    ]);

$form->get('full_name')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'John Doe'
    ]);

$form->get('password')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Type password here (6 characters at minimum)'
    ]);

$form->get('confirm_password')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Repeat password'
    ]);

$form->get('submit')->setAttributes(array('class'=>'btn btn-primary'));

$form->prepare();
?>

<h1>User Registration - Step 1</h1>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('email')); ?>
            <?= $this->formElement($form->get('email')); ?>
            <?= $this->formElementErrors($form->get('email')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('full_name')); ?>
            <?= $this->formElement($form->get('full_name')); ?>
            <?= $this->formElementErrors($form->get('full_name')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('password')); ?>
            <?= $this->formElement($form->get('password')); ?>
            <?= $this->formElementErrors($form->get('password')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('confirm_password')); ?>
            <?= $this->formElement($form->get('confirm_password')); ?>
            <?= $this->formElementErrors($form->get('confirm_password')); ?>
        </div>
        
        <div class="form-group">
        <?= $this->formElement($form->get('submit')); ?>
        </div>
        
        <?= $this->formElement($form->get('csrf')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~
    
Erstellen Sie anschließend die Datei *step2.phtml* im Verzeichnis *application/registration*  und fügen Sie den folgenden Code ein:

{line-numbers=off,lang=php}
~~~
<?php
$form->get('phone')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Phone number in international format'
    ]);

$form->get('street_address')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('city')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('state')->setAttributes([
    'class'=>'form-control',
    ]);

$form->get('post_code')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('country')->setAttributes([
    'class'=>'form-control'
    ]);

$form->get('submit')->setAttributes(array('class'=>'btn btn-primary'));

$form->prepare();
?>

<h1>User Registration - Step 2 - Personal Information</h1>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('phone')); ?>
            <?= $this->formElement($form->get('phone')); ?>
            <?= $this->formElementErrors($form->get('phone')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('street_address')); ?>
            <?= $this->formElement($form->get('street_address')); ?>
            <?= $this->formElementErrors($form->get('street_address')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('city')); ?>
            <?= $this->formElement($form->get('city')); ?>
            <?= $this->formElementErrors($form->get('city')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('state')); ?>
            <?= $this->formElement($form->get('state')); ?>
            <?= $this->formElementErrors($form->get('state')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('post_code')); ?>
            <?= $this->formElement($form->get('post_code')); ?>
            <?= $this->formElementErrors($form->get('post_code')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('country')); ?>
            <?= $this->formElement($form->get('country')); ?>
            <?= $this->formElementErrors($form->get('country')); ?>
        </div>
        
        <div class="form-group">
        <?= $this->formElement($form->get('submit')); ?>
        </div>
        
        <?= $this->formElement($form->get('csrf')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~

Anschließend erstellen Sie die Datei *step3.phtml* im Verzeichnis *application/registration* und fügen Sie den folgenden Code ein:

{line-numbers=off,lang=php}
~~~
<?php
$form->get('billing_plan')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('payment_method')->setAttributes([
    'class'=>'form-control', 
    ]);

$form->get('submit')->setAttributes(array('class'=>'btn btn-primary'));

$form->prepare();
?>

<h1>User Registration - Step 3 - Billing Information</h1>

<div class="row">
    <div class="col-md-6">
        <?= $this->form()->openTag($form); ?>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('billing_plan')); ?>
            <?= $this->formElement($form->get('billing_plan')); ?>
            <?= $this->formElementErrors($form->get('billing_plan')); ?>
        </div>
        
        <div class="form-group">
            <?= $this->formLabel($form->get('payment_method')); ?>
            <?= $this->formElement($form->get('payment_method')); ?>
            <?= $this->formElementErrors($form->get('payment_method')); ?>
        </div>
        
        <div class="form-group">
        <?= $this->formElement($form->get('submit')); ?>
        </div>
        
        <?= $this->formElement($form->get('csrf')); ?>
        
        <?= $this->form()->closeTag(); ?>
    </div>    
</div>   
~~~ 

Erstellen Sie schließlich Datei *review.phtml* im Verzeichnis *application/registration* und fügen Sie den folgenden Code hinzu:

{line-numbers=off,lang=php}
~~~
<h1>User Registration - Review</h1>

<p>Thank you! Now please review the data you entered in previous three steps.</p>

<pre>
<?php print_r($userChoices); ?>
</pre>
~~~    

### Adding Route

Add the following route inside your *module.config.php* config file:

{line-numbers=off,lang=php}
~~~
'registration' => [
    'type'    => Segment::class,
    'options' => [
        'route'    => '/registration[/:action]',
        'constraints' => [
            'action' => '[a-zA-Z][a-zA-Z0-9_-]*'
        ],
        'defaults' => [
            'controller'    => Controller\RegistrationController::class,
            'action'        => 'index',
        ],
    ],
],
~~~

Großartig! Nun ist alles bereit, um die Ergebnisse zu sehen!

### Ergebnisse

Geben Sie die URL "http://localhost/registration" in die Navigationsleiste Ihres Browser ein, um unser mehrstufiges 
Formular in Aktion zu sehen. Die Seite *User Registration - Step 1* wird angezeigt (siehe Abbildung 11.6 unten):

![Abbildung 11.6. Benutzerregistrierung - Schritt 1](images/forms_advanced/registration_step1.png)

Nachdem der Benutzer seine E-Mail-Adresse, den vollständigen Namen und das Kennwort eingegeben und auf *Next* geklickt hat, wird er zum nächsten Schritt weitergeleitet
(siehe Abbildung 11.7):

![Abbildung 11.7. Benutzerregistrierung - Schritt 2](images/forms_advanced/registration_step2.png)

Der letzte Schritt ist in Abbildung 11.8 dargestellt:

![Abbildung 11.8. Benutzerregistrierung - Schritt 3](images/forms_advanced/registration_step3.png)
    
Wenn Sie auf *Next* klicken, wird die Seite *Review* angezeigt, in der die, in den vorherigen drei Schritten eingegebenen Daten, angezeigt werden:

![Abbildung 11.9. Benutzerregistrierung - Überprüfung](images/forms_advanced/registration_review.png)
  
T> Dieses vollständige Beispiel finden Sie in der Beispielanwendung *Form Demo*, welches in diesem Buch enthalten ist.
    
## Zusammenfassung

In diesem Kapitel haben wir einige erweiterte Funktionen zur Verwendung von Formularen erläutert.

Zend Framework 3 bietet zwei Klassen, deren Zweck die Verbesserung der Formularsicherheit ist: @`Captcha`
und @`Csrf`[Zend\Form\Element\Csrf]. Ein CAPTCHA ist eine Art Frage-Antwort-Test, mit dem bestimmt wird, ob der
Benutzer ist ein Mensch oder nicht. CAPTCHA-Elemente werden im Formular verwendet, um die Übermittlung von Formularen durch einen
böswilliger automatisierter Prozess (ein Roboter) zu verhindern. Das letztere Element, @`Csrf`[Zend\Form\Element\Csrf], wird gegen 
Cross-Site-Request Forgery (kurz CSRF) zur Verhinderung von Hackerangriffen verwendet.

Wir haben auch gelernt, wie Sie mithilfe von Sessions ein mehrstufiges Formular implementieren können.
