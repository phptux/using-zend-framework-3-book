# Benutzerverwaltung, Authentifizierung und Zugriffsfilterung {#users}

Bei den meisten Websites im Internet können sich Besucher auf der Website registrieren und ein Profil erstellen. Anschließend
können sich die Besucher einloggen und eine persönliche Einstellungen tätigen. Zum Beispiel auf einer E-Commerce-Website
kann ein registrierter Benutzer Waren kaufen, seinen Einkaufswagen verwalten und mit einer Kreditkarte bezahlen.

In diesem Kapitel erfahren Sie, wie Sie die Benutzerauthentifizierung mit Login und Passwort auf einer ZF3-Website implementieren.
Wir zeigen Ihnen, wie Sie Benutzer in Ihrer Webanwendung verwalten (hinzufügen, bearbeiten, anzeigen und ändern/zurücksetzen) können und wie die Passwörter der Benutzer in der Datenbank
sicher gespeichert werden. Außerdem erfahren Sie, wie Sie einen Zugriffsfilter implementieren und zulassen, dass nur authentifizierte Benutzer auf bestimmte Seiten zugreifen können.

Da Sie bereits viel über ZF3 wissen, wenn Sie die vorherigen Kapitel gelesen haben, werden wir in diesem Kapite
die Besprechung einiger offensichtlicher Dinge auslassen und uns nur auf *konzeptuellen* Dinge konzentrieren. Es wird empfohlen, sich
das Beispiel *User Demo* , welches diesem Buch beiliegt anzusehen. Es ist eine vollständige Website, auf der Sie alles in Aktion sehen können.
Der gesamte behandelte Code in diesem Kapitel ist Teil dieser Beispielanwendung.

In diesem Kapitel behandelte ZF3-Komponenten:

|-----------------------|-------------------------------------------------------------------|
| *Komponente* 			| *Beschreibung* 													|
|-----------------------|-------------------------------------------------------------------|
| @ Zend\Authentication`| Bietet die Funktion der Benutzerauthentifizierung. 				|
|-----------------------|-------------------------------------------------------------------|
| @`Zend\Crypt` 		| Bietet Funktionalität für die Kennwortverschlüsselung. 			|
|-----------------------|-------------------------------------------------------------------|
| @`Zend\Math` 			| Stellt Funktionen zum Generieren sicherer zufälliger Token bereit.|
|-----------------------|-------------------------------------------------------------------|

## Holen Sie sich das Beispiel User Demo von GitHub

Zur Demonstration erstellen wir in diesem Kapitel eine echte *User Demo* Website.
Diese zeigt, wie man:

  * Ein neues Modul mit dem Namen *User* erstellt. Dieses Modul enthält die Funktionen zur Benutzerauthentifizierung und Benutzerverwaltung.
  * Erstellung einer Entität `User`.
  * Implementieren Sie das sichere Speichern von Benutzerpasswörtern in einer Datenbank.
  * Implementieren Sie die Benutzerauthentifizierung (mit Login und Passwort).
  * Implementieren Sie einen Zugriffsfilter, um nur authentifizierten Benutzern Zugriff auf bestimmte Seiten zu gewähren.
  * Implementieren Sie die Benutzerverwaltungsoberfläche, mit der Sie einen Benutzer hinzufügen, bearbeiten, anzeigen und das Kennwort des Benutzers ändern können.
  * Implementieren Sie die unterschiedlichen Hauptmenüelemente, je nachdem, ob der aktuelle Benutzer angemeldet ist oder nicht.
  
Um die Anwendung *User Demo* herunterzuladen, besuchen Sie [diese Seite](https://github.com/olegkrivtsov/using-zf3-book-samples).
Klicken Sie auf die Schaltfläche *Clone oder Download*, um den Code als ZIP-Archiv herunterzuladen.
Wenn der Download abgeschlossen ist, entpacken Sie das Archiv in ein Verzeichnis.

Navigieren Sie dann zu dem Verzeichnis `userdemo`, dass den
Quellcode der Webanwendung *User Demo* enthält:

{line-numbers=off,lang=text}
~~~
/using-zf3-book-samples
  /userdemo
  ...
~~~

Die *User Demo* ist eine Website, die auf Ihrem Computer installiert werden kann.

I> Detaillierte Anweisungen zur Installation des Beispiels *User Demo* finden Sie in der Datei *README.md*, die sich im Beispielverzeichnis befindet.

## Erstellen des Moduls User

Im Beispiel *User Demo* erstellen wir ein neues Modul mit dem Namen *User* und fügen alle Funktionen hinzu, die
im Zusammenhang mit der Benutzerverwaltung und Authentifizierung für dieses Modul notwendig sind. Wenn Sie neu sind,
finden Sie Informationen zum Modulkonzept im Kapitel [Erstellen eines neuen Moduls](#modules).

Das Modul *User* hat sehr wenige Abhängigkeiten zu anderen
Module der Website. Die Idee hinter dem Modul *User* ist, Ihnen eine wiederverwendbare Einheit zur Verfügung zu stellen, die Sie in Ihrer eigenen Web-Anwendung verwenden können, 
ohne Änderungen oder mit einigen Änderungen.

T> Im Idealfall können Sie das Modul *User* auf Ihrer eigenen Website ohne Änderungen verwenden. Aber bei realen
T> Websites müssen Sie wahrscheinlich einige Felder zur Tabelle `user` hinzufügen, den Arbeitsablauf für die Benutzerregistrierung ändern oder
T> den Zugriffsfilterungsalgorithmus ändern. In diesem Fall müssen Sie den Code des Moduls *User* anpassen,
T> um Ihre Bedürfnisse zu erfüllen.

Das Modul *User*  hat die folgende Struktur (siehe Abbildung 16.1 unten):

![Abbildung 16.1 Struktur des Modul User](images/users/user_module_structure.png)

Beschreiben wir kurz, welche Klassen wir im Modulverzeichnis haben werden.

Wir werden zwei Controller haben:

  * Der *UserController* enthält Funktionen zum Verwalten von Benutzern (Hinzufügen, Bearbeiten, Ändern des Kennworts usw.).
  * Der *AuthController* implementiert die Funktionen zur Benutzerauthentifizierung (Anmelden/Abmelden).

Es wird eine Entität von Doctrine geben:

  * Die Entität *User* wird verwendet, um Informationen über den Benutzer in der Datenbank zu speichern (E-Mail, vollständiger Name, Passwort usw.).

Wir werden vier Formulare verwenden, um Daten zu sammeln:

  * Das *LoginForm* wird verwendet, um Daten für die Authentifizierung (Login und Passwort) zu sammeln.
  * Das *PasswordChangeForm* wird zum Sammeln von Daten zum Ändern oder Zurücksetzen des Benutzerpassworts verwendet.
  * Das *PasswordResetForm* wird verwendet, um die E-Mail-Adresse der Person abzuholen, die ihr Passwort vergessen hat und das Passwort zurücksetzen möchte.
  * Die *UserForm* wird verwendet, um Daten über den Benutzer zu sammeln (E-Mail, vollständiger Name, Passwort usw.).
  
Wir werden mehrere Service haben:

  * Der Service *AuthAdapter* implementiert den Authentifizierungsalgorithmus. Es wird geprüft, ob der Benutzer anmeldet ist (E-Mail-Adresse)
    und Passwort korrekt ist. Dazu werden die Benutzerinformationen aus einer Datenbank abgerufen.
  * Der Service *AuthManager* führt eine tatsächliche Authentifizierung (Anmelden/Abmelden) durch. Es wird auch
    den Zugriffsfilter implementieren, der es ermöglicht ermöglicht, den Zugriff auf bestimmte Webseiten zuzulassen oder zu verweigern.
  * Der *UserManager* enthält Geschäftslogik zur Verwaltung von Benutzern (Hinzufügen, Bearbeiten, Ändern des Passworts).

Die meisten Controller und Serivce werden mit Factories instanziiert. Die Factory-Klassen befinden sich im
Unterverzeichnis *Factory*.
  
Im Verzeichnis *view* werden wir mehrere View-Templates haben, die das HTML-Markup der Webseiten
in der Benutzeroberfläche darstellen, die von unserem Modul angezeigt werden.

Wie üblich haben wir im Verzeichnis *config* die Datei *module.config.php*, die die Routen und die Registrierung für unsere Controller und Service 
enthält. Sie beinhaltet auch den Schlüssel *access_filter*, der definiert, welche Seiten für einen
authentifizierter Benutzer zugänglich sind (Dieser Schlüssel wird vom Service *AuthManager* gelesen).
  
Wie Sie sehen, ist das Modul *User* ein typisches ZF3-Modul, dessen Struktur dem MVC-Muster entspricht.

## Erstellen der Datenbank

Wir müssen eine Beispieldatenbank "userdemo" erstellen. Die Datenbank hat eine einzige Tabelle mit dem Namen `user`. In ihr werden
die Daten, die mit Benutzern unserer Website in Verbindung stehen, gespeichert (siehe Abbildung 16.2 unten).

![Abbildung 16.2 Benutzertabelle](images/users/userdemo_database_schema.png)

Die Tabelle `user` enthält die folgenden Felder:

  * Die `id` ist ein automatisch inkrementiertes Ganzzahlfeld (Primärschlüssel).
  * Die `email` ist ein String-Feld, welches die E-Mail-Adresse des Benutzers enthält. Jeder Benutzer hat eine eindeutige E-Mail-Adresse, daher ist dieses Feld auch ein eindeutiger Schlüssel.
  * Das `full_name` ist ein String-Feld, welches den vollständigen Namen eines Benutzers enthält (wie "John Doe").
  * Das Ganzzahlfeld `status` enthält den Status des Benutzers (entweder "aktiv" oder "ruhend"). Ruhende Benutzer dürfen sich nicht anmelden.
  * Das Feld `date_created` enthält Datum und Uhrzeit der Erstellung des Benutzers.
  * Die Felder `pwd_reset_token` und` pwd_reset_token_creation_date` werden zum Zurücksetzen des Passworts verwendet (wenn der Benutzer sein Passwort vergisst und es zurücksetzen muss).

T> Auf Ihrer eigenen Website möchten Sie wahrscheinlich weitere Felder zur Tabelle `user` hinzufügen.
T> In diesem Beispiel definieren wir nur einige minimale Felder.

Sie können die Tabelle `user` mit der folgenden SQL-Anweisung erstellen:

{line-numbers=off,lang=sql}
~~~
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `email` varchar(128) NOT NULL,
  `full_name` varchar(512) NOT NULL,
  `password` varchar(256) NOT NULL,
  `status` int(11) NOT NULL,
  `date_created` datetime NOT NULL,
  `pwd_reset_token` varchar(32) DEFAULT NULL,
  `pwd_reset_token_creation_date` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `email_idx` (`email`)
);
~~~

In der Beispielanwendung *User Demo* finden Sie eine Migration, die die Tabelle `user` erstellt.

T> Wenn Sie mit Migrationen noch nicht vertraut sind, lesen Sie Kapitel [Datenbankmigrationen](#migrations).
  
## Implementieren der Entität User

Das Beispiel *User Demo* verwendet Doctrine ORM zur Verwaltung der Datenbank. Wir haben bereits gelernt, Doctrine in einzusetzen - 
[Datenbankverwaltung mit Doctrine ORM](#doctrine).

Um die Informationen über den Benutzer in der Datenbank zu speichern, erstellen wir die Entität `User`. Die Entität `User` wird der
Datenbanktabelle `user` zugeordnet. Es ist eine typische Entität-Klasse von Doctrine.

Erstellen Sie die Datei *User.php* im Verzeichnis *Entity* im Quellverzeichnis des Moduls. Fügen Sie
den folgenden Code in diese Datei:

{line-numbers=off,lang=php}
~~~
<?php
namespace User\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * This class represents a registered user.
 * @ORM\Entity()
 * @ORM\Table(name="user")
 */
class User 
{
    // User status constants.
    const STATUS_ACTIVE       = 1; // Active user.
    const STATUS_RETIRED      = 2; // Retired user.
    
    /**
     * @ORM\Id
     * @ORM\Column(name="id")
     * @ORM\GeneratedValue
     */
    protected $id;

    /** 
     * @ORM\Column(name="email")  
     */
    protected $email;
    
    /** 
     * @ORM\Column(name="full_name")  
     */
    protected $fullName;

    /** 
     * @ORM\Column(name="password")  
     */
    protected $password;

    /** 
     * @ORM\Column(name="status")  
     */
    protected $status;
    
    /**
     * @ORM\Column(name="date_created")  
     */
    protected $dateCreated;
        
    /**
     * @ORM\Column(name="pwd_reset_token")  
     */
    protected $passwordResetToken;
    
    /**
     * @ORM\Column(name="pwd_reset_token_creation_date")  
     */
    protected $passwordResetTokenCreationDate;
    
    /**
     * Returns user ID.
     * @return integer
     */
    public function getId() 
    {
        return $this->id;
    }

    /**
     * Sets user ID. 
     * @param int $id    
     */
    public function setId($id) 
    {
        $this->id = $id;
    }

    /**
     * Returns email.     
     * @return string
     */
    public function getEmail() 
    {
        return $this->email;
    }

    /**
     * Sets email.     
     * @param string $email
     */
    public function setEmail($email) 
    {
        $this->email = $email;
    }
    
    /**
     * Returns full name.
     * @return string     
     */
    public function getFullName() 
    {
        return $this->fullName;
    }       

    /**
     * Sets full name.
     * @param string $fullName
     */
    public function setFullName($fullName) 
    {
        $this->fullName = $fullName;
    }
    
    /**
     * Returns status.
     * @return int     
     */
    public function getStatus() 
    {
        return $this->status;
    }

    /**
     * Returns possible statuses as array.
     * @return array
     */
    public static function getStatusList() 
    {
        return [
            self::STATUS_ACTIVE => 'Active',
            self::STATUS_RETIRED => 'Retired'
        ];
    }    
    
    /**
     * Returns user status as string.
     * @return string
     */
    public function getStatusAsString()
    {
        $list = self::getStatusList();
        if (isset($list[$this->status]))
            return $list[$this->status];
        
        return 'Unknown';
    }    
    
    /**
     * Sets status.
     * @param int $status     
     */
    public function setStatus($status) 
    {
        $this->status = $status;
    }   
    
    /**
     * Returns password.
     * @return string
     */
    public function getPassword() 
    {
       return $this->password; 
    }
    
    /**
     * Sets password.     
     * @param string $password
     */
    public function setPassword($password) 
    {
        $this->password = $password;
    }
    
    /**
     * Returns the date of user creation.
     * @return string     
     */
    public function getDateCreated() 
    {
        return $this->dateCreated;
    }
    
    /**
     * Sets the date when this user was created.
     * @param string $dateCreated     
     */
    public function setDateCreated($dateCreated) 
    {
        $this->dateCreated = $dateCreated;
    }    
    
    /**
     * Returns password reset token.
     * @return string
     */
    public function getResetPasswordToken()
    {
        return $this->passwordResetToken;
    }
    
    /**
     * Sets password reset token.
     * @param string $token
     */
    public function setPasswordResetToken($token) 
    {
        $this->passwordResetToken = $token;
    }
    
    /**
     * Returns password reset token's creation date.
     * @return string
     */
    public function getPasswordResetTokenCreationDate()
    {
        return $this->passwordResetTokenCreationDate;
    }
    
    /**
     * Sets password reset token's creation date.
     * @param string $date
     */
    public function setPasswordResetTokenCreationDate($date) 
    {
        $this->passwordResetTokenCreationDate = $date;
    }
}
~~~

Wie Sie dem obigen Code entnehmen können, ist die Entität *User* eine typische Doctrine-Entität mit
Klassenvariablen, die Annotations enthalten sowie Getter-und Setter-Methoden zum Abrufen/Setzen dieser Klassenvariablen.

## UserController hinzufügen

Die Klasse `UserController` enthält mehrere Aktionsmethoden, die Verwaltungsfunktionen und eine Benutzeroberfläche für die
zur Verwaltung der registrierten Benutzer bereitstellen. Sie hat folgenden Aktionen:

  * Die Aktion `indexAction()` zeigt eine Webseite mit einer Liste der Benutzer an (siehe Abbildung 16.3).
    Geben Sie "http://localhost/users" in die Navigationsleiste Ihres Webbrowsers ein, um auf diese Seite zuzugreifen.
  * Mit der Aktion `addAction()` wird eine Seite angezeigt, auf der Sie einen neuen Benutzer erstellen können (siehe Abbildung 16.4).
    Geben Sie "http://localhost/users/add" in die Navigationsleiste Ihres Webbrowsers ein, um auf diese Seite zuzugreifen.
  * Die Aktion `editAction()` zeigt eine Seite zum Aktualisieren eines vorhandenen Benutzers an (siehe Abbildung 16.5).
    Geben Sie "http://localhost/users/edit/&lt;id&gt;" in der Navigationsleiste Ihres Webbrowsers ein, um auf diese Seite zuzugreifen.
  * Die Aktion `viewAction()` ermöglicht die Anzeige eines vorhandenen Benutzers (siehe Abbildung 16.6).
    Geben Sie "http://localhost/users/view/&lt;id&gt;" in der Navigationsleiste Ihres Webbrowsers ein, um auf diese Seite zuzugreifen.
  * Die Aktion `changePasswordAction()` gibt dem Administrator die Möglichkeit, das Passwort eines vorhandenen Benutzers zu ändern (siehe Abbildung 16.7).
    Geben Sie "http://localhost/users/changePassword/&lt;id&gt;" in der Navigationsleiste Ihres Webbrowsers ein, um auf diese Seite zuzugreifen.
  * Mit der Aktion `resetPasswordAction()` kann ein Benutzer sein eigenes Passwort zurücksetzen (siehe Abbildung 16.8).
    Geben Sie "http://localhost/reset-password" in die Navigationsleiste Ihres Webbrowsers ein, um auf diese Seite zuzugreifen.
  
![Abbildung 16.3 Die Seite, auf der eine Liste der Benutzer angezeigt werden kann](images/users/users_page.png)

![Abbildung 16.4 Neuen Benutzer hinzufügen](images/users/add_user_page.png)

![Abbildung 16.5 Bearbeiten eines vorhandenen Benutzers](images/users/edit_user_page.png)

![Abbildung 16.6 Benutzerprofil](images/users/view_user_page.png)

![Abbildung 16.7 Benutzerpasswort ändern](images/users/change_password_page.png)

![Abbildung 16.8 Seite Passwort zurücksetzen](images/users/reset_password_page.png)

Die Controller-Klasse `UserController` soll möglichst "dünn" sein. Sie enthält nur den dafür zuständigen Code zum
prüfen der Eingabedaten, Instantiieren der benötigten Modelle, übergeben der Eingabedaten an die Modelle und zurückgeben der Ausgabedaten zum
Rendern in einem View-Template. Es ist eine typische Controller-Klasse.
Da Sie den vollständigen Code im Beispiel *User Demo* sehen können, werden wir ihn hier nicht näher beschreiben.

## Service UserManager hinzufügen

Der `UserController` arbeitet mit dem Service *UserManager* zusammen, der die gesamte Geschäftslogik für die Benutzerverwaltung enthält.
Der Service ermöglicht einem Administrator das Erstellen und Aktualisieren von Benutzern, das Ändern des Benutzerkennworts und das Zurücksetzen des Benutzerkennworts. Wir werden einige Teile davon 
ausführlicher beschreiben, wobei andere offensichtliche Teile weggelassen werden (Sie können den vollständigen Code immer im Beispiel *User Demo* sehen).

### Erstellen eines neuen Benutzers und Speichern des verschlüsselten Passworts

Die Methode `addUser()` des `UserManager` ermöglicht es uns, einen neuen Benutzer hinzuzufügen. Diese sieht wie folgt aus:

{line-numbers=on,lang=php}
~~~
/**
 * This method adds a new user.
 */
public function addUser($data) 
{
    // Do not allow several users with the same email address.
    if($this->checkUserExists($data['email'])) {
        throw new \Exception("User with email address " . 
                    $data['$email'] . " already exists");
    }
    
    // Create new User entity.
    $user = new User();
    $user->setEmail($data['email']);
    $user->setFullName($data['full_name']);        

    // Encrypt password and store the password in encrypted state.
    $bcrypt = new Bcrypt();
    $passwordHash = $bcrypt->create($data['password']);        
    $user->setPassword($passwordHash);
    
    $user->setStatus($data['status']);
    
    $currentDate = date('Y-m-d H:i:s');
    $user->setDateCreated($currentDate);        
            
    // Add the entity to the entity manager.
    $this->entityManager->persist($user);
    
    // Apply changes to database.
    $this->entityManager->flush();
    
    return $user;
}
~~~

Sie können in dieser Methode sehen, wie wir zuerst überprüfen, ob ein anderer Benutzer mit derselben E-Mail-Adresse
bereits vorhanden ist (Zeile 7). Wenn dies der Fall ist, verbieten wir die Erstellung des Benutzers durch das Auslösen einer Exception.

Wenn der Benutzer mit einer solchen E-Mail-Adresse nicht existiert, erstellen wir eine neue Entität `User` (Zeile 13) 
und setzen deren Klassenvariablen entsprechend.

Interessant ist hier, wie wir das Passwort des Benutzers in der Datenbank speichern. Aus Sicherheitsgründen speichern wir 
das Kennwort nicht so wie es ist sondern berechnen einen Hash davon mit der Klasse @`Bcrypt`, die von der
Zend Framework Komponente @`Zend\Crypt` bereitgestellt wird (Zeilen 18-19).

T> Sie können @`Zend\Crypt` mit dem folgenden Befehl installieren:
T>
T> 	`php composer.phar require zendframework/zend-crypt`
T>
T> Die Komponente @`Zend\Crypt` benötigt die PHP-Erweiterung `mcrypt`, welche installiert und aktiviert sein muss.

W> Der Algorithmus *Bcrypt* ist ein Hash-Algorithmus, der häufig von der Sicherheitsgemeinschaft zum Speichern des Benutzerpassworts verwendet wird.
W> Das Verschlüsseln des Passworts mit @`Bcrypt` gilt heutzutage als sicher. Einige Entwickler verschlüsseln immer noch Passwörter
W> mit MD5 oder SHA1 mit Salt. Dies wird jedoch nicht mehr als sicher betrachtet (MD5-und SHA1-Hashes können gehackt werden).

### Verschlüsselung des Passworts überprüfen

Wenn sich ein Benutzer anmeldet, müssen Sie überprüfen, ob der in der Datenbank, der gespeicherte Kennwort-Hash mit dem
berechnet Hash des vom Besucher eingegebenen Passwortes identisch ist. Sie tun dies mit Hilfe der bereitgestellten Methode `verify ()`
der Klasse @`Bcrypt` wie folgt:

{line-numbers=off,lang=php}
~~~
/**
 * Checks that the given password is correct.
 */
public function validatePassword($user, $password) 
{
    $bcrypt = new Bcrypt();
    $passwordHash = $user->getPassword();
    
    if ($bcrypt->verify($password, $passwordHash)) {
        return true;
    }
    
    return false;
}
~~~

### Benutzer Admin erstellen

Als Nächstes müssen Sie im Service `UserManager` beachten, wie wir den Admin-Benutzer erstellen.

I> Der Benutzer Admin ist ein Erstbenutzer, der automatisch erstellt wird, wenn keine Benutzer
I> in der Datenbank vorhanden sind und erlaubt Ihnen, sich zum ersten Mal anzumelden.

{line-numbers=off,lang=php}
~~~
/**
 * This method checks if at least one user presents, and if not, creates 
 * 'Admin' user with email 'admin@example.com' and password 'Secur1ty'. 
 */
public function createAdminUserIfNotExists()
{
    $user = $this->entityManager->getRepository(User::class)->findOneBy([]);
    if ($user==null) {
        $user = new User();
        $user->setEmail('admin@example.com');
        $user->setFullName('Admin');
        $bcrypt = new Bcrypt();
        $passwordHash = $bcrypt->create('Secur1ty');        
        $user->setPassword($passwordHash);
        $user->setStatus(User::STATUS_ACTIVE);
        $user->setDateCreated(date('Y-m-d H:i:s'));
        
        $this->entityManager->persist($user);
        $this->entityManager->flush();
    }
}
~~~

Wir setzen die E-Mail-Adresse des Admin-Benutzers auf `admin@example.com` und das Passwort auf `Secur1ty`, sodass Sie sich zuerst
damit anmelden können.

### Zurücksetzen des Benutzerpasswortes

Manchmal vergessen Benutzer ihr Passwort. In diesem Fall müssen Sie den Benutzer das Passwort zurücksetzen lassen
un das Passwort sicher ändern. Das Zurücksetzen des Passworts funktioniert wie folgt:

  * Ein zufälliges *Passwort-Reset-Token* wird generiert und sein Hash wird in der Datenbank gespeichert.
  * Das Token zum Zurücksetzen des Kennworts wird als Teil einer E-Mail-Nachricht an die E-Mail-Adresse des Benutzers gesendet.
  * Der Benutzer überprüft sein Postfach und klickt in der E-Mail-Nachricht auf den Link zum Zurücksetzen des Kennworts.
  * Die Website validiert das Passwort-Reset-Token und überprüft, ob es noch nicht abgelaufen ist.
  * Der Benutzer wird zu dem Formular geleitet, in dem er ein neues Passwort eingeben kann.

I> Sie speichern normalerweise keine rohen Kennwort-Reset-Token in der Datenbank. Stattdessen speichern Sie einen *Hash* des Tokens. Dies geschieht aus Sicherheitsgründen.
I> Auch wenn ein Angreifer die Datenbank stiehlt, können die Kennwörter der Benutzer nicht zurückgesetzt werden.
  
Der Algorithmus zur Generierung des Passwort-Reset-Token wird in der Methode `generatePasswordResetToken()` vom `UserManager` implementiert.
Um eine zufälligen String zu erzeugen, verwenden wir die Klasse @`Rand`, die von der Komponente @`Zend\Math` bereitgestellt wird.

{line-numbers=off,lang=php}
~~~
/**
 * Generates a password reset token for the user. This token is then stored in database and 
 * sent to the user's E-mail address. When the user clicks the link in E-mail message, he is 
 * directed to the Set Password page.
 */
public function generatePasswordResetToken($user)
{
    if ($user->getStatus() != User::STATUS_ACTIVE) {
        throw new \Exception('Cannot generate password reset token for inactive user ' . $user->getEmail());
    }
    
    // Generate a token.
    $token = Rand::getString(32, '0123456789abcdefghijklmnopqrstuvwxyz', true);
    
    // Encrypt the token before storing it in DB.
    $bcrypt = new Bcrypt();
    $tokenHash = $bcrypt->create($token);  
    
    // Save token to DB
    $user->setPasswordResetToken($tokenHash);
    
    // Save token creation date to DB.
    $currentDate = date('Y-m-d H:i:s');
    $user->setPasswordResetTokenCreationDate($currentDate);  
    
    // Apply changes to DB.
    $this->entityManager->flush();
    
    // Send an email to user.
    $subject = 'Password Reset';
        
    $httpHost = isset($_SERVER['HTTP_HOST'])?$_SERVER['HTTP_HOST']:'localhost';
    $passwordResetUrl = 'http://' . $httpHost . '/set-password?token=' . $token . "&email=" . $user->getEmail();
    
    // Produce HTML of password reset email
    $bodyHtml = $this->viewRenderer->render(
            'user/email/reset-password-email',
            [
                'passwordResetUrl' => $passwordResetUrl,
            ]);
    
    $html = new MimePart($bodyHtml);
    $html->type = "text/html";
    
    $body = new MimeMessage();
    $body->addPart($html);
    
    $mail = new Mail\Message();
    $mail->setEncoding('UTF-8');
    $mail->setBody($body);
    $mail->setFrom('no-reply@example.com', 'User Demo');
    $mail->addTo($user->getEmail(), $user->getFullName());
    $mail->setSubject($subject);
    
    // Setup SMTP transport
    $transport = new SmtpTransport();
    $options   = new SmtpOptions($this->config['smtp']);
    $transport->setOptions($options);

    $transport->send($mail);
}
~~~

I> Die Konfiguration des E-Mail-System für Ihren Webserver benötigt
I> ein Abonnement eines Mail-Dienstes (wie [SendGrid](https://sendgrid.com/) oder [Amazon SES](https://aws.amazon.com/de/ses)).

Die Überprüfung des Token zum Zurücksetzen des Kennworts ist in der Methode `validatePasswordResetToken()` implementiert.
Wir überprüfen, dass der Hash des Tokens derselbe ist, den wir in der Datenbank gespeichert haben und dass das Tokens nicht abgelaufen ist
(es verfällt 1 Tag nach der Erstellung).

{line-numbers=off,lang=php}
~~~
/**
 * Checks whether the given password reset token is a valid one.
 */
public function validatePasswordResetToken($email, $passwordResetToken)
{
    // Find user by email.
    $user = $this->entityManager->getRepository(User::class)
            ->findOneByEmail($email);
    
    if($user==null || $user->getStatus() != User::STATUS_ACTIVE) {
        return false;
    }
    
    // Check that token hash matches the token hash in our DB.
    $bcrypt = new Bcrypt();
    $tokenHash = $user->getPasswordResetToken();
    
    if (!$bcrypt->verify($passwordResetToken, $tokenHash)) {
        return false; // mismatch
    }
    
    // Check that token was created not too long ago.
    $tokenCreationDate = $user->getPasswordResetTokenCreationDate();
    $tokenCreationDate = strtotime($tokenCreationDate);
    
    $currentDate = strtotime('now');
    
    if ($currentDate - $tokenCreationDate > 24*60*60) {
        return false; // expired
    }
    
    return true;
}
~~~

Und schließlich kann mit der Methode `setPasswordByToken()` ein neues Passwort für den Benutzer festgelegt werden.

{line-numbers=off,lang=php}
~~~
/**
 * This method sets new password by password reset token.
 */
public function setNewPasswordByToken($email, $passwordResetToken, $newPassword)
{
    if (!$this->validatePasswordResetToken($email, $passwordResetToken)) {
       return false; 
    }
    
    // Find user with the given email.
    $user = $this->entityManager->getRepository(User::class)
            ->findOneByEmail($email);
    
    if ($user==null || $user->getStatus() != User::STATUS_ACTIVE) {
        return false;
    }
            
    // Set new password for user        
    $bcrypt = new Bcrypt();
    $passwordHash = $bcrypt->create($newPassword);        
    $user->setPassword($passwordHash);
            
    // Remove password reset token
    $user->setPasswordResetToken(null);
    $user->setPasswordResetTokenCreationDate(null);
    
    $this->entityManager->flush();
    
    return true;
}
~~~

## Benutzerauthentifizierung implementieren

*Authentifizierung* ist der Vorgang, der ausgeführt wird, wenn ein Benutzer seinen Benutzernamen und sein Kennwort angibt und Sie entscheiden, ob diese Anmeldeinformationen
richtig sind. Authentifizierung bedeutet in der Regel, dass Sie Ihre Datenbank auf das angegebene Login überprüfen. Wenn ein solches Login vorhanden ist,
prüfet man, ob der anhand des angegebenen Passworts berechnete Hash mit dem Hash des in der Datenbank gespeicherten Passworts übereinstimmt.

I> Sie speichern normalerweise keine rohen Passwörter in der Datenbank. Stattdessen speichern Sie einen *Hash* des Passwortes. 
I> Dies geschieht aus Sicherheitsgründen.

Sobald der Authentifizierungsalgorithmus feststellt, dass Login und Passwort korrekt sind, wird die *Benutzerindentität* zurückgegeben - ein eindeutiger Name oder
die ID des Benutzers. Die Identität wird normalerweise in einer Session gespeichert, sodass der Besucher nicht für jeden HTTP-Request 
eine Authentifizierung durchführen muss.

In ZF3 gibt es eine spezielle Komponente, mit der Sie die Benutzerauthentifizierung implementieren können - @`Zend\Authentication`.
Sie können diese Komponente mit Composer installieren, indem Sie den folgenden Befehl eingeben:

```
php composer.phar require zendframework/zend-authentication
```

T> Damit die Authentifizierung funktioniert, müssen Sie auch die @ Zend \ Session-Komponente installieren und den Session Manager konfigurieren. Zur Information
Weitere Informationen hierzu finden Sie im Kapitel [Arbeiten mit Sitzungen] (# session).

### AuthenticationService

Die Komponente @`Zend\Authentication stellt die besondere Serviceklasse namens `AuthenticationService` bereit, welche sich
im Namesraum @`Zend\Authentication` befindet. Die nützlichsten Methoden dieses Service sind in der folgenden Tabelle 16.1 aufgeführt.

{title="Tabelle 16.1. Methoden der Klasse AuthenticationService"}
|-------------------|-----------------------------------------------------------------------------------------------------------|
| *Methode* 		| *Beschreibung* 																							|
|-------------------|-----------------------------------------------------------------------------------------------------------|
| `authenticate()` 	| Führt die Benutzerauthentifizierung mithilfe des Adapters durch. 											|
|-------------------|-----------------------------------------------------------------------------------------------------------|
| `getAdapter()` 	| Gibt den Authentifizierungsadapter zurück. 																|
|-------------------|-----------------------------------------------------------------------------------------------------------|
| `setAdapter()` 	| Setzt den Authentifizierungsadapter, der den tatsächlichen Authentifizierungsalgorithmus implementiert.	|
|-------------------|-----------------------------------------------------------------------------------------------------------|
| `getStorage()` 	| Gibt den Speicher-Handler zurück. 																		|
|-------------------|-----------------------------------------------------------------------------------------------------------|
| `setStorage()` 	| Setzt den Speicher-Handler. 																				|
|-------------------|-----------------------------------------------------------------------------------------------------------|
| `hasIdentity()` 	| Gibt `true` zurück, wenn die Benutzeridentität bereits in der Session gespeichert ist. 					|
|-------------------|-----------------------------------------------------------------------------------------------------------|
| `getIdentity()` 	| Gibt die Benutzeridentität aus der Session zurück. 														|
|-------------------|-----------------------------------------------------------------------------------------------------------|
| `clearIdentity()`	| Löscht die Benutzeridentität aus der Session. 															|
|-------------------|-----------------------------------------------------------------------------------------------------------|

Wie Sie der Tabelle entnehmen können, können Sie die Methode `authenticate()` verwenden, um die Benutzerauthentifizierung durchzuführen.
Außerdem können Sie die Methoden `hasIdentity()`, `getIdentity()` und `clearIdentity()` zum Testen, 
Abrufen bzw. Löschen der Benutzeridentität verwenden.

Der Service @`AuthenticationService` ist jedoch sehr allgemein - er weiß nicht, wie
der Login und Passwort tatsächlich mit der Datenbank abzugleichen ist. Es weiß auch nicht, wie die Benutzeridentität in der Session
gespeichert werden soll. Mit diesem Design können Sie jeden geeigneten Authentifizierungsalgorithmus und jeden geeigneten Speicher implementieren.

Die Komponente @`Zend\Authentication` stellt mehrere *Authentifizierungsadapter* bereit, die einige Standardauthentifizierungen Algorithmen 
implementieren (siehe Abbildung 16.9) und mehrere *Speicher-Handler*, mit denen Sie die Benutzeridentität speichern und abrufen können (siehe Abbildung 16.10).

![Abbildung 16.9 Standard-Authentifizierungsadapter](images/users/std_auth_adapters.png)

![Abbildung 16.10 Standardspeicher-Handler](images/users/std_auth_storage_handlers.png)

Für unsere Zwecke können wir den Speicher-Handler @`Session`[Zend\Authentication\Storage\Session] verwenden, ohne Code ändern zu müssen. Der Adapter für 
die Standardauthentifizierung ist für uns nicht geeignet, da wir Doctrine ORM verwenden. Wir müssen unseren benutzerdefinierten Authentifizierungsadapter schreiben.
Zum Glück ist das ziemlich einfach.

### Authentifizierungsadapter schreiben

Ein Authentifizierungsadapter muss die Schnittstelle @`AdapterInterface`[Zend\Authentication\Adapter\AdapterInterface] implementieren, die über die einzige Methode `authenticate()` verfügt.
Diese Methode sollte die E-Mail-Adresse und das Kennwort des Benutzers anhand der Datenbank überprüfen. Wir machen das wie folgt:

  * Finden Sie den Benutzer mit der angegebenen `email` (wir verwenden die E-Mail-Adresse als Login des Benutzers).
  * Wenn ein Benutzer mit einer solchen `email` nicht existiert, wird der Fehlerstatus zurückgegeben.
  * Überprüfen Sie den `status` des Benutzers. Wenn der Benutzer "retired" (Ruhestand) ist, kann der Benutzer sich nicht anmelden.
  * Passwort-Hash berechnen und mit dem in der Datenbank gespeicherten Hash für den gefundenen Benutzer vergleichen.
  * Wenn der Passwort-Hash nicht übereinstimmt, geben Sie den Fehlerstatus zurück.
  * Wenn das Passwort korrekt ist, geben Sie den Erfolgsstatus zurück.
  
Die Methode `authenticate()` gibt eine Instanz der Klasse @`Zend\Authentication\Result` zurück.
Die Klasse @`Result`[Zend\Authentication\Result] enthält den Authentifizierungsstatus, die Fehlernachricht und die Benutzeridentität.

Der Adapter kann auch zusätzliche Methoden haben. Zum Beispiel fügen wir die Methoden `setEmail()` und `setPassword()` hinzu.
Diese wir verwenden, um die E-Mail-Adresse und das Passwort des Benutzers an den Adapter zu übergeben.

Erstellen Sie für den Authentifizierungsadapters die Datei *AuthAdapter.php* im Verzeichnis *Service* des Quellverzeichnisses des Moduls.

I> Im Beispiel *User Demo* erstellen wir ein separates Modul mit dem Namen *User* und fügen Funktionen zur Authentifizierung
I> und Benutzerverwaltung für dieses Modul hinzu.

Fügen Sie den folgenden Code in diese Datei ein:

{line-numbers=off,lang=php}
~~~
<?php
namespace User\Service;

use Zend\Authentication\Adapter\AdapterInterface;
use Zend\Authentication\Result;
use Zend\Crypt\Password\Bcrypt;
use User\Entity\User;

/**
 * Adapter used for authenticating user. It takes login and password on input
 * and checks the database if there is a user with such login (email) and password.
 * If such user exists, the service returns his identity (email). The identity
 * is saved to session and can be retrieved later with Identity view helper provided
 * by ZF3.
 */
class AuthAdapter implements AdapterInterface
{
    /**
     * User email.
     * @var string 
     */
    private $email;
    
    /**
     * Password
     * @var string 
     */
    private $password;
    
    /**
     * Entity manager.
     * @var Doctrine\ORM\EntityManager 
     */
    private $entityManager;
        
    /**
     * Constructor.
     */
    public function __construct($entityManager)
    {
        $this->entityManager = $entityManager;
    }
    
    /**
     * Sets user email.     
     */
    public function setEmail($email) 
    {
        $this->email = $email;        
    }
    
    /**
     * Sets password.     
     */
    public function setPassword($password) 
    {
        $this->password = (string)$password;        
    }
    
    /**
     * Performs an authentication attempt.
     */
    public function authenticate()
    {                
        // Check the database if there is a user with such email.
        $user = $this->entityManager->getRepository(User::class)
                ->findOneByEmail($this->email);
        
        // If there is no such user, return 'Identity Not Found' status.
        if ($user==null) {
            return new Result(
                Result::FAILURE_IDENTITY_NOT_FOUND, 
                null, 
                ['Invalid credentials.']);        
        }   
        
        // If the user with such email exists, we need to check if it is active or retired.
        // Do not allow retired users to log in.
        if ($user->getStatus()==User::STATUS_RETIRED) {
            return new Result(
                Result::FAILURE, 
                null, 
                ['User is retired.']);        
        }
        
        // Now we need to calculate hash based on user-entered password and compare
        // it with the password hash stored in database.
        $bcrypt = new Bcrypt();
        $passwordHash = $user->getPassword();
        
        if ($bcrypt->verify($this->password, $passwordHash)) {
            // Great! The password hash matches. Return user identity (email) to be
            // saved in session for later use.
            return new Result(
                    Result::SUCCESS, 
                    $this->email, 
                    ['Authenticated successfully.']);        
        }             
        
        // If password check didn't pass return 'Invalid Credential' failure status.
        return new Result(
                Result::FAILURE_CREDENTIAL_INVALID, 
                null, 
                ['Invalid credentials.']);        
    }
}
~~~

### Factory des AuthenticationService erstellen

Sobald wir den Adapter implementiert haben, können wir den Service @`AuthenticationService` erstellen.
ZF3's @`AuthenticationService` sollte im Service-Manager registriert werden, bevor wir ihn verwenden können.
Zunächst etsellen wir eine Factory dafür. Erstellen Sie die Datei *AuthenticationServiceFactory.php*
im Verszeichnis *Service/Factory* und geben Sie den folgenden Code dort ein:

{line-numbers=off,lang=php}
~~~
<?php
namespace User\Service\Factory;

use Interop\Container\ContainerInterface;
use Zend\Authentication\AuthenticationService;
use Zend\ServiceManager\Factory\FactoryInterface;
use Zend\Session\SessionManager;
use Zend\Authentication\Storage\Session as SessionStorage;
use User\Service\AuthAdapter;

/**
 * The factory responsible for creating of authentication service.
 */
class AuthenticationServiceFactory implements FactoryInterface
{
    /**
     * This method creates the Zend\Authentication\AuthenticationService service 
     * and returns its instance. 
     */
    public function __invoke(ContainerInterface $container, 
                    $requestedName, array $options = null)
    {
        $sessionManager = $container->get(SessionManager::class);
        $authStorage = new SessionStorage('Zend_Auth', 'session', $sessionManager);
        $authAdapter = $container->get(AuthAdapter::class);

        // Create the service and inject dependencies into its constructor.
        return new AuthenticationService($authStorage, $authAdapter);
    }
}
~~~

In der Factory machen wir Folgendes: Zuerst erstellen wir eine Instanz des Session-Managers (den Sie bereits
eingerichtet haben) und erstellen Sie eine Instanz des Speicher-Handlers @`Session`[Zend\Authentication\Storage\Session]. Dann erstellen wir
eine Instanz von `AuthAdapter`. Zum Schluss instanziieren wir den Service @`AuthenticationService` und setzen die Abhängigkeiten
(Speicher-Handler und Adapter).

Registrieren Sie den Service @`AuthenticationService` in Ihrer Konfigurationsdatei *module.config.php* wie folgt:

{line-numbers=off,lang=php}
~~~
<?php 
return [
    'service_manager' => [
        'factories' => [
            \Zend\Authentication\AuthenticationService::class 
                => Service\Factory\AuthenticationServiceFactory::class,
            // ...
        ],
    ],
];
~~~

### AuthController hinzufügen

Die Klasse `AuthController` hat zwei Aktionen:

  * Die Aktion `loginAction()` erlaubt das Einloggen in die Website (siehe Abbildungen 16.11 und 16.12).
    Sie können auf diese Seite zugreifen, indem Sie die URL "http://localhost/login" in die Navigationsleiste Ihres Webbrowsers eingeben.
    
  * Die Aktion `logoutAction()` ermöglicht das Abmelden von der Website.
    Sie können auf diese Seite zugreifen, indem Sie in der Navigationsleiste Ihres Webbrowsers die URL "http://localhost/logout" eingeben.
    
![Abbildung 16.11 Anmeldeseite](images/users/login_page.png)

![Abbildung 16.12 Anmeldeseite - Ungültige Anmeldeinformationen](images/users/login_page_errors.png)

Der Code der Controller-Klasse `AuthController` wird im Folgenden dargestellt:

{line-numbers=off,lang=php}
~~~
<?php

namespace User\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Zend\Authentication\Result;
use Zend\Uri\Uri;
use User\Form\LoginForm;
use User\Entity\User;

/**
 * This controller is responsible for letting the user to log in and log out.
 */
class AuthController extends AbstractActionController
{
    /**
     * Entity manager.
     * @var Doctrine\ORM\EntityManager 
     */
    private $entityManager;
    
    /**
     * Auth manager.
     * @var User\Service\AuthManager 
     */
    private $authManager;
    
    /**
     * Auth service.
     * @var \Zend\Authentication\AuthenticationService
     */
    private $authService;
    
    /**
     * User manager.
     * @var User\Service\UserManager
     */
    private $userManager;
    
    /**
     * Constructor.
     */
    public function __construct($entityManager, $authManager, $authService, $userManager)
    {
        $this->entityManager = $entityManager;
        $this->authManager = $authManager;
        $this->authService = $authService;
        $this->userManager = $userManager;
    }
    
    /**
     * Authenticates user given email address and password credentials.     
     */
    public function loginAction()
    {
        // Retrieve the redirect URL (if passed). We will redirect the user to this
        // URL after successfull login.
        $redirectUrl = (string)$this->params()->fromQuery('redirectUrl', '');
        if (strlen($redirectUrl)>2048) {
            throw new \Exception("Too long redirectUrl argument passed");
        }
        
        // Check if we do not have users in database at all. If so, create 
        // the 'Admin' user.
        $this->userManager->createAdminUserIfNotExists();
        
        // Create login form
        $form = new LoginForm(); 
        $form->get('redirect_url')->setValue($redirectUrl);
        
        // Store login status.
        $isLoginError = false;
        
        // Check if user has submitted the form
        if ($this->getRequest()->isPost()) {
            
            // Fill in the form with POST data
            $data = $this->params()->fromPost();            
            
            $form->setData($data);
            
            // Validate form
            if($form->isValid()) {
                
                // Get filtered and validated data
                $data = $form->getData();
                
                // Perform login attempt.
                $result = $this->authManager->login($data['email'], 
                        $data['password'], $data['remember_me']);
                
                // Check result.
                if ($result->getCode()==Result::SUCCESS) {
                    
                    // Get redirect URL.
                    $redirectUrl = $this->params()->fromPost('redirect_url', '');
                    
                    if (!empty($redirectUrl)) {
                        // The below check is to prevent possible redirect attack 
                        // (if someone tries to redirect user to another domain).
                        $uri = new Uri($redirectUrl);
                        if (!$uri->isValid() || $uri->getHost()!=null)
                            throw new \Exception('Incorrect redirect URL: ' . $redirectUrl);
                    }

                    // If redirect URL is provided, redirect the user to that URL;
                    // otherwise redirect to Home page.
                    if(empty($redirectUrl)) {
                        return $this->redirect()->toRoute('home');
                    } else {
                        $this->redirect()->toUrl($redirectUrl);
                    }
                } else {
                    $isLoginError = true;
                }                
            } else {
                $isLoginError = true;
            }           
        } 
        
        return new ViewModel([
            'form' => $form,
            'isLoginError' => $isLoginError,
            'redirectUrl' => $redirectUrl
        ]);
    }
    
    /**
     * The "logout" action performs logout operation.
     */
    public function logoutAction() 
    {        
        $this->authManager->logout();
        
        return $this->redirect()->toRoute('login');
    }
}
~~~

Die Methode `loginAction()` akzeptiert den GET-Parameter `redirectUrl`. Die "Weiterleitungs-URL" ist eine angenehme
Funktion, die mit dem *Zugriffsfilter* arbeitet, der später in diesem Kapitel beschrieben wird. Wenn der
Besucher versucht, auf eine Webseite zuzugreifen, die der Zugriffsfilter verbietet, wird der Besucher auf die Seite "Login" 
umgeleitet, welche als URL der Originalseite als "Weiterleitungs-URL" übergeben wurde. Wenn sich der Benutzer anmeldet, wird er
automatisch zur ursprünglichen Seite zurückgeleitet, wodurch die Benutzererfahrung verbessert wird.

### Hinzufügen eines View-Templates für die Anmeldeseite

Das View-Template (eine *.phtml* -Datei) für unsere *Login* Seite sieht wie folgt aus:

{line-numbers=off,lang=php}
~~~
<?php
$this->headTitle('Sign in');

$this->mainMenu()->setActiveItemId('login');

$form->get('email')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Email address',
    'required' => true,
    'autofocus' => true
    ])
    ->setLabelAttributes([
        'class' => 'sr-only'
    ]);

$form->get('password')->setAttributes([
    'class'=>'form-control', 
    'placeholder'=>'Password',
    'required' => true,
    ])
    ->setLabelAttributes([
        'class' => 'sr-only'
    ]);
?>

<div class="row">
    <div class="col-md-offset-4 col-md-3">
        <form class="form-signin" method="post">
            <h2 class="form-signin-heading">Please sign in</h2>
            <?php if ($isLoginError): ?>
            <div class="alert alert-warning" role="alert">
                Incorrect login and/or password. 
                <a href="<?= $this->url('reset-password') ?>">Forgot password?</a>
            </div>
            <?php endif; ?>
            <?= $this->formLabel($form->get('email')); ?>
            <?= $this->formElement($form->get('email')); ?>
            <?= $this->formLabel($form->get('password')); ?>
            <?= $this->formElement($form->get('password')); ?>
            <div class="checkbox">
                <label>
                    <?= $this->formElement($form->get('remember_me')); ?> Remember me
                </label>
            </div>
            <?= $this->formElement($form->get('redirect_url')); ?>
            <?= $this->formElement($form->get('csrf')) ?>
            <button class="btn btn-lg btn-primary btn-block" type="submit">Sign in</button>
        </form>
    </div>
</div>
~~~

T> Das View-Template verwendet die von Bootstrap CSS Framework bereitgestellte Seitenvorlage *Sign In*.
T> Sie finden die Originalvorlage [hier](https://getbootstrap.com/examples/signin/).

### Service AuthManager hinzufügen

Der `AuthController` arbeitet mit dem Service `AuthManager` zusammen. Die wichtigste Geschäftslogik hinter der Authentifizierung
ist im Service implementiert. Beschreiben wir den `AuthManager` ausführlich.

Der Service `AuthManager` hat die folgenden Authentifizierungsmethoden:

  * Die Methode `login()` und
  * die Methode `logout()`.

Die Methode `login()` (siehe unten) verwendet den @`AuthenticationService` von ZF3 und den `AuthAdapter`, den wir zuvor für die
Benutzerauthentifizierung geschrieben haben. Die Methode akzeptiert zusätzlich das Argument `$rememberMe`, welches
die Lebensdauer des Session-Cookies auf 30 Tage verlängert.

{line-numbers=off,lang=php}
~~~
/**
 * Performs a login attempt. If $rememberMe argument is true, it forces the session
 * to last for one month (otherwise the session expires on one hour).
 */
public function login($email, $password, $rememberMe)
{   
    // Check if user has already logged in. If so, do not allow to log in 
    // twice.
    if ($this->authService->getIdentity()!=null) {
        throw new \Exception('Already logged in');
    }
        
    // Authenticate with login/password.
    $authAdapter = $this->authService->getAdapter();
    $authAdapter->setEmail($email);
    $authAdapter->setPassword($password);
    $result = $this->authService->authenticate();

    // If user wants to "remember him", we will make session to expire in 
    // one month. By default session expires in 1 hour (as specified in our 
    // config/global.php file).
    if ($result->getCode()==Result::SUCCESS && $rememberMe) {
        // Session cookie will expire in 1 month (30 days).
        $this->sessionManager->rememberMe(60*60*24*30);
    }
    
    return $result;
}
~~~

Die Methode `logout()` löscht die Benutzeridentität aus der Session, sodass der Besucher nicht authentifiziert wird.

{line-numbers=off,lang=php}
~~~
/**
 * Performs user logout.
 */
public function logout()
{
    // Allow to log out only when user is logged in.
    if ($this->authService->getIdentity()==null) {
        throw new \Exception('The user is not logged in');
    }
    
    // Remove identity from session.
    $this->authService->clearIdentity();               
}
~~~

## Zugriffsfilterung

Das letzte, was wir im Modul `User` implementieren, ist der *Zugriffsfilter*. Der Zugriffsfilter wird für die
Beschränkung des Zugriffs auf bestimmte Webseiten verwendet, auf die nur authentifizierte Benutzer Zugriff haben.

Der Zugriffsfilter funktioniert wie folgt:

  * Wenn jemand versucht, auf eine Webseite zuzugreifen, überprüfen Sie den Schlüssel `access_filter` der Anewendungskonfiguration, 
    ob diese Seite von allen Besuchern oder nur von authentifizierten Benutzern zugänglich ist.
  
  * Wenn die Seite von jedermann aufgerufen werden darf, lassen wir den Besucher die Seite sehen.

  * Wenn nur authentifizierte Benutzer auf die Seite zugreifen dürfen, überprüfen wir, ob der Benutzer authentifiziert ist oder nicht.

  * Wenn der Benutzer nicht authentifiziert ist, leiten wir ihn auf die Seite *Login* um und bitten ihn um Anmeldung.

  * Wenn sich der Benutzer angemeldet hat, leiten wir ihn automatisch zur ursprünglichen Seite zurück.
  
Der Zugriffsfilter funktioniert in einem von zwei Modi: restriktiv (Standard) und permissiv. Im restriktiven Modus
verbietet der Filter den Zugriff auf eine Seite, die nicht unter dem Schlüssel `access_filter` aufgeführt ist.
  
Der Konfigurationsschlüssel `access_filter` befindet sich in der Datei *module.config.php* und wird
durch den Zugriffsfilter verwendet. Er enthält die Liste der Controller und Aktionsnamen.
Durch diese Aktion kann jeder die Seite sehen oder nur authentifizierte Benutzer wird die Seite angezeigt. Eine Beispielstruktur
des Schlüssels wird unten dargestellt:

{line-numbers=off,lang=php}
~~~
// The 'access_filter' key is used by the User module to restrict or permit
// access to certain controller actions for unauthenticated visitors.
'access_filter' => [
    'options' => [
        // The access filter can work in 'restrictive' (recommended) or 'permissive'
        // mode. In restrictive mode all controller actions must be explicitly listed 
        // under the 'access_filter' config key, and access is denied to any not listed 
        // action for users not logged in. In permissive mode, if an action is not listed 
        // under the 'access_filter' key, access to it is permitted to anyone (even for 
        // users not logged in. Restrictive mode is more secure and recommended.
        'mode' => 'restrictive'
    ],
    'controllers' => [
        Controller\IndexController::class => [
            // Allow anyone to visit "index" and "about" actions
            ['actions' => ['index', 'about'], 'allow' => '*'],
            // Allow authenticated users to visit "settings" action
            ['actions' => ['settings'], 'allow' => '@']
        ],
    ]
],
~~~ 

Unter dem Schlüssel `access_filter` haben wir zwei Unterschlüssel:

  * Mit der Schlüssel `options` kann festgelegt werden, in welchem ​​Modus der Filter funktioniert ("restriktiv" oder "permissiv").
  * Der Schlüssel `controllers` listet die Controller und ihre Aktionen auf und gibt den Zugriffstyp für jede Aktion an. Das Sternchen
    (*) bedeutet, dass jeder auf die Webseite zugreifen kann. Das "at"-Zeichen (@) bedeutet, dass nur authentifizierte
    Benutzer auf die Seite zugreifen können.

I> Die Access-Filter-Implementierung ist sehr einfach. Er kann keinen Zugriff basierend auf einen Benutzernamen oder einer Benutzerrolle zulassen.
I> Sie können ihn nach Ihren Wünschen ändern und erweitern. Wenn Sie die rollenbasierte Zugriffssteuerung (RBAC) einführen möchten, lesen Sie das
I> Kapitel [Rollenbasierte Zugriffskontrolle](#roles).
    
### Hinzufügen eines Dispatch-Event-Listener
  
Um die Zugriffsfilterung zu implementieren, verwenden wir einen Event-Listener. Wir haben uns bereits mit dem Event-Listing
im Kapitel [Ein neues Modul erstellen](#modules) vertraut gemacht.

Das Event *Dispatch* wird nach dem Event *Route* ausgelöst, wenn der
Controller und die Aktion bereits gesetzt sind. Um den Listener zu implementieren, ändern wir die Datei *Module.php* des Moduls *User*
wie folgt:

{line-numbers=off,lang=php}
~~~
<?php
namespace User;

use Zend\Mvc\MvcEvent;
use Zend\Mvc\Controller\AbstractActionController;
use User\Controller\AuthController;
use User\Service\AuthManager;

class Module
{
    /**
     * This method returns the path to module.config.php file.
     */
    public function getConfig()
    {
        return include __DIR__ . '/../config/module.config.php';
    }
    
    /**
     * This method is called once the MVC bootstrapping is complete and allows
     * to register event listeners. 
     */
    public function onBootstrap(MvcEvent $event)
    {
        // Get event manager.
        $eventManager = $event->getApplication()->getEventManager();
        $sharedEventManager = $eventManager->getSharedManager();
        // Register the event listener method. 
        $sharedEventManager->attach(AbstractActionController::class, 
                MvcEvent::EVENT_DISPATCH, [$this, 'onDispatch'], 100);
    }
    
    /**
     * Event listener method for the 'Dispatch' event. We listen to the Dispatch
     * event to call the access filter. The access filter allows to determine if
     * the current visitor is allowed to see the page or not. If he/she
     * is not authenticated and is not allowed to see the page, we redirect the user 
     * to the login page.
     */
    public function onDispatch(MvcEvent $event)
    {
        // Get controller and action to which the HTTP request was dispatched.
        $controller = $event->getTarget();
        $controllerName = $event->getRouteMatch()->getParam('controller', null);
        $actionName = $event->getRouteMatch()->getParam('action', null);
        
        // Convert dash-style action name to camel-case.
        $actionName = str_replace('-', '', lcfirst(ucwords($actionName, '-')));
        
        // Get the instance of AuthManager service.
        $authManager = $event->getApplication()->getServiceManager()->get(AuthManager::class);
        
        // Execute the access filter on every controller except AuthController
        // (to avoid infinite redirect).
        if ($controllerName!=AuthController::class && 
            !$authManager->filterAccess($controllerName, $actionName)) {
            
            // Remember the URL of the page the user tried to access. We will
            // redirect the user to that URL after successful login.
            $uri = $event->getApplication()->getRequest()->getUri();
            // Make the URL relative (remove scheme, user info, host name and port)
            // to avoid redirecting to other domain by a malicious user.
            $uri->setScheme(null)
                ->setHost(null)
                ->setPort(null)
                ->setUserInfo(null);
            $redirectUrl = $uri->toString();
            
            // Redirect the user to the "Login" page.
            return $controller->redirect()->toRoute('login', [], 
                    ['query'=>['redirectUrl'=>$redirectUrl]]);
        }
    }
}
~~~

### Implementieren des Zugriffsfilter-Algorithmus

Der Event-Listener `onDispatch()` ruft die Methode `filterAccess()` des Service `AuthManager` auf, um zu ermitteln,
ob die Seite sichtbar ist oder nicht. Der Code der Methode `filterAccess()` ist unten dargestellt:

{line-numbers=off,lang=php}
~~~
/**
 * This is a simple access control filter. It allows vistors to visit certain pages only,
 * the rest requiring the user to be authenticated. 
 * 
 * This method uses the 'access_filter' key in the config file and determines
 * whenther the current visitor is allowed to access the given controller action
 * or not. It returns true if allowed; otherwise false.
 */
public function filterAccess($controllerName, $actionName)
{
    // Determine mode - 'restrictive' (default) or 'permissive'. In restrictive
    // mode all controller actions must be explicitly listed under the 'access_filter'
    // config key, and access is denied to any not listed action for unauthenticated users. 
    // In permissive mode, if an action is not listed under the 'access_filter' key, 
    // access to it is permitted to anyone (even for not logged in users.
    // Restrictive mode is more secure and recommended to use.
    $mode = isset($this->config['options']['mode'])?$this->config['options']['mode']:'restrictive';
    if ($mode!='restrictive' && $mode!='permissive')
        throw new \Exception('Invalid access filter mode (expected either restrictive or permissive mode');
    
    if (isset($this->config['controllers'][$controllerName])) {
        $items = $this->config['controllers'][$controllerName];
        foreach ($items as $item) {
            $actionList = $item['actions'];
            $allow = $item['allow'];
            if (is_array($actionList) && in_array($actionName, $actionList) ||
                $actionList=='*') {
                if ($allow=='*')
                    return true; // Anyone is allowed to see the page.
                else if ($allow=='@' && $this->authService->hasIdentity()) {
                    return true; // Only authenticated user is allowed to see the page.
                } else {                    
                    return false; // Access denied.
                }
            }
        }            
    }
    
    // In restrictive mode, we forbid access for authenticated users to any 
    // action not listed under 'access_filter' key (for security reasons).
    if ($mode=='restrictive' && !$this->authService->hasIdentity())
        return false;
    
    // Permit access to this page.
    return true;
}
~~~

### Testen des Zugriffsfilters

Um den Zugriffsfilter zu testen, besuchen Sie die Seite "http://localhost/users" oder "http://localhost/settings", wenn Sie nicht angemeldet sind. Der Zugriffsfilter
führt Sie zur Seite *Login*. Sie können jedoch problemlos die Seite "http://localhost/about" besuchen. Sie ist für jedermann zugänglich.

##  Controller-Plugin Identity und View-Helper

Eine letzte Sache, die wir besprechen werden, ist, wie Sie prüfen können, ob ein Benutzer angemeldet ist
oder nicht und die Benutzeridentität abrufen. Sie können dies mit Hilfe des Controller-Plugins @`Identity`[Zend\Mvc\Plugin\Identity] und des View-Helpers @`Identity`[Zend\View\Helper\Identity] tun.

I> Um das Controller-Plugin @`Identity`[Zend\Mvc\Plugin\Identity] verwenden zu können, müssen Sie das Paket `zendframework/zend-mvc-plugins` mit Composer wie folgt installieren:
I>
I> `php composer.phar require zendframework/zend-mvc-plugins`

In Ihrer Controller-Aktionsmethode können Sie mit folgendem Code überprüfen, ob der Benutzer angemeldet ist:

{line-numbers=off,lang=php}
~~~
if ($this->identity()!=null) {
    // User is logged in
    
    // Retrieve user identity
    $userEmail = $this->identity();
}
~~~
 
In Ihrem View-Template können Sie den View-Helper @`Identity`[Zend\View\Helper\Identity] für denselben Zweck verwenden:

{line-numbers=off,lang=php}
~~~
// Echo user identity
<?= $this->escapeHtml($this->identity()) ?>
~~~ 
 
## Zusammenfassung

In diesem Kapitel haben wir die Benutzerverwaltung, die Benutzerauthentifizierung und die Zugriffsfilterung kennen gelernt.

Benutzerverwaltung bedeutet, die Bereitstellung einer Benutzeroberfläche zum Hinzufügen, Bearbeiten, Anzeigen von Benutzern und Ändern des Kennworts.

Authentifizierung ist, wenn ein Benutzer seinen Benutzernamen und sein Kennwort angibt und Sie entscheiden, ob diese Anmeldeinformationen
richtig sind oder nicht. ZF3 bietet den speziellen Service @`AuthenticationService` an, den Sie zu diesem Zweck verwenden können.
Zuerst müssen Sie einen Authentifizierungsadapter implementieren.

Die Zugriffsfilterung ermöglicht nur authentifizierten Benutzern den Zugriff auf bestimmte Seiten. Sie können die
Zugriffsfilterung mit Hilfe eines Event-Listeners implementieren.
 
